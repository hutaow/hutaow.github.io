<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Linux信号处理机制 | 胡桃夹子</title>
  <meta name="author" content="Wang Tao">
  
  <meta name="description" content="在Linux中，信号是进程间通讯的一种方式，它采用的是异步机制。当信号发送到某个进程中时，操作系统会中断该进程的正常流程，并进入相应的信号处理函数执行操作，完成后再回到中断的地方继续执行。
需要说明的是，信号只是用于通知进程发生了某个事件，除了信号本身的信息之外，并不具备传递用户数据的功能。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Linux信号处理机制"/>
  <meta property="og:site_name" content="胡桃夹子"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="胡桃夹子" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-17662168-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">胡桃夹子</a></h1>
  <h2><a href="/">open source, world shares.</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/blog/archives">文章列表</a></li>
    
      <li><a href="/about">关于我</a></li>
    
      <li><a href="/copyright">版权声明</a></li>
    
      <li><a href="/atom.xml">订阅</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <!-- added by wangtao for new date style begin -->
        <div class="date-wrapper">
          <div class="date-shadow"></div>
          <div class="date-mask"></div>
          <div class="dateTitle">
            <span class="d">19</span>
            <span class="ym">10/2013</span>
          </div>
        </div>
        <!-- added by wangtao for new date style end -->
        <!-- removed by wangtao for new date style begin -->
        
        <!-- removed by wangtao for new date style end -->
      
      
  
    <h1 class="title">Linux信号处理机制</h1>
  

    </header>
    <div class="entry">
      
        <p>在Linux中，信号是进程间通讯的一种方式，它采用的是异步机制。当信号发送到某个进程中时，操作系统会中断该进程的正常流程，并进入相应的信号处理函数执行操作，完成后再回到中断的地方继续执行。</p>
<p>需要说明的是，信号只是用于通知进程发生了某个事件，除了信号本身的信息之外，并不具备传递用户数据的功能。</p>
<a id="more"></a>

<h3>1 信号的响应动作</h3>
<p>每个信号都有自己的响应动作，当接收到信号时，进程会根据信号的响应动作执行相应的操作，信号的响应动作有以下几种：</p>
<ul>
<li>中止进程(Term)</li>
<li>忽略信号(Ign)</li>
<li>中止进程并保存内存信息(Core)</li>
<li>停止进程(Stop)</li>
<li>继续运行进程(Cont)</li>
</ul>
<p>用户可以通过<code>signal</code>或<code>sigaction</code>函数修改信号的响应动作（也就是常说的“注册信号”，在文章的后面会举例说明）。另外，在多线程中，各线程的信号响应动作都是相同的，不能对某个线程设置独立的响应动作。</p>
<h3>2 信号类型</h3>
<p>Linux支持的信号类型可以参考下面给出的列表。</p>
<h4>2.1 在POSIX.1-1990标准中的信号列表</h4>
<table>
<thead>
<tr>
<th>信号</th>
<th>值</th>
<th>动作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGHUP</td>
<td>1</td>
<td>Term</td>
<td>终端控制进程结束(终端连接断开)</td>
</tr>
<tr>
<td>SIGINT</td>
<td>2</td>
<td>Term</td>
<td>用户发送INTR字符(Ctrl+C)触发</td>
</tr>
<tr>
<td>SIGQUIT</td>
<td>3</td>
<td>Core</td>
<td>用户发送QUIT字符(Ctrl+/)触发</td>
</tr>
<tr>
<td>SIGILL</td>
<td>4</td>
<td>Core</td>
<td>非法指令(程序错误、试图执行数据段、栈溢出等)</td>
</tr>
<tr>
<td>SIGABRT</td>
<td>6</td>
<td>Core</td>
<td>调用abort函数触发</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>8</td>
<td>Core</td>
<td>算术运行错误(浮点运算错误、除数为零等)</td>
</tr>
<tr>
<td>SIGKILL</td>
<td>9</td>
<td>Term</td>
<td>无条件结束程序(不能被捕获、阻塞或忽略)</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>11</td>
<td>Core</td>
<td>无效内存引用(试图访问不属于自己的内存空间、对只读内存空间进行写操作)</td>
</tr>
<tr>
<td>SIGPIPE</td>
<td>13</td>
<td>Term</td>
<td>消息管道损坏(FIFO/Socket通信时，管道未打开而进行写操作)</td>
</tr>
<tr>
<td>SIGALRM</td>
<td>14</td>
<td>Term</td>
<td>时钟定时信号</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>15</td>
<td>Term</td>
<td>结束程序(可以被捕获、阻塞或忽略)</td>
</tr>
<tr>
<td>SIGUSR1</td>
<td>30,10,16</td>
<td>Term</td>
<td>用户保留</td>
</tr>
<tr>
<td>SIGUSR2</td>
<td>31,12,17</td>
<td>Term</td>
<td>用户保留</td>
</tr>
<tr>
<td>SIGCHLD</td>
<td>20,17,18</td>
<td>Ign</td>
<td>子进程结束(由父进程接收)</td>
</tr>
<tr>
<td>SIGCONT</td>
<td>19,18,25</td>
<td>Cont</td>
<td>继续执行已经停止的进程(不能被阻塞)</td>
</tr>
<tr>
<td>SIGSTOP</td>
<td>17,19,23</td>
<td>Stop</td>
<td>停止进程(不能被捕获、阻塞或忽略)</td>
</tr>
<tr>
<td>SIGTSTP</td>
<td>18,20,24</td>
<td>Stop</td>
<td>停止进程(可以被捕获、阻塞或忽略)</td>
</tr>
<tr>
<td>SIGTTIN</td>
<td>21,21,26</td>
<td>Stop</td>
<td>后台程序从终端中读取数据时触发</td>
</tr>
<tr>
<td>SIGTTOU</td>
<td>22,22,27</td>
<td>Stop</td>
<td>后台程序向终端中写数据时触发</td>
</tr>
</tbody>
</table>
<p><strong>注</strong>：其中<code>SIGKILL</code>和<code>SIGSTOP</code>信号不能被捕获、阻塞或忽略。</p>
<h4>2.2 在SUSv2和POSIX.1-2001标准中的信号列表</h4>
<table>
<thead>
<tr>
<th>信号</th>
<th>值</th>
<th>动作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGTRAP</td>
<td>5</td>
<td>Core</td>
<td>Trap指令触发(如断点，在调试器中使用)</td>
</tr>
<tr>
<td>SIGBUS</td>
<td>0,7,10</td>
<td>Core</td>
<td>非法地址(内存地址对齐错误)</td>
</tr>
<tr>
<td>SIGPOLL</td>
<td></td>
<td>Term</td>
<td>Pollable event (Sys V). Synonym for SIGIO</td>
</tr>
<tr>
<td>SIGPROF</td>
<td>27,27,29</td>
<td>Term</td>
<td>性能时钟信号(包含系统调用时间和进程占用CPU的时间)</td>
</tr>
<tr>
<td>SIGSYS</td>
<td>12,31,12</td>
<td>Core</td>
<td>无效的系统调用(SVr4)</td>
</tr>
<tr>
<td>SIGURG</td>
<td>16,23,21</td>
<td>Ign</td>
<td>有紧急数据到达Socket(4.2BSD)</td>
</tr>
<tr>
<td>SIGVTALRM</td>
<td>26,26,28</td>
<td>Term</td>
<td>虚拟时钟信号(进程占用CPU的时间)(4.2BSD)</td>
</tr>
<tr>
<td>SIGXCPU</td>
<td>24,24,30</td>
<td>Core</td>
<td>超过CPU时间资源限制(4.2BSD)</td>
</tr>
<tr>
<td>SIGXFSZ</td>
<td>25,25,31</td>
<td>Core</td>
<td>超过文件大小资源限制(4.2BSD)</td>
</tr>
</tbody>
</table>
<p><strong>注</strong>：在Linux 2.2版本之前，<code>SIGSYS</code>、<code>SIGXCPU</code>、<code>SIGXFSZ</code>以及<code>SIGBUS</code>的默认响应动作为Term，Linux 2.4版本之后这三个信号的默认响应动作改为Core。</p>
<h4>2.3 其它信号</h4>
<table>
<thead>
<tr>
<th>信号</th>
<th>值</th>
<th>动作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGIOT</td>
<td>6</td>
<td>Core</td>
<td>IOT捕获信号(同SIGABRT信号)</td>
</tr>
<tr>
<td>SIGEMT</td>
<td>7,-,7</td>
<td>Term</td>
<td>实时硬件发生错误</td>
</tr>
<tr>
<td>SIGSTKFLT</td>
<td>-,16,-</td>
<td>Term</td>
<td>协同处理器栈错误(未使用)</td>
</tr>
<tr>
<td>SIGIO</td>
<td>23,29,22</td>
<td>Term</td>
<td>文件描述符准备就绪(可以开始进行输入/输出操作)(4.2BSD)</td>
</tr>
<tr>
<td>SIGCLD</td>
<td>-,-,18</td>
<td>Ign</td>
<td>子进程结束(由父进程接收)(同SIGCHLD信号)</td>
</tr>
<tr>
<td>SIGPWR</td>
<td>29,30,19</td>
<td>Term</td>
<td>电源错误(System V)</td>
</tr>
<tr>
<td>SIGINFO</td>
<td>29,-,-</td>
<td></td>
<td>电源错误(同SIGPWR信号)</td>
</tr>
<tr>
<td>SIGLOST</td>
<td>-,-,-</td>
<td>Term</td>
<td>文件锁丢失(未使用)</td>
</tr>
<tr>
<td>SIGWINCH</td>
<td>28,28,20</td>
<td>Ign</td>
<td>窗口大小改变时触发(4.3BSD, Sun)</td>
</tr>
<tr>
<td>SIGUNUSED</td>
<td>-,31,-</td>
<td>Core</td>
<td>无效的系统调用(同SIGSYS信号)</td>
</tr>
</tbody>
</table>
<p><strong>注意</strong>：列表中有的信号有三个值，这是因为部分信号的值和CPU架构有关，这些信号的值在不同架构的CPU中是不同的，三个值的排列顺序为：1，Alpha/Sparc；2，x86/ARM/Others；3，MIPS。</p>
<p>例如<code>SIGSTOP</code>这个信号，它有三种可能的值，分别是17、19、23，其中第一个值（17）是用在Alpha和Sparc架构中，第二个值（19）用在x86、ARM等其它架构中，第三个值（23）则是用在MIPS架构中的。</p>
<h3>3 信号机制</h3>
<p>文章的前面提到过，信号是异步的，这就涉及信号何时接收、何时处理的问题。</p>
<p>我们知道，函数运行在用户态，当遇到系统调用、中断或是异常的情况时，程序会进入内核态。信号涉及到了这两种状态之间的转换，过程可以先看一下下面的示意图：</p>
<p><img src="/images/articles/201310/linux_signal_flow.png" alt="信号处理机制示意图"></p>
<p>接下来围绕示意图，将信号分成接收、检测和处理三个部分，逐一讲解每一步的处理流程。</p>
<h4>3.1 信号的接收</h4>
<p>接收信号的任务是由内核代理的，当内核接收到信号后，会将其放到对应进程的信号队列中，同时向进程发送一个中断，使其陷入内核态。</p>
<p>注意，此时信号还只是在队列中，对进程来说暂时是不知道有信号到来的。</p>
<h4>3.2 信号的检测</h4>
<p>进程陷入内核态后，有两种场景会对信号进行检测：</p>
<ul>
<li>进程从内核态返回到用户态前进行信号检测</li>
<li>进程在内核态中，从睡眠状态被唤醒的时候进行信号检测</li>
</ul>
<p>当发现有新信号时，便会进入下一步，信号的处理。</p>
<h4>3.3 信号的处理</h4>
<p>信号处理函数是运行在用户态的，调用处理函数前，内核会将当前内核栈的内容备份拷贝到用户栈上，并且修改指令寄存器（eip）将其指向信号处理函数。</p>
<p>接下来进程返回到用户态中，执行相应的信号处理函数。</p>
<p>信号处理函数执行完成后，还需要返回内核态，检查是否还有其它信号未处理。如果所有信号都处理完成，就会将内核栈恢复（从用户栈的备份拷贝回来），同时恢复指令寄存器（eip）将其指向中断前的运行位置，最后回到用户态继续执行进程。</p>
<p>至此，一个完整的信号处理流程便结束了，如果同时有多个信号到达，上面的处理流程会在第2步和第3步骤间重复进行。</p>
<h3>4 信号的使用</h3>
<h4>4.1 发送信号</h4>
<p>用于发送信号的函数有<code>raise</code>、<code>kill</code>、<code>killpg</code>、<code>pthread_kill</code>、<code>tgkill</code>、<code>sigqueue</code>，这几个函数的含义和用法都大同小异，这里主要介绍一下常用的<code>raise</code>和<code>kill</code>函数。</p>
<p><strong>raise函数</strong>：向进程本身发送信号</p>
<p>函数声明如下：</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;signal.h&gt;</span>

<span class="keyword">int</span> raise(<span class="keyword">int</span> sig);
</pre></td></tr></table></figure>

<p>函数功能是向当前程序(自身)发送信号，其中参数<code>sig</code>为信号值。</p>
<p><strong>kill函数</strong>：向指定进程发送信号</p>
<p>函数声明如下：</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>#include <span class="tag">&lt;<span class="title">sys</span>/<span class="attribute">types.h</span>&gt;</span>
#include <span class="tag">&lt;<span class="title">signal.h</span>&gt;</span>

int kill(pid_t pid, int sig);
</pre></td></tr></table></figure>

<p>函数功能是向特定的进程发送信号，其中参数<code>pid</code>为进程号，<code>sig</code>为信号值。</p>
<p>在这里的参数<code>pid</code>，根据取值范围不同，含义也不同，具体说明如下：</p>
<ul>
<li>pid &gt; 0  ：向进程号为pid的进程发送信号</li>
<li>pid = 0  ：向当前进程所在的进程组发送信号</li>
<li>pid = -1 ：向所有进程(除PID=1外)发送信号(权限范围内)</li>
<li>pid &lt; -1 ：向进程组号为-pid的所有进程发送信号</li>
</ul>
<p>另外，当<code>sig</code>值为零时，实际不发送任何信号，但函数返回值依然有效，可以用于检查进程是否存在。</p>
<h4>4.2 等待信号被捕获</h4>
<p>等待信号的过程，其实就是将当前进程(线程)暂停，直到有信号发到当前进程(线程)上并被捕获，函数有<code>pause</code>和<code>sigsuspend</code>。</p>
<p><strong>pause函数</strong>：将进程(或线程)转入睡眠状态，直到接收到信号</p>
<p>函数声明如下：</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;unistd.h&gt;</span>

<span class="keyword">int</span> pause(<span class="keyword">void</span>);
</pre></td></tr></table></figure>

<p>该函数调用后，调用者(进程或线程)会进入睡眠(Sleep)状态，直到捕获到(任意)信号为止。该函数的返回值始终为-1，并且调用结束后，错误代码(errno)会被置为EINTR。</p>
<p><strong>sigsuspend函数</strong>：将进程(或线程)转入睡眠状态，直到接收到特定信号</p>
<p>函数声明如下：</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;signal.h&gt;</span>

<span class="keyword">int</span> sigsuspend(<span class="keyword">const</span> sigset_t *mask);
</pre></td></tr></table></figure>

<p>该函数调用后，会将进程的信号掩码临时修改(参数<code>mask</code>)，然后暂停进程，直到收到符合条件的信号为止，函数返回前会将调用前的信号掩码恢复。该函数的返回值始终为-1，并且调用结束后，错误代码(errno)会被置为EINTR。</p>
<h4>4.3 修改信号的响应动作</h4>
<p>用户可以自己重新定义某个信号的处理方式，即前面提到的修改信号的默认响应动作，也可以理解为对信号的注册，可以通过<code>signal</code>或<code>sigaction</code>函数进行，这里以<code>signal</code>函数举例说明。</p>
<p>首先看一下函数声明：</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>#include &lt;signal.h&gt;

typedef void <span class="comment">(*sighandler_t)(int);

sighandler_t signal(int signum, sighandler_t handler);
</pre></td></tr></table></figure>

<p>第一个参数<code>signum</code>是信号值，可以从前面的信号列表中查到，第二个参数<code>handler</code>为处理函数，通过回调方式在信号触发时调用。</p>
<p>下面为示例代码：</p>
<figure class="highlight lang-c"><figcaption><span>Example of Linux Signal </span><a href="/downloads/code/linux_signal.c">download</a></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;signal.h&gt;</span>
<span class="preprocessor">#include &lt;unistd.h&gt;</span>

<span class="comment">/* 信号处理函数 */</span>
<span class="keyword">void</span> sig_callback(<span class="keyword">int</span> signum) {
    <span class="keyword">switch</span> (signum) {
        <span class="keyword">case</span> SIGINT:
            <span class="comment">/* SIGINT: Ctrl+C 按下时触发 */</span>
            printf(<span class="string">"Get signal SIGINT. \r\n"</span>);
            <span class="keyword">break</span>;
        <span class="comment">/* 多个信号可以放到同一个函数中进行 通过信号值来区分 */</span>
        <span class="keyword">default</span>:
            <span class="comment">/* 其它信号 */</span>
            printf(<span class="string">"Unknown signal %d. \r\n"</span>, signum);
            <span class="keyword">break</span>;
    }

    <span class="keyword">return</span>;
}

<span class="comment">/* 主函数 */</span>
<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) {
    printf(<span class="string">"Register SIGINT(%u) Signal Action. \r\n"</span>, SIGINT);

    <span class="comment">/* 注册SIGINT信号的处理函数 */</span>
    <span class="keyword">signal</span>(SIGINT, sig_callback);

    printf(<span class="string">"Waitting for Signal ... \r\n"</span>);

    <span class="comment">/* 等待信号触发 */</span>
    pause();

    printf(<span class="string">"Process Continue. \r\n"</span>);

    <span class="keyword">return</span> <span class="number">0</span>;
}


</pre></td></tr></table></figure>


<p>例子中，将<code>SIGINT</code>信号（<code>Ctrl+C</code>触发）的动作接管(打印提示信息)，程序运行后，按下<code>Ctrl+C</code>，命令行输出如下：</p>
<pre><code>./linux_signal_example
Register SIGINT(<span class="number">2</span>) Signal Action. 
Waitting <span class="keyword">for</span> Signal <span class="keyword">...</span> 
^CGet signal SIGINT. 
Process Continue.</code></pre>
<p>进程收到<code>SIGINT</code>信号后，触发响应动作，将提示信息打印出来，然后从暂停的地方继续运行。这里需要注意的是，因为我们修改了<code>SIGINT</code>信号的响应动作（只打印信息，不做进程退出处理），所以我们按下<code>Ctrl+C</code>后，程序并没有直接退出，而是继续运行并将“Process Continue.”打印出来，直至程序正常结束。</p>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/blog/categories/Linux/">Linux</a>
  </div>

        
  
  <div class="tags">
    <a href="/blog/tags/Linux/">Linux</a>, <a href="/blog/tags/C/">C</a>, <a href="/blog/tags/开发/">开发</a>, <a href="/blog/tags/信号/">信号</a>
  </div>

        
        
  <!-- Baidu Button BEGIN -->
  <div id="bdshare" class="bdshare_t bds_tools get-codes-bdshare">
    <span class="bds_more">分享到：</span>
    <a class="bds_tsina">新浪微博</a>
    <a class="bds_renren">人人网</a>
    <a class="bds_youdao">有道云笔记</a>
    <a class="bds_hi">百度空间</a>
    <a class="bds_mail">邮件分享</a>
    <a class="shareCount"></a>
  </div>
  <script type="text/javascript" id="bdshare_js" data="type=tools&amp;uid=3588804" ></script>
  <script type="text/javascript" id="bdshell_js"></script>
  <script type="text/javascript">
    document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + Math.ceil(new Date()/3600000);
  </script>
  <!-- Baidu Button END -->

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:hutaow.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/blog/categories/Database/">Database</a><small>1</small></li>
  
    <li><a href="/blog/categories/Life/">Life</a><small>1</small></li>
  
    <li><a href="/blog/categories/Linux/">Linux</a><small>17</small></li>
  
    <li><a href="/blog/categories/Network/">Network</a><small>2</small></li>
  
    <li><a href="/blog/categories/Programming/">Programming</a><small>17</small></li>
  
    <li><a href="/blog/categories/Protocol/">Protocol</a><small>1</small></li>
  
    <li><a href="/blog/categories/Security/">Security</a><small>2</small></li>
  
    <li><a href="/blog/categories/Technology/">Technology</a><small>3</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/blog/tags/ATL/" style="font-size: 10.00px;">ATL</a><a href="/blog/tags/Android/" style="font-size: 18.00px;">Android</a><a href="/blog/tags/ArchLinux/" style="font-size: 10.00px;">ArchLinux</a><a href="/blog/tags/C/" style="font-size: 16.00px;">C</a><a href="/blog/tags/CScope/" style="font-size: 10.00px;">CScope</a><a href="/blog/tags/CSharp/" style="font-size: 10.00px;">CSharp</a><a href="/blog/tags/CTags/" style="font-size: 10.00px;">CTags</a><a href="/blog/tags/CoreDump/" style="font-size: 10.00px;">CoreDump</a><a href="/blog/tags/Fcitx/" style="font-size: 10.00px;">Fcitx</a><a href="/blog/tags/Fedora/" style="font-size: 12.00px;">Fedora</a><a href="/blog/tags/Foxmarks/" style="font-size: 10.00px;">Foxmarks</a><a href="/blog/tags/GDB/" style="font-size: 10.00px;">GDB</a><a href="/blog/tags/IDS/" style="font-size: 12.00px;">IDS</a><a href="/blog/tags/Java/" style="font-size: 16.00px;">Java</a><a href="/blog/tags/KDE/" style="font-size: 10.00px;">KDE</a><a href="/blog/tags/Linux/" style="font-size: 20.00px;">Linux</a><a href="/blog/tags/MPlayer/" style="font-size: 10.00px;">MPlayer</a><a href="/blog/tags/MySQL/" style="font-size: 12.00px;">MySQL</a><a href="/blog/tags/OProfile/" style="font-size: 10.00px;">OProfile</a><a href="/blog/tags/OpenWRT/" style="font-size: 10.00px;">OpenWRT</a><a href="/blog/tags/PXE/" style="font-size: 10.00px;">PXE</a><a href="/blog/tags/Protocol/" style="font-size: 10.00px;">Protocol</a><a href="/blog/tags/PyQT/" style="font-size: 10.00px;">PyQT</a><a href="/blog/tags/Python/" style="font-size: 12.00px;">Python</a><a href="/blog/tags/QT/" style="font-size: 10.00px;">QT</a><a href="/blog/tags/Rhythmbox/" style="font-size: 10.00px;">Rhythmbox</a><a href="/blog/tags/SQL/" style="font-size: 10.00px;">SQL</a><a href="/blog/tags/Snort/" style="font-size: 10.00px;">Snort</a><a href="/blog/tags/TagList/" style="font-size: 10.00px;">TagList</a><a href="/blog/tags/VI/" style="font-size: 12.00px;">VI</a><a href="/blog/tags/VirtualBox/" style="font-size: 10.00px;">VirtualBox</a><a href="/blog/tags/XML/" style="font-size: 10.00px;">XML</a><a href="/blog/tags/Xmarks/" style="font-size: 10.00px;">Xmarks</a><a href="/blog/tags/交换机/" style="font-size: 10.00px;">交换机</a><a href="/blog/tags/代理/" style="font-size: 10.00px;">代理</a><a href="/blog/tags/信号/" style="font-size: 10.00px;">信号</a><a href="/blog/tags/入侵检测/" style="font-size: 12.00px;">入侵检测</a><a href="/blog/tags/协议分析/" style="font-size: 10.00px;">协议分析</a><a href="/blog/tags/字符编码/" style="font-size: 10.00px;">字符编码</a><a href="/blog/tags/定位/" style="font-size: 14.00px;">定位</a>
  </div>
</div>


  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/blog/2013/12/29/performance-analysis-with-oprofile/">使用OProfile进行性能分析</a>
      </li>
    
      <li>
        <a href="/blog/2013/12/24/convert-python-script-to-executable-program/">将 Python 脚本转换为可执行程序</a>
      </li>
    
      <li>
        <a href="/blog/2013/12/16/using-pyqt-as-graphical-interface-for-python/">使用 PyQT 作为 Python 的图形界面</a>
      </li>
    
      <li>
        <a href="/blog/2013/12/05/string-size-calculation/">类型转换导致字符串大小计算错误的问题</a>
      </li>
    
      <li>
        <a href="/blog/2013/11/22/vim-development-environment/">配置 VIM 开发环境</a>
      </li>
    
      <li>
        <a href="/blog/2013/11/18/configure-the-fcitx-in-archlinux/">在 ArchLinux 中使用 Fcitx 输入法</a>
      </li>
    
      <li>
        <a href="/blog/2013/11/06/mysql-protocol-analysis/">MySQL协议分析</a>
      </li>
    
      <li>
        <a href="/blog/2013/10/30/install-linux-with-pxe/">通过PXE方式安装Linux系统</a>
      </li>
    
      <li>
        <a href="/blog/2013/10/25/linux-core-dump/">Linux中生成 Core Dump 文件的方法</a>
      </li>
    
      <li>
        <a href="/blog/2013/10/19/linux-signal/">Linux信号处理机制</a>
      </li>
    
  </ul>
</div>


</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2013 Wang Tao
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
var disqus_shortname = 'hutaow';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>