<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[胡桃夹子]]></title>
  <subtitle><![CDATA[open source, world shares.]]></subtitle>
  <link href="http://hutaow.net/atom.xml" rel="self"/>
  <link href="http://hutaow.net"/>
  <updated>2013-10-26T14:14:13.909Z</updated>
  <id>http://hutaow.net/</id>
  <author>
    <name><![CDATA[Wang Tao]]></name>
    <email><![CDATA[hutaow@gmail.com]]></email>
  </author>
  <generator uri="http://zespia.tw/hexo">Hexo</generator>
  <entry>
    <title type="html"><![CDATA[Linux中生成 Core Dump 文件的方法]]></title>
    <link href="http://hutaow.net/blog/2013/10/25/linux-core-dump/"/>
    <id>http://hutaow.net/blog/2013/10/25/linux-core-dump/</id>
    <published>2013-10-25T15:19:39.000Z</published>
    <updated>2013-10-26T14:13:25.000Z</updated>
    <content type="html"><![CDATA[<h3>1 什么是 Core Dump</h3>
<p>Core Dump 又叫核心转储。在程序运行过程中发生异常退出时，将其所使用的内存数据保存到文件中，这个过程叫做 Core Dump。</p>
<h3>2 Core Dump 的作用</h3>
<p>在开发过程中，难免会遇到程序运行过程中异常退出的情况，这时候想要定位哪里出了问题，仅仅依靠程序自身的信息打印（日志记录）往往是不够的，这个时候就需要 Core Dump 文件来帮忙了。</p>
<p>一个完整的 Core Dump 文件实际上相当于恢复了异常现场，利用 Core Dump 文件，可以查看到程序异常时的所有信息，变量值、栈信息、内存数据，程序异常时的运行位置（甚至记录代码行号）等等，定位所需要的一切信息都可以从 Core Dump文件获取到，能够非常有效的提高定位效率。</p>
<a id="more"></a>

<h3>3 如何生成 Core Dump</h3>
<h4>3.1 Core Dump 文件生成开关</h4>
<p>Core Dump 文件的生成是由Core文件大小限制，Linux中默认的Core文件大小设置为零，也就是不生成 Core Dump 文件，可以使用<code>ulimit -c</code>命令来查看当前的Core文件大小限制。</p>
<p>要生成 Core Dump 文件，只需要执行下面的命令设置Core文件的大小即可（其中<code>filesize</code>参数的单位为KByte）：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">ulimit</span> -c filesize
</pre></td></tr></table></figure>

<p>如果要设置Core文件大小无限制（即把程序完整的运行内存都保存下来），则执行如下命令：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">ulimit</span> -c unlimited
</pre></td></tr></table></figure>

<h4>3.2 Core Dump 文件名设置</h4>
<p>Core Dump 文件默认的名字为<code>core</code>，而且新的Core文件会把老的覆盖，这样我们只能看到最后一次的 Core Dump 信息，可以通过设置Core文件名称模板，使每次生成的 Core Dump 文件区分开来。</p>
<p>Core Dump 文件的命名规则定义在<code>/proc/sys/kernel/core_pattern</code>文件中，规则中还可以加入预设的变量来更好的区分Core文件，支持的变量列表如下：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>%%</td>
<td><code>%</code>字符</td>
</tr>
<tr>
<td>%p</td>
<td>进程ID(PID)</td>
</tr>
<tr>
<td>%u</td>
<td>用户ID(UID)</td>
</tr>
<tr>
<td>%g</td>
<td>用户组ID</td>
</tr>
<tr>
<td>%s</td>
<td>触发 Core Dump 的信号</td>
</tr>
<tr>
<td>%t</td>
<td>触发 Core Dump 的时间(单位为秒，从 1970-01-01 00:00:00 开始计算)</td>
</tr>
<tr>
<td>%h</td>
<td>主机名称(主机名可以通过<code>uname</code>命令来查看)</td>
</tr>
<tr>
<td>%e</td>
<td>程序名称(无路径信息)</td>
</tr>
<tr>
<td>%E</td>
<td>程序的路径名称(路径中的<code>/</code>会被<code>!</code>替代)</td>
</tr>
<tr>
<td>%c</td>
<td>Core文件的限制大小值(Linux 2.6.24版本后开始支持)</td>
</tr>
</tbody>
</table>
<p>注：Core Dump 文件名的最大长度为128字节（在 Linux 2.6.19 版本前，最大长度为64字节）。</p>
<p>例如：可以通过下面的命令，生成文件名为<code>core-程序名称-进程ID-时间</code>的 Core Dump 文件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>echo <span class="string">"core-<span class="variable">%e</span>-<span class="variable">%p</span>-<span class="variable">%t</span>"</span> &gt; <span class="regexp">/proc/sys</span><span class="regexp">/kernel/core</span>_pattern
</pre></td></tr></table></figure>

<p>从 Linux 2.4 版本开始，提供了一种比较原始的Core文件名设置方式，直接设置<code>/proc/sys/kernel/core_uses_pid</code>文件中的值为1，生成的Core文件名中便会自动加上<code>.PID</code>后缀，即生成的文件名为<code>core.PID</code>这种形式。执行下面的命令可以设置该值：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>echo <span class="string">"1"</span> &gt; <span class="regexp">/proc/sys</span><span class="regexp">/kernel/core</span>_uses_pid
</pre></td></tr></table></figure>

<h3>4 如何使用 Core Dump</h3>
<p>有了 Core Dump 文件后，可以使用GDB来加载分析，执行如下命令（假设可执行程序名称及路径为<code>/home/hutaow/test_dump</code>，生成的Core文件名为<code>core</code>）：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">gdb</span> /home/hutaow/test_dump -c core
</pre></td></tr></table></figure>

<p>加载完成后，即可以在GDB中查看程序异常时的各种运行信息了（查看变量值、线程信息、调用栈、反汇编等等）。</p>
]]></content>
    <category scheme="http://hutaow.net/blog/tags/Linux/" term="Linux"/>
    <category scheme="http://hutaow.net/blog/tags/CoreDump/" term="CoreDump"/>
    <category scheme="http://hutaow.net/blog/tags/GDB/" term="GDB"/>
    <category scheme="http://hutaow.net/blog/tags/开发/" term="开发"/>
    <category scheme="http://hutaow.net/blog/tags/定位/" term="定位"/>
    <category scheme="http://hutaow.net/blog/categories/Programming/" term="Programming"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Linux信号处理机制]]></title>
    <link href="http://hutaow.net/blog/2013/10/19/linux-signal/"/>
    <id>http://hutaow.net/blog/2013/10/19/linux-signal/</id>
    <published>2013-10-19T13:47:22.000Z</published>
    <updated>2013-10-23T19:14:16.000Z</updated>
    <content type="html"><![CDATA[<p>在Linux中，信号是进程间通讯的一种方式，它采用的是异步机制。当信号发送到某个进程中时，操作系统会中断该进程的正常流程，并进入相应的信号处理函数执行操作，完成后再回到中断的地方继续执行。</p>
<p>需要说明的是，信号只是用于通知进程发生了某个事件，除了信号本身的信息之外，并不具备传递用户数据的功能。</p>
<a id="more"></a>

<h3>1 信号的响应动作</h3>
<p>每个信号都有自己的响应动作，当接收到信号时，进程会根据信号的响应动作执行相应的操作，信号的响应动作有以下几种：</p>
<ul>
<li>中止进程(Term)</li>
<li>忽略信号(Ign)</li>
<li>中止进程并保存内存信息(Core)</li>
<li>停止进程(Stop)</li>
<li>继续运行进程(Cont)</li>
</ul>
<p>用户可以通过<code>signal</code>或<code>sigaction</code>函数修改信号的响应动作（也就是常说的“注册信号”，在文章的后面会举例说明）。另外，在多线程中，各线程的信号响应动作都是相同的，不能对某个线程设置独立的响应动作。</p>
<h3>2 信号类型</h3>
<p>Linux支持的信号类型可以参考下面给出的列表。</p>
<h4>2.1 在POSIX.1-1990标准中的信号列表</h4>
<table>
<thead>
<tr>
<th>信号</th>
<th>值</th>
<th>动作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGHUP</td>
<td>1</td>
<td>Term</td>
<td>终端控制进程结束(终端连接断开)</td>
</tr>
<tr>
<td>SIGINT</td>
<td>2</td>
<td>Term</td>
<td>用户发送INTR字符(Ctrl+C)触发</td>
</tr>
<tr>
<td>SIGQUIT</td>
<td>3</td>
<td>Core</td>
<td>用户发送QUIT字符(Ctrl+/)触发</td>
</tr>
<tr>
<td>SIGILL</td>
<td>4</td>
<td>Core</td>
<td>非法指令(程序错误、试图执行数据段、栈溢出等)</td>
</tr>
<tr>
<td>SIGABRT</td>
<td>6</td>
<td>Core</td>
<td>调用abort函数触发</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>8</td>
<td>Core</td>
<td>算术运行错误(浮点运算错误、除数为零等)</td>
</tr>
<tr>
<td>SIGKILL</td>
<td>9</td>
<td>Term</td>
<td>无条件结束程序(不能被捕获、阻塞或忽略)</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>11</td>
<td>Core</td>
<td>无效内存引用(试图访问不属于自己的内存空间、对只读内存空间进行写操作)</td>
</tr>
<tr>
<td>SIGPIPE</td>
<td>13</td>
<td>Term</td>
<td>消息管道损坏(FIFO/Socket通信时，管道未打开而进行写操作)</td>
</tr>
<tr>
<td>SIGALRM</td>
<td>14</td>
<td>Term</td>
<td>时钟定时信号</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>15</td>
<td>Term</td>
<td>结束程序(可以被捕获、阻塞或忽略)</td>
</tr>
<tr>
<td>SIGUSR1</td>
<td>30,10,16</td>
<td>Term</td>
<td>用户保留</td>
</tr>
<tr>
<td>SIGUSR2</td>
<td>31,12,17</td>
<td>Term</td>
<td>用户保留</td>
</tr>
<tr>
<td>SIGCHLD</td>
<td>20,17,18</td>
<td>Ign</td>
<td>子进程结束(由父进程接收)</td>
</tr>
<tr>
<td>SIGCONT</td>
<td>19,18,25</td>
<td>Cont</td>
<td>继续执行已经停止的进程(不能被阻塞)</td>
</tr>
<tr>
<td>SIGSTOP</td>
<td>17,19,23</td>
<td>Stop</td>
<td>停止进程(不能被捕获、阻塞或忽略)</td>
</tr>
<tr>
<td>SIGTSTP</td>
<td>18,20,24</td>
<td>Stop</td>
<td>停止进程(可以被捕获、阻塞或忽略)</td>
</tr>
<tr>
<td>SIGTTIN</td>
<td>21,21,26</td>
<td>Stop</td>
<td>后台程序从终端中读取数据时触发</td>
</tr>
<tr>
<td>SIGTTOU</td>
<td>22,22,27</td>
<td>Stop</td>
<td>后台程序向终端中写数据时触发</td>
</tr>
</tbody>
</table>
<p><strong>注</strong>：其中<code>SIGKILL</code>和<code>SIGSTOP</code>信号不能被捕获、阻塞或忽略。</p>
<h4>2.2 在SUSv2和POSIX.1-2001标准中的信号列表</h4>
<table>
<thead>
<tr>
<th>信号</th>
<th>值</th>
<th>动作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGTRAP</td>
<td>5</td>
<td>Core</td>
<td>Trap指令触发(如断点，在调试器中使用)</td>
</tr>
<tr>
<td>SIGBUS</td>
<td>0,7,10</td>
<td>Core</td>
<td>非法地址(内存地址对齐错误)</td>
</tr>
<tr>
<td>SIGPOLL</td>
<td></td>
<td>Term</td>
<td>Pollable event (Sys V). Synonym for SIGIO</td>
</tr>
<tr>
<td>SIGPROF</td>
<td>27,27,29</td>
<td>Term</td>
<td>性能时钟信号(包含系统调用时间和进程占用CPU的时间)</td>
</tr>
<tr>
<td>SIGSYS</td>
<td>12,31,12</td>
<td>Core</td>
<td>无效的系统调用(SVr4)</td>
</tr>
<tr>
<td>SIGURG</td>
<td>16,23,21</td>
<td>Ign</td>
<td>有紧急数据到达Socket(4.2BSD)</td>
</tr>
<tr>
<td>SIGVTALRM</td>
<td>26,26,28</td>
<td>Term</td>
<td>虚拟时钟信号(进程占用CPU的时间)(4.2BSD)</td>
</tr>
<tr>
<td>SIGXCPU</td>
<td>24,24,30</td>
<td>Core</td>
<td>超过CPU时间资源限制(4.2BSD)</td>
</tr>
<tr>
<td>SIGXFSZ</td>
<td>25,25,31</td>
<td>Core</td>
<td>超过文件大小资源限制(4.2BSD)</td>
</tr>
</tbody>
</table>
<p><strong>注</strong>：在Linux 2.2版本之前，<code>SIGSYS</code>、<code>SIGXCPU</code>、<code>SIGXFSZ</code>以及<code>SIGBUS</code>的默认响应动作为Term，Linux 2.4版本之后这三个信号的默认响应动作改为Core。</p>
<h4>2.3 其它信号</h4>
<table>
<thead>
<tr>
<th>信号</th>
<th>值</th>
<th>动作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGIOT</td>
<td>6</td>
<td>Core</td>
<td>IOT捕获信号(同SIGABRT信号)</td>
</tr>
<tr>
<td>SIGEMT</td>
<td>7,-,7</td>
<td>Term</td>
<td>实时硬件发生错误</td>
</tr>
<tr>
<td>SIGSTKFLT</td>
<td>-,16,-</td>
<td>Term</td>
<td>协同处理器栈错误(未使用)</td>
</tr>
<tr>
<td>SIGIO</td>
<td>23,29,22</td>
<td>Term</td>
<td>文件描述符准备就绪(可以开始进行输入/输出操作)(4.2BSD)</td>
</tr>
<tr>
<td>SIGCLD</td>
<td>-,-,18</td>
<td>Ign</td>
<td>子进程结束(由父进程接收)(同SIGCHLD信号)</td>
</tr>
<tr>
<td>SIGPWR</td>
<td>29,30,19</td>
<td>Term</td>
<td>电源错误(System V)</td>
</tr>
<tr>
<td>SIGINFO</td>
<td>29,-,-</td>
<td></td>
<td>电源错误(同SIGPWR信号)</td>
</tr>
<tr>
<td>SIGLOST</td>
<td>-,-,-</td>
<td>Term</td>
<td>文件锁丢失(未使用)</td>
</tr>
<tr>
<td>SIGWINCH</td>
<td>28,28,20</td>
<td>Ign</td>
<td>窗口大小改变时触发(4.3BSD, Sun)</td>
</tr>
<tr>
<td>SIGUNUSED</td>
<td>-,31,-</td>
<td>Core</td>
<td>无效的系统调用(同SIGSYS信号)</td>
</tr>
</tbody>
</table>
<p><strong>注意</strong>：列表中有的信号有三个值，这是因为部分信号的值和CPU架构有关，这些信号的值在不同架构的CPU中是不同的，三个值的排列顺序为：1，Alpha/Sparc；2，x86/ARM/Others；3，MIPS。</p>
<p>例如<code>SIGSTOP</code>这个信号，它有三种可能的值，分别是17、19、23，其中第一个值（17）是用在Alpha和Sparc架构中，第二个值（19）用在x86、ARM等其它架构中，第三个值（23）则是用在MIPS架构中的。</p>
<h3>3 信号机制</h3>
<p>文章的前面提到过，信号是异步的，这就涉及信号何时接收、何时处理的问题。</p>
<p>我们知道，函数运行在用户态，当遇到系统调用、中断或是异常的情况时，程序会进入内核态。信号涉及到了这两种状态之间的转换，过程可以先看一下下面的示意图：</p>
<p><img src="/images/articles/201310/linux_signal_flow.png" alt="信号处理机制示意图"></p>
<p>接下来围绕示意图，将信号分成接收、检测和处理三个部分，逐一讲解每一步的处理流程。</p>
<h4>3.1 信号的接收</h4>
<p>接收信号的任务是由内核代理的，当内核接收到信号后，会将其放到对应进程的信号队列中，同时向进程发送一个中断，使其陷入内核态。</p>
<p>注意，此时信号还只是在队列中，对进程来说暂时是不知道有信号到来的。</p>
<h4>3.2 信号的检测</h4>
<p>进程陷入内核态后，有两种场景会对信号进行检测：</p>
<ul>
<li>进程从内核态返回到用户态前进行信号检测</li>
<li>进程在内核态中，从睡眠状态被唤醒的时候进行信号检测</li>
</ul>
<p>当发现有新信号时，便会进入下一步，信号的处理。</p>
<h4>3.3 信号的处理</h4>
<p>信号处理函数是运行在用户态的，调用处理函数前，内核会将当前内核栈的内容备份拷贝到用户栈上，并且修改指令寄存器（eip）将其指向信号处理函数。</p>
<p>接下来进程返回到用户态中，执行相应的信号处理函数。</p>
<p>信号处理函数执行完成后，还需要返回内核态，检查是否还有其它信号未处理。如果所有信号都处理完成，就会将内核栈恢复（从用户栈的备份拷贝回来），同时恢复指令寄存器（eip）将其指向中断前的运行位置，最后回到用户态继续执行进程。</p>
<p>至此，一个完整的信号处理流程便结束了，如果同时有多个信号到达，上面的处理流程会在第2步和第3步骤间重复进行。</p>
<h3>4 信号的使用</h3>
<h4>4.1 发送信号</h4>
<p>用于发送信号的函数有<code>raise</code>、<code>kill</code>、<code>killpg</code>、<code>pthread_kill</code>、<code>tgkill</code>、<code>sigqueue</code>，这几个函数的含义和用法都大同小异，这里主要介绍一下常用的<code>raise</code>和<code>kill</code>函数。</p>
<p><strong>raise函数</strong>：向进程本身发送信号</p>
<p>函数声明如下：</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;signal.h&gt;</span>

<span class="keyword">int</span> raise(<span class="keyword">int</span> sig);
</pre></td></tr></table></figure>

<p>函数功能是向当前程序(自身)发送信号，其中参数<code>sig</code>为信号值。</p>
<p><strong>kill函数</strong>：向指定进程发送信号</p>
<p>函数声明如下：</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>#include <span class="tag">&lt;<span class="title">sys</span>/<span class="attribute">types.h</span>&gt;</span>
#include <span class="tag">&lt;<span class="title">signal.h</span>&gt;</span>

int kill(pid_t pid, int sig);
</pre></td></tr></table></figure>

<p>函数功能是向特定的进程发送信号，其中参数<code>pid</code>为进程号，<code>sig</code>为信号值。</p>
<p>在这里的参数<code>pid</code>，根据取值范围不同，含义也不同，具体说明如下：</p>
<ul>
<li>pid &gt; 0  ：向进程号为pid的进程发送信号</li>
<li>pid = 0  ：向当前进程所在的进程组发送信号</li>
<li>pid = -1 ：向所有进程(除PID=1外)发送信号(权限范围内)</li>
<li>pid &lt; -1 ：向进程组号为-pid的所有进程发送信号</li>
</ul>
<p>另外，当<code>sig</code>值为零时，实际不发送任何信号，但函数返回值依然有效，可以用于检查进程是否存在。</p>
<h4>4.2 等待信号被捕获</h4>
<p>等待信号的过程，其实就是将当前进程(线程)暂停，直到有信号发到当前进程(线程)上并被捕获，函数有<code>pause</code>和<code>sigsuspend</code>。</p>
<p><strong>pause函数</strong>：将进程(或线程)转入睡眠状态，直到接收到信号</p>
<p>函数声明如下：</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;unistd.h&gt;</span>

<span class="keyword">int</span> pause(<span class="keyword">void</span>);
</pre></td></tr></table></figure>

<p>该函数调用后，调用者(进程或线程)会进入睡眠(Sleep)状态，直到捕获到(任意)信号为止。该函数的返回值始终为-1，并且调用结束后，错误代码(errno)会被置为EINTR。</p>
<p><strong>sigsuspend函数</strong>：将进程(或线程)转入睡眠状态，直到接收到特定信号</p>
<p>函数声明如下：</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;signal.h&gt;</span>

<span class="keyword">int</span> sigsuspend(<span class="keyword">const</span> sigset_t *mask);
</pre></td></tr></table></figure>

<p>该函数调用后，会将进程的信号掩码临时修改(参数<code>mask</code>)，然后暂停进程，直到收到符合条件的信号为止，函数返回前会将调用前的信号掩码恢复。该函数的返回值始终为-1，并且调用结束后，错误代码(errno)会被置为EINTR。</p>
<h4>4.3 修改信号的响应动作</h4>
<p>用户可以自己重新定义某个信号的处理方式，即前面提到的修改信号的默认响应动作，也可以理解为对信号的注册，可以通过<code>signal</code>或<code>sigaction</code>函数进行，这里以<code>signal</code>函数举例说明。</p>
<p>首先看一下函数声明：</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>#include &lt;signal.h&gt;

typedef void <span class="comment">(*sighandler_t)(int);

sighandler_t signal(int signum, sighandler_t handler);
</pre></td></tr></table></figure>

<p>第一个参数<code>signum</code>是信号值，可以从前面的信号列表中查到，第二个参数<code>handler</code>为处理函数，通过回调方式在信号触发时调用。</p>
<p>下面为示例代码：</p>
<figure class="highlight lang-c"><figcaption><span>Example of Linux Signal </span><a href="/downloads/code/linux_signal.c">download</a></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;signal.h&gt;</span>
<span class="preprocessor">#include &lt;unistd.h&gt;</span>

<span class="comment">/* 信号处理函数 */</span>
<span class="keyword">void</span> sig_callback(<span class="keyword">int</span> signum) {
    <span class="keyword">switch</span> (signum) {
        <span class="keyword">case</span> SIGINT:
            <span class="comment">/* SIGINT: Ctrl+C 按下时触发 */</span>
            printf(<span class="string">"Get signal SIGINT. \r\n"</span>);
            <span class="keyword">break</span>;
        <span class="comment">/* 多个信号可以放到同一个函数中进行 通过信号值来区分 */</span>
        <span class="keyword">default</span>:
            <span class="comment">/* 其它信号 */</span>
            printf(<span class="string">"Unknown signal %d. \r\n"</span>, signum);
            <span class="keyword">break</span>;
    }

    <span class="keyword">return</span>;
}

<span class="comment">/* 主函数 */</span>
<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) {
    printf(<span class="string">"Register SIGINT(%u) Signal Action. \r\n"</span>, SIGINT);

    <span class="comment">/* 注册SIGINT信号的处理函数 */</span>
    <span class="keyword">signal</span>(SIGINT, sig_callback);

    printf(<span class="string">"Waitting for Signal ... \r\n"</span>);

    <span class="comment">/* 等待信号触发 */</span>
    pause();

    printf(<span class="string">"Process Continue. \r\n"</span>);

    <span class="keyword">return</span> <span class="number">0</span>;
}


</pre></td></tr></table></figure>


<p>例子中，将<code>SIGINT</code>信号（<code>Ctrl+C</code>触发）的动作接管(打印提示信息)，程序运行后，按下<code>Ctrl+C</code>，命令行输出如下：</p>
<pre><code>./linux_signal_example
Register SIGINT(<span class="number">2</span>) Signal Action. 
Waitting <span class="keyword">for</span> Signal <span class="keyword">...</span> 
^CGet signal SIGINT. 
Process Continue.</code></pre>
<p>进程收到<code>SIGINT</code>信号后，触发响应动作，将提示信息打印出来，然后从暂停的地方继续运行。这里需要注意的是，因为我们修改了<code>SIGINT</code>信号的响应动作（只打印信息，不做进程退出处理），所以我们按下<code>Ctrl+C</code>后，程序并没有直接退出，而是继续运行并将“Process Continue.”打印出来，直至程序正常结束。</p>
]]></content>
    <category scheme="http://hutaow.net/blog/tags/Linux/" term="Linux"/>
    <category scheme="http://hutaow.net/blog/tags/C/" term="C"/>
    <category scheme="http://hutaow.net/blog/tags/开发/" term="开发"/>
    <category scheme="http://hutaow.net/blog/tags/信号/" term="信号"/>
    <category scheme="http://hutaow.net/blog/categories/Linux/" term="Linux"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[函数调用栈的获取原理分析]]></title>
    <link href="http://hutaow.net/blog/2013/10/15/dump-stack/"/>
    <id>http://hutaow.net/blog/2013/10/15/dump-stack/</id>
    <published>2013-10-15T15:32:31.000Z</published>
    <updated>2013-10-18T12:53:47.000Z</updated>
    <content type="html"><![CDATA[<p>上一篇文章<a href="/blog/2013/10/11/dump-stack-with-backtrace">《在Linux程序中输出函数调用栈》</a>，讲述了在Linux中如何利用backtrace获取调用栈，本篇文章主要介绍一下获取函数调用栈的原理，并给出相应的实现方式。</p>
<a id="more"></a>

<p>要了解调用栈，首先需要了解函数的调用过程，下面用一段代码作为例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="comment">#include &lt;stdio.h&gt;</span>

<span class="keyword">int</span> add(<span class="keyword">int</span> a, <span class="keyword">int</span> b) {
    <span class="keyword">int</span> result = <span class="number">0</span>;

    result = a + b;

    <span class="keyword">return</span> result;
}

<span class="keyword">int</span> main(<span class="keyword">int</span> argc, char <span class="variable">*argv</span>[]) {
    <span class="keyword">int</span> result = <span class="number">0</span>;

    result = test(<span class="number">1</span>, <span class="number">2</span>);

    <span class="keyword">printf</span>(<span class="string">"result = <span class="variable">%d</span> \r\n"</span>, result);

    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>

<p>使用gcc编译，然后gdb反汇编main函数，看看它是如何调用add函数的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="xml">(gdb) disassemble main 
Dump of assembler code for function main:
   </span><span class="number">0x08048439</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">0</span><span class="xml">&gt;:     push   %ebp
   </span><span class="number">0x0804843a</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">1</span><span class="xml">&gt;:     mov    %esp,%ebp
   </span><span class="number">0x0804843c</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">3</span><span class="xml">&gt;:     and    </span><span class="variable">$0xfffffff0</span><span class="xml">,%esp
   </span><span class="number">0x0804843f</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">6</span><span class="xml">&gt;:     sub    </span><span class="variable">$0x20</span><span class="xml">,%esp
   </span><span class="number">0x08048442</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">9</span><span class="xml">&gt;:     movl   </span><span class="variable">$0x0</span><span class="xml">,</span><span class="number">0x1c</span><span class="xml">(%esp)  # 给result变量赋</span><span class="number">0</span><span class="xml">值
   </span><span class="number">0x0804844a</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">17</span><span class="xml">&gt;:    movl   </span><span class="variable">$0x2</span><span class="xml">,</span><span class="number">0x4</span><span class="xml">(%esp)   # 将第</span><span class="number">2</span><span class="xml">个参数压栈(该参数偏移为esp+</span><span class="number">0x04</span><span class="xml">)
   </span><span class="number">0x08048452</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">25</span><span class="xml">&gt;:    movl   </span><span class="variable">$0x1</span><span class="xml">,(%esp)      # 将第</span><span class="number">1</span><span class="xml">个参数压栈(该参数偏移为esp+</span><span class="number">0x00</span><span class="xml">)
   </span><span class="number">0x08048459</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">32</span><span class="xml">&gt;:    call   </span><span class="number">0x804841c</span><span class="xml"> <span class="tag">&lt;<span class="title">add</span>&gt;</span>  # 调用add函数
   </span><span class="number">0x0804845e</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">37</span><span class="xml">&gt;:    mov    %eax,</span><span class="number">0x1c</span><span class="xml">(%esp)  # 将add函数的返回值赋给result变量
   </span><span class="number">0x08048462</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">41</span><span class="xml">&gt;:    mov    </span><span class="number">0x1c</span><span class="xml">(%esp),%eax
   </span><span class="number">0x08048466</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">45</span><span class="xml">&gt;:    mov    %eax,</span><span class="number">0x4</span><span class="xml">(%esp)
   </span><span class="number">0x0804846a</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">49</span><span class="xml">&gt;:    movl   </span><span class="variable">$0x8048510</span><span class="xml">,(%esp)
   </span><span class="number">0x08048471</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">56</span><span class="xml">&gt;:    call   </span><span class="number">0x80482f0</span><span class="xml"> <span class="tag">&lt;<span class="title">printf@plt</span>&gt;</span>
   </span><span class="number">0x08048476</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">61</span><span class="xml">&gt;:    mov    </span><span class="variable">$0x0</span><span class="xml">,%eax
   </span><span class="number">0x0804847b</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">66</span><span class="xml">&gt;:    leave  
   </span><span class="number">0x0804847c</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">67</span><span class="xml">&gt;:    ret    
End of assembler dump.</span>
</pre></td></tr></table></figure>

<p>可以看到，参数是在add函数调用前压栈，换句话说，参数压栈由调用者进行，参数存储在调用者的栈空间中，下面再看一下进入add函数后都做了什么：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="xml">(gdb) disassemble add
Dump of assembler code for function add:
   </span><span class="number">0x0804841c</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">0</span><span class="xml">&gt;:     push   %ebp             # 将ebp压栈(保存函数调用者的栈基址)
   </span><span class="number">0x0804841d</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">1</span><span class="xml">&gt;:     mov    %esp,%ebp        # 将ebp指向栈顶esp(设置当前函数的栈基址)
   </span><span class="number">0x0804841f</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">3</span><span class="xml">&gt;:     sub    </span><span class="variable">$0x10</span><span class="xml">,%esp       # 分配栈空间(栈向低地址方向生长)
   </span><span class="number">0x08048422</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">6</span><span class="xml">&gt;:     movl   </span><span class="variable">$0x0</span><span class="xml">,-</span><span class="number">0x4</span><span class="xml">(%ebp)  # 给result变量赋</span><span class="number">0</span><span class="xml">值(该变量偏移为ebp-</span><span class="number">0x04</span><span class="xml">)
   </span><span class="number">0x08048429</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">13</span><span class="xml">&gt;:    mov    </span><span class="number">0xc</span><span class="xml">(%ebp),%eax   # 将第</span><span class="number">2</span><span class="xml">个参数的值赋给eax(准备运算)
   </span><span class="number">0x0804842c</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">16</span><span class="xml">&gt;:    mov    </span><span class="number">0x8</span><span class="xml">(%ebp),%edx   # 将第</span><span class="number">1</span><span class="xml">个参数的值赋给edx(准备运算)
   </span><span class="number">0x0804842f</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">19</span><span class="xml">&gt;:    add    %edx,%eax        # 加法运算(edx+eax)，结果保存在eax中
   </span><span class="number">0x08048431</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">21</span><span class="xml">&gt;:    mov    %eax,-</span><span class="number">0x4</span><span class="xml">(%ebp)  # 将运算结果eax赋给result变量
   </span><span class="number">0x08048434</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">24</span><span class="xml">&gt;:    mov    -</span><span class="number">0x4</span><span class="xml">(%ebp),%eax  # 将result变量的值赋给eax(eax将作为函数返回值)
   </span><span class="number">0x08048437</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">27</span><span class="xml">&gt;:    leave                   # 恢复函数调用者的栈基址(pop %ebp)
   </span><span class="number">0x08048438</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">28</span><span class="xml">&gt;:    ret                     # 返回(准备执行下条指令)
End of assembler dump.</span>
</pre></td></tr></table></figure>

<p>进入add函数后，首先进行的操作是将当前的栈基址ebp压栈(此栈基址是调用者main函数的)，然后将ebp指向栈顶esp，接下来再进行函数内的处理流程。函数结束前，会将函数调用者的栈基址恢复，然后返回准备执行下一指令。这个过程中，栈上的空间会是下面的样子：</p>
<p><img src="/images/articles/201310/dia_function_stack.png" alt="函数调用过程中栈的情况"></p>
<p>可以发现，每调用一次函数，都会对调用者的栈基址(ebp)进行压栈操作，并且由于栈基址是由当时栈顶指针(esp)而来，会发现，各层函数的栈基址很巧妙的构成了一个链，即当前的栈基址指向下一层函数栈基址所在的位置，如下图所示：</p>
<p><img src="/images/articles/201310/dia_dump_stack.png" alt="调用栈中各层函数栈基址间的关系"></p>
<p>了解了函数的调用过程，想要回溯调用栈也就很简单了，首先获取当前函数的栈基址(寄存器ebp)的值，然后获取该地址所指向的栈的值，该值也就是下层函数的栈基址，找到下层函数的栈基址后，重复刚才的动作，即可以将每一层函数的栈基址都找出来，这也就是我们所需要的调用栈了。</p>
<p>下面是根据原理实现的一段获取函数调用栈的代码，供参考。</p>
<figure class="highlight lang-c"><figcaption><span>Code of Dump Stack </span><a href="/downloads/code/dumpstack.c">download</a></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>

<span class="comment">/* 打印调用栈的最大深度 */</span>
<span class="preprocessor">#define DUMP_STACK_DEPTH_MAX 16</span>

<span class="comment">/* 获取寄存器ebp的值 */</span>
<span class="keyword">void</span> get_ebp(<span class="keyword">unsigned</span> <span class="keyword">long</span> *ebp) {
    __asm__ __volatile__ (
        <span class="string">"mov %%ebp, %0"</span>
        :<span class="string">"=m"</span>(*ebp)
        ::<span class="string">"memory"</span>);
}

<span class="comment">/* 获取调用栈 */</span>
<span class="keyword">int</span> dump_stack(<span class="keyword">void</span> **<span class="built_in">stack</span>, <span class="keyword">int</span> size) {
    <span class="keyword">unsigned</span> <span class="keyword">long</span> ebp = <span class="number">0</span>;
    <span class="keyword">int</span> depth = <span class="number">0</span>;

    <span class="comment">/* 1.得到首层函数的栈基址 */</span>
    get_ebp(&amp;ebp);

    <span class="comment">/* 2.逐层回溯栈基址 */</span>
    <span class="keyword">for</span> (depth = <span class="number">0</span>; (depth &lt; size) &amp;&amp; (<span class="number">0</span> != ebp) &amp;&amp; (<span class="number">0</span> != *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)ebp) &amp;&amp; (ebp != *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)ebp); ++depth) {
        <span class="built_in">stack</span>[depth] = (<span class="keyword">void</span> *)(*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(ebp + <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>)));
        ebp = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)ebp;
    }

    <span class="keyword">return</span> depth;
}

<span class="comment">/* 测试函数 2 */</span>
<span class="keyword">void</span> test_meloner() {
    <span class="keyword">void</span> *<span class="built_in">stack</span>[DUMP_STACK_DEPTH_MAX] = {<span class="number">0</span>};
    <span class="keyword">int</span> stack_depth = <span class="number">0</span>;
    <span class="keyword">int</span> i = <span class="number">0</span>;

    <span class="comment">/* 获取调用栈 */</span>
    stack_depth = dump_stack(<span class="built_in">stack</span>, DUMP_STACK_DEPTH_MAX);

    <span class="comment">/* 打印调用栈 */</span>
    printf(<span class="string">" Stack Track: \r\n"</span>);
    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; stack_depth; ++i) {
        printf(<span class="string">" [%d] %p \r\n"</span>, i, <span class="built_in">stack</span>[i]);
    }

    <span class="keyword">return</span>;
}

<span class="comment">/* 测试函数 1 */</span>
<span class="keyword">void</span> test_hutaow() {
    test_meloner();
    <span class="keyword">return</span>;
}

<span class="comment">/* 主函数 */</span>
<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) {
    test_hutaow();
    <span class="keyword">return</span> <span class="number">0</span>;
}


</pre></td></tr></table></figure>


<p>执行<code>gcc dumpstack.c -o dumpstack</code>编译并运行，执行结果如下：</p>
<pre><code> <span class="tag">Stack</span> <span class="tag">Track</span>: 
 <span class="attr_selector">[0]</span> 0<span class="tag">x8048475</span> 
 <span class="attr_selector">[1]</span> 0<span class="tag">x8048508</span> 
 <span class="attr_selector">[2]</span> 0<span class="tag">x804855c</span> 
 <span class="attr_selector">[3]</span> 0<span class="tag">x804856a</span></code></pre>
]]></content>
    <category scheme="http://hutaow.net/blog/tags/C/" term="C"/>
    <category scheme="http://hutaow.net/blog/tags/Linux/" term="Linux"/>
    <category scheme="http://hutaow.net/blog/tags/开发/" term="开发"/>
    <category scheme="http://hutaow.net/blog/tags/调用栈/" term="调用栈"/>
    <category scheme="http://hutaow.net/blog/tags/调试/" term="调试"/>
    <category scheme="http://hutaow.net/blog/tags/定位/" term="定位"/>
    <category scheme="http://hutaow.net/blog/categories/Programming/" term="Programming"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[在Linux程序中输出函数调用栈]]></title>
    <link href="http://hutaow.net/blog/2013/10/11/dump-stack-with-backtrace/"/>
    <id>http://hutaow.net/blog/2013/10/11/dump-stack-with-backtrace/</id>
    <published>2013-10-11T14:03:39.000Z</published>
    <updated>2013-10-14T14:49:53.000Z</updated>
    <content type="html"><![CDATA[<p>程序发生异常时，将函数的调用栈打印出来，可以大大提高定位效率。</p>
<p>Linux中提供了三个函数用来获取调用栈：</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="comment">/* 获取函数调用栈 */</span>
<span class="keyword">int</span> backtrace(void <span class="variable">**</span>buffer, <span class="keyword">int</span> <span class="keyword">size</span>);

<span class="comment">/* 将调用栈中的函数地址转化为函数名称 并返回一个字符串数组 */</span>
char <span class="variable">**</span>backtrace_symbols(void <span class="variable">*const</span> <span class="variable">*buffer</span>, <span class="keyword">int</span> <span class="keyword">size</span>);

<span class="comment">/* 将调用栈中的函数地址转化为函数名称 并将其定入到文件中 */</span>
void backtrace_symbols_fd(void <span class="variable">*const</span> <span class="variable">*buffer</span>, <span class="keyword">int</span> <span class="keyword">size</span>, <span class="keyword">int</span> fd);
</pre></td></tr></table></figure>

<a id="more"></a>

<p>示例代码：</p>
<figure class="highlight lang-c"><figcaption><span>Example of backtrace usage </span><a href="/downloads/code/backtrace.c">download</a></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;execinfo.h&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>

<span class="comment">/* 打印调用栈的最大深度 */</span>
<span class="preprocessor">#define DUMP_STACK_DEPTH_MAX 16</span>

<span class="comment">/* 打印调用栈函数 */</span>
<span class="keyword">void</span> dump_trace() {
    <span class="keyword">void</span> *stack_trace[DUMP_STACK_DEPTH_MAX] = {<span class="number">0</span>};
    <span class="keyword">char</span> **stack_strings = NULL;
    <span class="keyword">int</span> stack_depth = <span class="number">0</span>;
    <span class="keyword">int</span> i = <span class="number">0</span>;

    <span class="comment">/* 获取栈中各层调用函数地址 */</span>
    stack_depth = backtrace(stack_trace, DUMP_STACK_DEPTH_MAX);
    
    <span class="comment">/* 查找符号表将函数调用地址转换为函数名称 */</span>
    stack_strings = (<span class="keyword">char</span> **)backtrace_symbols(stack_trace, stack_depth);
    if (NULL == stack_strings) {
        printf(<span class="string">" Memory is not enough while dump Stack Trace! \r\n"</span>);
        <span class="keyword">return</span>;
    }

    <span class="comment">/* 打印调用栈 */</span>
    printf(<span class="string">" Stack Trace: \r\n"</span>);
    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; stack_depth; ++i) {
        printf(<span class="string">" [%d] %s \r\n"</span>, i, stack_strings[i]);
    }

    <span class="comment">/* 获取函数名称时申请的内存需要自行释放 */</span>
    free(stack_strings);
    stack_strings = NULL;

    <span class="keyword">return</span>;
}

<span class="comment">/* 测试函数 2 */</span>
<span class="keyword">void</span> test_meloner() {
    dump_trace();
    <span class="keyword">return</span>;
}

<span class="comment">/* 测试函数 1 */</span>
<span class="keyword">void</span> test_hutaow() {
    test_meloner();
    <span class="keyword">return</span>;
}

<span class="comment">/* 主函数 */</span>
<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) {
    test_hutaow();
    <span class="keyword">return</span> <span class="number">0</span>;
}


</pre></td></tr></table></figure>


<p>编译时需要加上<code>-rdynamic</code>参数，以得到符号名称，像下面这样：</p>
<pre><code><span class="comment">gcc</span> <span class="literal">-</span><span class="comment">rdynamic</span> <span class="comment">backtrace</span>.<span class="comment">c</span> <span class="literal">-</span><span class="comment">o</span> <span class="comment">backtrace</code></pre>
<p>执行<code>./backtrace</code>运行程序，输出如下：</p>
<p><img src="/images/articles/201310/dump_stack_with_backtrace.png" alt="Dump stack with backtrace"></p>
]]></content>
    <category scheme="http://hutaow.net/blog/tags/C/" term="C"/>
    <category scheme="http://hutaow.net/blog/tags/Linux/" term="Linux"/>
    <category scheme="http://hutaow.net/blog/tags/开发/" term="开发"/>
    <category scheme="http://hutaow.net/blog/tags/调用栈/" term="调用栈"/>
    <category scheme="http://hutaow.net/blog/tags/调试/" term="调试"/>
    <category scheme="http://hutaow.net/blog/tags/定位/" term="定位"/>
    <category scheme="http://hutaow.net/blog/categories/Programming/" term="Programming"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[博客搬家完成，新域名正式上线]]></title>
    <link href="http://hutaow.net/blog/2013/10/10/starting-with-new-domain-name/"/>
    <id>http://hutaow.net/blog/2013/10/10/starting-with-new-domain-name/</id>
    <published>2013-10-10T14:23:31.000Z</published>
    <updated>2013-10-14T14:35:22.000Z</updated>
    <content type="html"><![CDATA[<p>昨天注册了<a href="http://hutaow.net">hutaow.net</a>这个域名，决心把博客搬过来，恢复写博客的生活。</p>
<p>算下来差不多有两年时间都没有更新过了，其中一个最主要借口是找不到合适的落脚点，时间最长地方要数ChinaUNIX了，早期的时候用着还是蛮不错的，但是随着时间的推移，ChinaUNIX的系统更新实在是跟不上节奏，想到过搬家但是由于ChinaUNIX的订阅数据实在太蹩脚，连搬都不好搬，更不用说评论等等了，博客搬家的计划也就一直搁置了。后来有试过CSDN但是上面的广告太多了，百度也试过但又不对我等码农的口味，WordPress又悲催的总被墙等等。</p>
<p>另一个借口就是工作太忙没时间，一回家就不太想写东西了，但是最近开始意识到挥挥衣袖什么都没有留下的感觉很不好，没有积累，没有思考，需要改变一下了。</p>
<p>博客一方面作为记录，把了解的知识积累下来，方便自己以后回忆；另一方面作为分享，将解决问题过程中吸取的经验写下来，供大家参考，这样遇到同样问题时可以更迅速的解决。</p>
<p>不多说，坚持就好。</p>
]]></content>
    <category scheme="http://hutaow.net/blog/categories/Life/" term="Life"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[TP-WR703n安装OpenWRT记录]]></title>
    <link href="http://hutaow.net/blog/2013/09/06/install-openwrt/"/>
    <id>http://hutaow.net/blog/2013/09/06/install-openwrt/</id>
    <published>2013-09-06T15:16:00.000Z</published>
    <updated>2013-10-14T14:35:22.000Z</updated>
    <content type="html"><![CDATA[<h3>1 安装OpenWRT</h3>
<h4>1.1 下载并刷新固件</h4>
<p>如果以前没刷过OpenWRT，需要升级factory固件，<a href="http://downloads.openwrt.org/snapshots/trunk/ar71xx/openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-factory.bin" title="openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-factory.bin" target="_blank">点击这里下载</a>。</p>
<p>如果之前已经安装过了OpenWRT，则直接更新sysupgrade固件即可，<a href="http://downloads.openwrt.org/snapshots/trunk/ar71xx/openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-sysupgrade.bin" title="openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-sysupgrade.bin" target="_blank">点击这里下载</a>。</p>
<p>注意升级的时候要将原配置删除，避免配置文件互相影响，固件刷新完成后，路由器会自动重启。</p>
<a id="more"></a>

<h4>1.2 登陆路由器</h4>
<p>OpenWRT主线固件的无线信号是默认关闭的，这个时候需要找跟网线将电脑和路由器连接上，然后将电脑的IP地址设置为静态的“192.168.1.100”，然后用Telnet访问“192.168.1.1”，正确的情况下，会看到如下界面：<br><img src="/images/articles/201309/install_openwrt_01_first_login.png" alt="First Login"></p>
<h4>1.3 打开无线信号</h4>
<p>编辑“/etc/config/wireless”文件，将“option disabled 1”这一行注掉，或者直接删除。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>config wifi-device radio0
    <span class="keyword">option</span> type     mac80211
    <span class="keyword">option</span> channel  <span class="number">11</span>
    <span class="keyword">option</span> hwmode   <span class="number">11</span>ng
    <span class="keyword">option</span> path     <span class="comment">'platform/ar933x_wmac'</span>
    <span class="keyword">option</span> htmode   HT20
    list ht_capab   SHORT-GI-<span class="number">20</span>
    list ht_capab   SHORT-GI-<span class="number">40</span>
    list ht_capab   RX-STBC1
    list ht_capab   DSSS_CCK-<span class="number">40</span>
    # REMOVE THIS LINE <span class="keyword">TO</span> ENABLE WIFI:
    # <span class="keyword">option</span> disabled <span class="number">1</span>

config wifi-iface
    <span class="keyword">option</span> device   radio0
    <span class="keyword">option</span> network  lan
    <span class="keyword">option</span> mode     ap
    <span class="keyword">option</span> ssid     OpenWrt
    <span class="keyword">option</span> encryption none
</pre></td></tr></table></figure>

<h4>1.4 外网接入配置</h4>
<p>编辑“/etc/config/network”文件，将原“lan”区段中的“ifname”注掉，新增“wan”段，如果是用宽带拨号上网，则配置成下面的样子（其中USERNAME和PASSWORD分别是拨号的用户名和密码）：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre>config <span class="class"><span class="keyword">interface</span> '<span class="title">loopback</span>'
	<span class="title">option</span> <span class="title">ifname</span> '<span class="title">lo</span>'
	<span class="title">option</span> <span class="title">proto</span> '<span class="title">static</span>'
	<span class="title">option</span> <span class="title">ipaddr</span> '127.0.0.1'
	<span class="title">option</span> <span class="title">netmask</span> '255.0.0.0'

<span class="title">config</span> <span class="title">globals</span> '<span class="title">globals</span>'
	<span class="title">option</span> <span class="title">ula_prefix</span> '<span class="title">fd4f</span>:26<span class="title">fb</span>:9<span class="title">d78</span>::/48'

<span class="title">config</span> <span class="title">interface</span> '<span class="title">lan</span>'
	# <span class="title">option</span> <span class="title">ifname</span> '<span class="title">eth0</span>'
	<span class="title">option</span> <span class="title">type</span> '<span class="title">bridge</span>'
	<span class="title">option</span> <span class="title">proto</span> '<span class="title">static</span>'
	<span class="title">option</span> <span class="title">ipaddr</span> '192.168.1.1'
	<span class="title">option</span> <span class="title">netmask</span> '255.255.255.0'
	<span class="title">option</span> <span class="title">ip6assign</span> '60'

<span class="title">config</span> <span class="title">interface</span> '<span class="title">wan</span>'
	<span class="title">option</span> <span class="title">ifname</span> '<span class="title">eth0</span>'
	<span class="title">option</span> <span class="title">proto</span> '<span class="title">pppoe</span>'
	<span class="title">option</span> <span class="title">username</span> '<span class="title">USERNAME</span>'
	<span class="title">option</span> <span class="title">password</span> '<span class="title">PASSWORD</span>'
</pre></td></tr></table></figure>

<p>如果不需要拨号，直接通过其它路由器连接，则将“wan”区段配置成下面的样子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>config <span class="class"><span class="keyword">interface</span> '<span class="title">wan</span>'
	<span class="title">option</span> <span class="title">ifname</span> '<span class="title">eth0</span>'
	<span class="title">option</span> <span class="title">proto</span> '<span class="title">dhcp</span>'
</pre></td></tr></table></figure>

<h4>1.5 重启路由器，完成OpenWRT的安装</h4>
<p>执行reboot命令重启路由器，将外网线连上，重启后搜索无线信号，就可以看到“OpenWRT”的信号了，连接上去，不出意外的话，这个时候电脑已经可以上网了。</p>
<h3>2 将OpenWRT扩展至U盘</h3>
<h4>2.1 安装基本软件</h4>
<p>再次用Telnet访问“192.168.1.1”，执行下面的命令，将挂载U盘相关的基本软件安装上。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="title">opkg</span> update
<span class="title">opkg</span> install block-mount kmod-fs-ext4 kmod-usb-ohci kmod-usb-storage e2fsprogs
</pre></td></tr></table></figure>

<h4>2.2 准备挂载U盘</h4>
<p>将U盘插上，执行“block info”命令，看下U盘是否已被识别，如下图，其中中sda1、sda2、sda5为U盘分区：<br><img src="/images/articles/201309/install_openwrt_02_block_info.png" alt="Block Info"></p>
<h4>2.3 拷贝系统文件</h4>
<p>执行如下命令，将路由器ROM中的系统文件全部拷贝到U盘中：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="title">mount</span> /dev/sda1 /mnt 
<span class="title">mkdir</span> /tmp/vroot 
<span class="title">mount</span> <span class="comment">--bind / /tmp/vroot </span>
<span class="title">cp</span> -a /tmp/vroot/* /mnt 
<span class="title">sync</span> 
<span class="title">umount</span> /tmp/vroot
</pre></td></tr></table></figure>

<h4>2.4 设置交换空间（可选）</h4>
<p>U盘在分区时可以预留一个交换分区，防止路由器内存不足，这里预留的交换分区是sda5，执行下面的命令：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">swapon</span> /dev/sda5
</pre></td></tr></table></figure>

<h4>2.5 保存挂载信息</h4>
<p>将当前挂载状态写入fstab文件中：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>block detect &gt; <span class="regexp">/etc/config</span><span class="regexp">/fstab
</pre></td></tr></table></figure>

<p>然后修改“/etc/config/fstab”文件，将sda1的挂载点设置为“/”，并将“option enabled”置1，配置类似下面的样子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>config global
	<span class="keyword">option</span> anon_swap <span class="comment">'0'</span>
	<span class="keyword">option</span> anon_mount <span class="comment">'0'</span>
	<span class="keyword">option</span> auto_swap <span class="comment">'1'</span>
	<span class="keyword">option</span> auto_mount <span class="comment">'1'</span>
	<span class="keyword">option</span> delay_root <span class="comment">'5'</span>
	<span class="keyword">option</span> check_fs <span class="comment">'0'</span>

config mount
	<span class="keyword">option</span> target <span class="comment">'/'</span>
	<span class="keyword">option</span> uuid <span class="comment">'413b964c-9c9c-4af4-8966-daf04ee53414'</span>
	<span class="keyword">option</span> enabled <span class="comment">'1'</span>
	<span class="keyword">option</span> fstype <span class="comment">'ext4'</span>

config mount
	<span class="keyword">option</span> target <span class="comment">'/home'</span>
	<span class="keyword">option</span> uuid <span class="comment">'e7052ed0-b883-4375-9f31-5648ea8f2948'</span>
	<span class="keyword">option</span> enabled <span class="comment">'1'</span>
	<span class="keyword">option</span> fstype <span class="comment">'ext4'</span>

config swap
	<span class="keyword">option</span> uuid <span class="comment">'58713d02-e9de-4c23-a56b-a5ea3d3dfcf0'</span>
	<span class="keyword">option</span> enabled <span class="comment">'1'</span>
</pre></td></tr></table></figure>

<p>如果U盘只有一个分区，会只看到一个sda1(“/”)，其它诸如sda2(“/home”)、sda5(“swap”)需要额外分区才能看到。</p>
<h4>2.6 重启路由器，完成OpenWRT的扩展</h4>
<p>重启路由器，再次“df -h”一下，可以看到路由器的空间已经扩展成功了。<br><img src="/images/articles/201309/install_openwrt_03_df.png" alt="DF Info"></p>
]]></content>
    <category scheme="http://hutaow.net/blog/tags/OpenWRT/" term="OpenWRT"/>
    <category scheme="http://hutaow.net/blog/tags/路由器/" term="路由器"/>
    <category scheme="http://hutaow.net/blog/categories/Network/" term="Network"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Linux中分区出现“Read-only file system”的解决办法]]></title>
    <link href="http://hutaow.net/blog/2013/06/16/slove-the-read-only-file-system-problem-in-linux/"/>
    <id>http://hutaow.net/blog/2013/06/16/slove-the-read-only-file-system-problem-in-linux/</id>
    <published>2013-06-16T14:54:00.000Z</published>
    <updated>2013-10-14T14:35:22.000Z</updated>
    <content type="html"><![CDATA[<p>最近发现手机上TF卡权限显示是可写入的，但无法向TF卡写入文件，并提示“Read-only file system”，用下面的命令重新挂载一下就可以了：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">mount</span> -o remount,rw /media/TF
</pre></td></tr></table></figure>

<p>注：其中”/media/TF“是挂载的目录。</p>
]]></content>
    <category scheme="http://hutaow.net/blog/tags/Linux/" term="Linux"/>
    <category scheme="http://hutaow.net/blog/categories/Linux/" term="Linux"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Linux中批量设置目录或文件权限的方法]]></title>
    <link href="http://hutaow.net/blog/2013/06/16/batch-settings-directory-or-file-permissions/"/>
    <id>http://hutaow.net/blog/2013/06/16/batch-settings-directory-or-file-permissions/</id>
    <published>2013-06-15T17:48:00.000Z</published>
    <updated>2013-10-14T14:35:22.000Z</updated>
    <content type="html"><![CDATA[<p>递归方式将当前目录下所有的子目录设置为755权限（不包括文件）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">find</span> ./ -<span class="typedef"><span class="keyword">type</span> d -exec chmod 755 <span class="container">{}</span> \;</span>
</pre></td></tr></table></figure>

<p>递归方式将当前目录下的所有文件设置为644权限（包括子目录下的文件，但不对目录本身设置权限）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">find</span> ./ -<span class="typedef"><span class="keyword">type</span> f -exec chmod 644 <span class="container">{}</span> \;</span>
</pre></td></tr></table></figure>

]]></content>
    <category scheme="http://hutaow.net/blog/tags/Linux/" term="Linux"/>
    <category scheme="http://hutaow.net/blog/categories/Linux/" term="Linux"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[配置 Cisco Catalyst 3560 交换机端口镜像]]></title>
    <link href="http://hutaow.net/blog/2010/05/14/config-cisco-catalyst-3560-switch-port-mirroring/"/>
    <id>http://hutaow.net/blog/2010/05/14/config-cisco-catalyst-3560-switch-port-mirroring/</id>
    <published>2010-05-14T14:13:00.000Z</published>
    <updated>2013-10-14T14:35:22.000Z</updated>
    <content type="html"><![CDATA[<p>假设要将19和27号端口的数据镜像到2号端口，按如下操作进行：</p>
<p>1) 通过串口登陆到交换机，其中参数设置为：速率9600bps，8位数据位，1位停止位，无奇偶校验，无流量控制。</p>
<p>2) 交换机上电自检然后登入后出现命令提示符：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="attribute">Switch&gt;
</pre></td></tr></table></figure>

<a id="more"></a>

<p>3) 依次进入特权模式和全局模式，输入如下命令：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">Switch</span>&gt;enable
Password:
<span class="keyword">Switch</span><span class="comment">#configure terminal</span>
Enter configuration commands, one per line.  End with CNTL/Z.
<span class="keyword">Switch</span>(config)<span class="comment">#</span>
</pre></td></tr></table></figure>

<p>4) 在新session中，将端口19和27设置为被监听端口(source)，2号端口设置为监听端口(destination)，命令如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>Switch(config)#monitor session <span class="number">1</span> source <span class="class"><span class="keyword">interface</span> <span class="title">Fa0</span>/19
<span class="title">Switch</span>(<span class="title">config</span>)#<span class="title">monitor</span> <span class="title">session</span> 1 <span class="title">source</span> <span class="title">interface</span> <span class="title">Fa0</span>/27
<span class="title">Switch</span>(<span class="title">config</span>)#<span class="title">monitor</span> <span class="title">session</span> 1 <span class="title">destination</span> <span class="title">interface</span> <span class="title">Fa0</span>/2
<span class="title">Switch</span>(<span class="title">config</span>)#<span class="title">end</span>
<span class="title">Switch</span>#
03:30:52: %<span class="title">SYS</span>-5-<span class="title">CONFIG_I</span>: <span class="title">Configured</span> <span class="title">from</span> <span class="title">console</span> <span class="title">by</span> <span class="title">console</span>
</pre></td></tr></table></figure>

<p>5) 断开连接，完成。</p>
]]></content>
    <category scheme="http://hutaow.net/blog/tags/交换机/" term="交换机"/>
    <category scheme="http://hutaow.net/blog/categories/Network/" term="Network"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[C#获取XML文件指定节点的数据]]></title>
    <link href="http://hutaow.net/blog/2010/04/27/get-xml-node-value-with-c-sharp-language/"/>
    <id>http://hutaow.net/blog/2010/04/27/get-xml-node-value-with-c-sharp-language/</id>
    <published>2010-04-27T04:43:00.000Z</published>
    <updated>2013-10-14T14:35:22.000Z</updated>
    <content type="html"><![CDATA[<p>实例说明会更清楚些，假设有如下XML文件：</p>
<figure class="highlight lang-xml"><figcaption><span>message_hutaow.xml</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="tag">&lt;<span class="title">Message version="1.0"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">Head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">Date</span>&gt;</span>20080502<span class="tag">&lt;/<span class="title">Date</span>&gt;</span>
    <span class="tag">&lt;<span class="title">Source</span>&gt;</span>
      <span class="tag">&lt;<span class="title">Address</span>&gt;</span>192.168.0.1<span class="tag">&lt;/<span class="title">Address</span>&gt;</span>
      <span class="tag">&lt;<span class="title">Name</span>&gt;</span>hutaow<span class="tag">&lt;/<span class="title">Name</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">Source</span>&gt;</span>
    <span class="tag">&lt;<span class="title">Target</span>&gt;</span>
      <span class="tag">&lt;<span class="title">Address</span>&gt;</span>192.168.0.19<span class="tag">&lt;/<span class="title">Address</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">Target</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">Head</span>&gt;</span>
<span class="tag">&lt;/<span class="title">Message</span>&gt;</span>
</pre></td></tr></table></figure>

<p>现在要读取消息源IP地址(192.168.0.1)和目的IP地址(192.168.0.19)。</p>
<a id="more"></a>

<p>根据上面XML文件的结构，查找路径为“/Message/Head/Source/Address”和“/Message/Head/Target/Address”，需要用到XPath的寻径方式，代码如下：</p>
<figure class="highlight lang-c#"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre>// 需要引用System<span class="preprocessor">.Xml</span>库
using System<span class="preprocessor">.Xml</span><span class="comment">;</span>

// 省略中间无关代码

// 加载XML文件
XmlDocument xmlDoc = new XmlDocument()<span class="comment">;</span>
xmlDoc<span class="preprocessor">.Load</span>(<span class="string">"message_hutaow.xml"</span>)<span class="comment">;</span>

// 使用XPath方式寻找源IP地址节点并输出
xmlNode = xmlDoc<span class="preprocessor">.SelectSingleNode</span>(<span class="string">"/Message/Head/Source/Address"</span>)<span class="comment">;</span>
Console<span class="preprocessor">.WriteLine</span>(<span class="string">"Source Address: {0}"</span>,xmlNode<span class="preprocessor">.InnerText</span>)<span class="comment">;</span>

// 使用XPath方式寻找目的IP地址节点并输出
xmlNode = xmlDoc<span class="preprocessor">.SelectSingleNode</span>(<span class="string">"/Message/Head/Target/Address"</span>)<span class="comment">;</span>
Console<span class="preprocessor">.WriteLine</span>(<span class="string">"Target Address: {0}"</span>,xmlNode<span class="preprocessor">.InnerText</span>)<span class="comment">;</span>
</pre></td></tr></table></figure>

<p>控制台输出<br>    Source Address: 192.168.0.1<br>    Target Address: 192.168.0.19</p>
]]></content>
    <category scheme="http://hutaow.net/blog/tags/CSharp/" term="CSharp"/>
    <category scheme="http://hutaow.net/blog/tags/XML/" term="XML"/>
    <category scheme="http://hutaow.net/blog/tags/开发/" term="开发"/>
    <category scheme="http://hutaow.net/blog/categories/Programming/" term="Programming"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Snort安装IDMEF插件]]></title>
    <link href="http://hutaow.net/blog/2010/04/21/install-idmef-plugin-for-snort/"/>
    <id>http://hutaow.net/blog/2010/04/21/install-idmef-plugin-for-snort/</id>
    <published>2010-04-21T02:48:00.000Z</published>
    <updated>2013-10-14T14:35:22.000Z</updated>
    <content type="html"><![CDATA[<p>Snort作为一款开源的入侵检测系统，可以与其它各种网络设备连接协同工作，其中IDMEF插件可以实现设备之间报警信息的共享，在安装该插件时，需要注意以下几个问题：</p>
<ol>
<li><p>IDMEF插件依赖于<a href="http://sourceforge.net/projects/libidmef" target="_blank">libidmef</a>、<a href="http://xmlsoft.org" target="_blank">libxml2</a>及<a href="http://www.ntp.org" target="_blank">libntp</a>库，所以在安装Snort之前，需要首先安装这三个库。</p>
</li>
<li><p>配置Snort时，需要加上“—enable-idmef”参数，如下所示：</p>
</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="string">.</span><span class="comment">/configure</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">enable</span>-<span class="comment">idmef</span>
<span class="comment">make</span>
<span class="comment">make</span> <span class="comment">install
</pre></td></tr></table></figure>

]]></content>
    <category scheme="http://hutaow.net/blog/tags/IDS/" term="IDS"/>
    <category scheme="http://hutaow.net/blog/tags/Snort/" term="Snort"/>
    <category scheme="http://hutaow.net/blog/tags/入侵检测/" term="入侵检测"/>
    <category scheme="http://hutaow.net/blog/categories/Security/" term="Security"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[入侵检测与响应系统的信息共享]]></title>
    <link href="http://hutaow.net/blog/2010/04/17/intrusion-dedection-and-response-system-for-information-sharing/"/>
    <id>http://hutaow.net/blog/2010/04/17/intrusion-dedection-and-response-system-for-information-sharing/</id>
    <published>2010-04-17T13:25:00.000Z</published>
    <updated>2013-10-14T14:35:22.000Z</updated>
    <content type="html"><![CDATA[<h3>引言</h3>
<p>入侵检测系统(IDS)与其它系统(如防火墙)交互过程中，需要遵循一定的规范和协议，然而生产IDS的各个厂家的报警日志及数据格式均有所区别，所以在不同设备之间交互会遇到很多麻烦。早先知道的是CheckPoint提出的OPSec协议和天融信提出的TOPSec协议，凡是遵循这两个协议的网络安全设备均可与相应的IDS进行交互，协同防护网络安全。在2007年，IETF针对这种交互情况形成了四份相关文档，分为三个部分，分别是隧道轮廓(RFC3620 - The TUNNEL Profile)、入侵检测消息交换格式和要求(RFC4765 - IDMEF, RFC4766 - IDMER)、入侵检测交换协议(RFC4767 - IDXP)。</p>
<p>值得注意的是，IETF规定IDS对其它设备交互的方式采用XML格式存储和传输，和SOAP似乎有些相似，XML跨平台跨语言结构清晰等优点使它的应用范围越来越广，几乎达到了无处不用XML的程度。</p>
<a id="more"></a>

<h3>1 入侵检测消息交互过程</h3>
<h4>1.1 建立连接</h4>
<p>使用IDXP传输数据的入侵检测实体被称为IDXP对等体。对等体只能成对出现，这些对等体通过BEEP会话中的一个或多个BEEP信道进行数据传输。对等体可能是管理器或分析器。</p>
<p>在分析器和管理器之间很可能是多对多的关系。即一个分析器可以和多个管理器通信，同样，一个管理器也可以和多个分析器通信；在不同的管理器之间也可以是多对多的关系。所以，一个管理器可以通过多个中间管理器接收大量的来自分析器的报警信息。但是，各个分析器之间禁止建立IDXP连接，避免重复报警情况的发生。</p>
<p><strong>对等体“Alice”和“Bob”建立IDXP交换的过程</strong></p>
<p>IDXP对等体之间通过打开一个BEEP信道进行通信。在打开BEEP信道之前，需要首先建立BEEP会话，然后就安全特性等问题进行协商。BEEP安全轮廓协商成功后，再经互相确认应答，然后开始IDXP交换。</p>
<pre><code><span class="comment">Alice</span>                                               <span class="comment">Bob</span>
  <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">建立连接(1)</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
&lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">问候</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
&lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">启动安全轮廓(2)</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
&lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">问候</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
&lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">启动</span> <span class="comment">IDXP(3)</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;</code></pre>
<p>交互过程:</p>
<ul>
<li>“Alice”建立一个到‘Bob’的连接, 并触发交换二者BEEP问候消息</li>
<li>两个实体协商BEEP安全轮廓</li>
<li>两个实体协商IDXP轮廓</li>
</ul>
<p><strong>对等体“Alice”和“Bob”通过代理服务器建立IDXP交换</strong></p>
<p>在一对IDXP对等体之间可以存在多个代理，这些代理可能是因为管理的需要。比如透过防火墙进行受限访问，或是将公司各部门分析器的数据转发到公司总管理器。</p>
<p>在使用代理转发数据时，会使用BEEP协调轮廓建立一个应用层的隧道。隧道轮廓(详细见“RFC3620 - The TUNNEL profile”)即在此时发挥作用。在创建应用层隧道时，必须建立一个作为协调轮廓的隧道，并且该隧道轮廓需要进行SASL认证。隧道建立完成后，BEEP安全轮廓才可以提供IDXP协商时需要的各项安全特性。</p>
<pre><code><span class="comment">Alice</span>              <span class="comment">proxy1</span>               <span class="comment">proxy2</span>               <span class="comment">Bob</span>
  <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">建立连接</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
&lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">问候</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
  <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">启动隧道</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
                      <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">建立连接(1)</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
                    &lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">问候</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
                      <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">启动隧道</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
                                           <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">建立连接</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
                                         &lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">问候</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
                                           <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">启动隧道</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
                                         &lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> &lt;<span class="comment">确认</span>&gt;<span class="comment">(2)</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>
                    &lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> &lt;<span class="comment">确认</span>&gt; <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>
&lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> &lt;<span class="comment">确认</span>&gt; <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>
&lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">问候</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
&lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">启动安全轮廓</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
&lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">问候</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
&lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">启动</span> <span class="comment">IDXP</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;</code></pre>
<p>交互过程:</p>
<ul>
<li>收到“Alice”启动隧道的消息后，“proxy1”并没有立即返回确认消息，而是先试图和“proxy”连接以建立隧道。同样的，“proxy2”也不会立即给“proxy1”返回确认消息</li>
<li>“Bob”的确认信息首先到达“proxy2”并且与之启动隧道，然后确认消息会传递下去最终返回给“Alice”，最终“Alice”和“Bob”之间就成功建立了应用层的隧道</li>
</ul>
<h4>1.2 数据传输</h4>
<p>在一对入侵检测实体通过BEEP会话进行通信时，会使用IDXP轮廓打开一个或多个BEEP信道。如果需要，可以用IDXP轮廓建立更多的BEEP会话，以提供额外的信道。但是在多数情况下，还是应该在已有的BEEP会话中添加新的信道，尽量避免用新建BEEP会话的方式添加信道。</p>
<p>在每条信道中，对等体都是以客户端/服务器形式进行通信。客户端和服务器的角色扮演决定于建立BEEP会话的发起者和监听者。即发起者为客户端，监听者为服务器。</p>
<pre><code><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>                          <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
<span class="comment">|</span>          <span class="comment">|</span>                          <span class="comment">|</span>          <span class="comment">|</span>
<span class="comment">|</span>          <span class="comment">|********</span> <span class="comment">BEEP</span> <span class="comment">会话</span> <span class="comment">********|</span>          <span class="comment">|</span>
<span class="comment">|</span>          <span class="comment">|</span>                          <span class="comment">|</span>          <span class="comment">|</span>
<span class="comment">|</span>  <span class="comment">分析器</span>   <span class="comment">|</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">IDXP</span> <span class="comment">轮廓</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">|</span>  <span class="comment">管理器</span>   <span class="comment">|</span>
<span class="comment">|</span> <span class="comment">(客户端)</span>  <span class="comment">|</span>                          <span class="comment">|</span> <span class="comment">(服务端)</span>  <span class="comment">|</span>
<span class="comment">|</span>          <span class="comment">|</span>                          <span class="comment">|</span>          <span class="comment">|</span>
<span class="comment">|</span>          <span class="comment">|**************************|</span>          <span class="comment">|</span>
<span class="comment">|</span>          <span class="comment">|</span>                          <span class="comment">|</span>          <span class="comment">|</span>
<span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>                          <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></code></pre>
<p>在一个BEEP会话中使用多个BEEP信道的方式对IDXP对等体之间传输数据的分类和优先级的管理非常有利。例如，管理器“M1”向“M2”发送报警数据时，可以将不同类型的信息使用单独的信道进行传输。“M1”在这些信道中扮演了客户端的角色，“M2”则对接收到的报警信息根据其不同类型进行相应处理。</p>
<pre><code><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>                                            <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
<span class="comment">|</span>          <span class="comment">|</span>                                            <span class="comment">|</span>          <span class="comment">|</span>
<span class="comment">|</span>          <span class="comment">|****************</span> <span class="comment">BEEP</span> <span class="comment">会话</span> <span class="comment">******************|</span>          <span class="comment">|</span>
<span class="comment">|</span>          <span class="comment">|</span>                                            <span class="comment">|</span>          <span class="comment">|</span>
<span class="comment">|</span>          <span class="comment">|</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">IDXP</span> <span class="comment">轮廓</span>, <span class="comment">基于网络的报警信息</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">|</span>          <span class="comment">|</span>
<span class="comment">|</span>  <span class="comment">管理器</span>   <span class="comment">|</span>                                            <span class="comment">|</span>  <span class="comment">管理器</span>   <span class="comment">|</span>
<span class="comment">|</span>    <span class="comment">M1</span>    <span class="comment">|</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">IDXP</span> <span class="comment">轮廓</span>, <span class="comment">基于主机的报警信息</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">|</span>    <span class="comment">M2</span>    <span class="comment">|</span>
<span class="comment">|</span> <span class="comment">(客户端)</span>  <span class="comment">|</span>                                            <span class="comment">|</span> <span class="comment">(服务端)</span>  <span class="comment">|</span>
<span class="comment">|</span>          <span class="comment">|</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">IDXP</span> <span class="comment">轮廓</span>, <span class="comment">其它报警信息</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">|</span>          <span class="comment">|</span>
<span class="comment">|</span>          <span class="comment">|</span>                                            <span class="comment">|</span>          <span class="comment">|</span>
<span class="comment">|</span>          <span class="comment">|********************************************|</span>          <span class="comment">|</span>
<span class="comment">|</span>          <span class="comment">|</span>                                            <span class="comment">|</span>          <span class="comment">|</span>
<span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>                                            <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></code></pre>
<h4>1.3 断开连接</h4>
<p>在一些情况下(如处理过程中出现错误)，IDXP对等体可以关闭某个IDXP信道。要关闭某条信道，需要在零号信道上发送一条“关闭”的指令，并且指明所关闭的信道。如果想要关闭整个BEEP会话，只需在零号信道上发送一条要求“关闭”零信道的指令即可。</p>
<p>由于应用层隧道和BEEP安全轮廓会经常使用，所以凡是包含IDXP信道的BEEP会话将会一直存活下去。同时，为了避免IDXP信道被反复的建立，系统会一直保持这些IDXP信道的连接，即使当前已经没有数据在上面传输。建议当IDXP对等体在合适的时候，手动关闭并重建BEEP会话。</p>
<h4>1.4 可信模型</h4>
<p>在以上的模型中，BEEP安全轮廓是建立在IDXP对等体之间从而实现的端到端安全，而无需对中间代理建立信任。因此，只有在安全轮廓下经过协商后的IDXP对等体之间是相互信任的，而代理始终被看作是不可信的。</p>
<h3>2 入侵检测消息交换格式</h3>
<h4>2.1 IDMEF数据模型</h4>
<p>IDMEF数据模型的各主要部分关系如下图所示（这里省略了事件指示器和属性）。<br><img src="/images/articles/201004/intrusion_dedection_and_response_system_for_information_sharing.png" alt="数据模型"></p>
<p>IDMEF消息的最高层类是“IDMEF-Message”，其它各类型消息都是该类的子类。目前IDMEF定义了两种消息：“Alerts”和“Heartbeats”。其中这两个消息各自携带不同的子类，各子类又描述了更加详细的信息。</p>
<p>需要注意的是，数据模型并没有指明警报信息如何分类和识别。例如，端口扫描这一行为，它可能被分析器识别为一次单点对多目标的攻击，同时被另一分析器识别为多次的单点攻击。所有，只有在分析器确定了报警类型之后，数据模型才能确定如何对报警数据进行格式化。</p>
<h4>2.2 示例</h4>
<p>IDMEF数据模型最终是以XML形式实现，XML跨平台、跨语言以及强扩展性的特点保证了IDS设备之间共享信息时良好的兼容性。</p>
<p>下面用实例说明IDMEF对报警信息封装的格式。这些例子只是为说明用，不具备代表性。</p>
<figure class="highlight lang-xml"><figcaption><span>基于网络检测到的某次泪滴攻击报警信息</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="code"><pre><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
   <span class="tag">&lt;<span class="title">idmef:IDMEF-Message</span> <span class="attribute">xmlns:idmef</span>=<span class="value">"http://iana.org/idmef"</span> <span class="attribute">version</span>=<span class="value">"1.0"</span>&gt;</span>
     <span class="tag">&lt;<span class="title">idmef:Alert</span> <span class="attribute">messageid</span>=<span class="value">"abc123456789"</span>&gt;</span>
       <span class="tag">&lt;<span class="title">idmef:Analyzer</span> <span class="attribute">analyzerid</span>=<span class="value">"hq-dmz-analyzer01"</span>&gt;</span>
         <span class="tag">&lt;<span class="title">idmef:Node</span> <span class="attribute">category</span>=<span class="value">"dns"</span>&gt;</span>
           <span class="tag">&lt;<span class="title">idmef:location</span>&gt;</span>Headquarters DMZ Network<span class="tag">&lt;/<span class="title">idmef:location</span>&gt;</span>
           <span class="tag">&lt;<span class="title">idmef:name</span>&gt;</span>analyzer01.example.com<span class="tag">&lt;/<span class="title">idmef:name</span>&gt;</span>
         <span class="tag">&lt;/<span class="title">idmef:Node</span>&gt;</span>
       <span class="tag">&lt;/<span class="title">idmef:Analyzer</span>&gt;</span>
       <span class="tag">&lt;<span class="title">idmef:CreateTime</span> <span class="attribute">ntpstamp</span>=<span class="value">"0xbc723b45.0xef449129"</span>&gt;</span>
         2000-03-09T10:01:25.93464-05:00
       <span class="tag">&lt;/<span class="title">idmef:CreateTime</span>&gt;</span>
       <span class="tag">&lt;<span class="title">idmef:Source</span> <span class="attribute">ident</span>=<span class="value">"a1b2c3d4"</span>&gt;</span>
         <span class="tag">&lt;<span class="title">idmef:Node</span> <span class="attribute">ident</span>=<span class="value">"a1b2c3d4-001"</span> <span class="attribute">category</span>=<span class="value">"dns"</span>&gt;</span>
           <span class="tag">&lt;<span class="title">idmef:name</span>&gt;</span>badguy.example.net<span class="tag">&lt;/<span class="title">idmef:name</span>&gt;</span>
           <span class="tag">&lt;<span class="title">idmef:Address</span> <span class="attribute">ident</span>=<span class="value">"a1b2c3d4-002"</span> <span class="attribute">category</span>=<span class="value">"ipv4-net-mask"</span>&gt;</span>
             <span class="tag">&lt;<span class="title">idmef:address</span>&gt;</span>192.0.2.50<span class="tag">&lt;/<span class="title">idmef:address</span>&gt;</span>
             <span class="tag">&lt;<span class="title">idmef:netmask</span>&gt;</span>255.255.255.255<span class="tag">&lt;/<span class="title">idmef:netmask</span>&gt;</span>
           <span class="tag">&lt;/<span class="title">idmef:Address</span>&gt;</span>
         <span class="tag">&lt;/<span class="title">idmef:Node</span>&gt;</span>
       <span class="tag">&lt;/<span class="title">idmef:Source</span>&gt;</span>
       <span class="tag">&lt;<span class="title">idmef:Target</span> <span class="attribute">ident</span>=<span class="value">"d1c2b3a4"</span>&gt;</span>
         <span class="tag">&lt;<span class="title">idmef:Node</span> <span class="attribute">ident</span>=<span class="value">"d1c2b3a4-001"</span> <span class="attribute">category</span>=<span class="value">"dns"</span>&gt;</span>
           <span class="tag">&lt;<span class="title">idmef:Address</span> <span class="attribute">category</span>=<span class="value">"ipv4-addr-hex"</span>&gt;</span>
             <span class="tag">&lt;<span class="title">idmef:address</span>&gt;</span>0xde796f70<span class="tag">&lt;/<span class="title">idmef:address</span>&gt;</span>
           <span class="tag">&lt;/<span class="title">idmef:Address</span>&gt;</span>
         <span class="tag">&lt;/<span class="title">idmef:Node</span>&gt;</span>
       <span class="tag">&lt;/<span class="title">idmef:Target</span>&gt;</span>
       <span class="tag">&lt;<span class="title">idmef:Classification</span> <span class="attribute">text</span>=<span class="value">"Teardrop detected"</span>&gt;</span>
         <span class="tag">&lt;<span class="title">idmef:Reference</span> <span class="attribute">origin</span>=<span class="value">"bugtraqid"</span>&gt;</span>
           <span class="tag">&lt;<span class="title">idmef:name</span>&gt;</span>124<span class="tag">&lt;/<span class="title">idmef:name</span>&gt;</span>
           <span class="tag">&lt;<span class="title">idmef:url</span>&gt;</span>http://www.securityfocus.com/bid/124<span class="tag">&lt;/<span class="title">idmef:url</span>&gt;</span>
         <span class="tag">&lt;/<span class="title">idmef:Reference</span>&gt;</span>
       <span class="tag">&lt;/<span class="title">idmef:Classification</span>&gt;</span>
     <span class="tag">&lt;/<span class="title">idmef:Alert</span>&gt;</span>
   <span class="tag">&lt;/<span class="title">idmef:IDMEF-Message</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight lang-xml"><figcaption><span>基于网络检测到的某个端口扫描行为（注意<portlist>中记录了被扫描的端口列表）</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
   <span class="tag">&lt;<span class="title">idmef:IDMEF-Message version="1.0"</span> <span class="attribute">xmlns:idmef</span>=<span class="value">"http://iana.org/idmef"</span>&gt;</span>
     <span class="tag">&lt;<span class="title">idmef:Alert</span> <span class="attribute">messageid</span>=<span class="value">"abc123456789"</span>&gt;</span>
       <span class="tag">&lt;<span class="title">idmef:Analyzer</span> <span class="attribute">analyzerid</span>=<span class="value">"hq-dmz-analyzer62"</span>&gt;</span>
         <span class="tag">&lt;<span class="title">idmef:Node</span> <span class="attribute">category</span>=<span class="value">"dns"</span>&gt;</span>
           <span class="tag">&lt;<span class="title">idmef:location</span>&gt;</span>Headquarters Web Server<span class="tag">&lt;/<span class="title">idmef:location</span>&gt;</span>
           <span class="tag">&lt;<span class="title">idmef:name</span>&gt;</span>analyzer62.example.com<span class="tag">&lt;/<span class="title">idmef:name</span>&gt;</span>
         <span class="tag">&lt;/<span class="title">idmef:Node</span>&gt;</span>
       <span class="tag">&lt;/<span class="title">idmef:Analyzer</span>&gt;</span>
       <span class="tag">&lt;<span class="title">idmef:CreateTime</span> <span class="attribute">ntpstamp</span>=<span class="value">"0xbc72b2b4.0x00000000"</span>&gt;</span>
         2000-03-09T15:31:00-08:00
       <span class="tag">&lt;/<span class="title">idmef:CreateTime</span>&gt;</span>
       <span class="tag">&lt;<span class="title">idmef:Source</span> <span class="attribute">ident</span>=<span class="value">"abc01"</span>&gt;</span>
         <span class="tag">&lt;<span class="title">idmef:Node</span> <span class="attribute">ident</span>=<span class="value">"abc01-01"</span>&gt;</span>
           <span class="tag">&lt;<span class="title">idmef:Address</span> <span class="attribute">ident</span>=<span class="value">"abc01-02"</span> <span class="attribute">category</span>=<span class="value">"ipv4-addr"</span>&gt;</span>
             <span class="tag">&lt;<span class="title">idmef:address</span>&gt;</span>192.0.2.200<span class="tag">&lt;/<span class="title">idmef:address</span>&gt;</span>
           <span class="tag">&lt;/<span class="title">idmef:Address</span>&gt;</span>
         <span class="tag">&lt;/<span class="title">idmef:Node</span>&gt;</span>
       <span class="tag">&lt;/<span class="title">idmef:Source</span>&gt;</span>
       <span class="tag">&lt;<span class="title">idmef:Target</span> <span class="attribute">ident</span>=<span class="value">"def01"</span>&gt;</span>
         <span class="tag">&lt;<span class="title">idmef:Node</span> <span class="attribute">ident</span>=<span class="value">"def01-01"</span> <span class="attribute">category</span>=<span class="value">"dns"</span>&gt;</span>
           <span class="tag">&lt;<span class="title">idmef:name</span>&gt;</span>www.example.com<span class="tag">&lt;/<span class="title">idmef:name</span>&gt;</span>
           <span class="tag">&lt;<span class="title">idmef:Address</span> <span class="attribute">ident</span>=<span class="value">"def01-02"</span> <span class="attribute">category</span>=<span class="value">"ipv4-addr"</span>&gt;</span>
             <span class="tag">&lt;<span class="title">idmef:address</span>&gt;</span>192.0.2.50<span class="tag">&lt;/<span class="title">idmef:address</span>&gt;</span>
           <span class="tag">&lt;/<span class="title">idmef:Address</span>&gt;</span>
         <span class="tag">&lt;/<span class="title">idmef:Node</span>&gt;</span>
         <span class="tag">&lt;<span class="title">idmef:Service</span> <span class="attribute">ident</span>=<span class="value">"def01-03"</span>&gt;</span>
           <span class="tag">&lt;<span class="title">idmef:portlist</span>&gt;</span>5-25,37,42,43,53,69-119,123-514
           <span class="tag">&lt;/<span class="title">idmef:portlist</span>&gt;</span>
         <span class="tag">&lt;/<span class="title">idmef:Service</span>&gt;</span>
       <span class="tag">&lt;/<span class="title">idmef:Target</span>&gt;</span>
       <span class="tag">&lt;<span class="title">idmef:Classification</span> <span class="attribute">text</span>=<span class="value">"simple portscan"</span>&gt;</span>
         <span class="tag">&lt;<span class="title">idmef:Reference</span> <span class="attribute">origin</span>=<span class="value">"vendor-specific"</span>&gt;</span>
           <span class="tag">&lt;<span class="title">idmef:name</span>&gt;</span>portscan<span class="tag">&lt;/<span class="title">idmef:name</span>&gt;</span>
           <span class="tag">&lt;<span class="title">idmef:url</span>&gt;</span>http://www.vendor.com/portscan<span class="tag">&lt;/<span class="title">idmef:url</span>&gt;</span>
         <span class="tag">&lt;/<span class="title">idmef:Reference</span>&gt;</span>
       <span class="tag">&lt;/<span class="title">idmef:Classification</span>&gt;</span>
     <span class="tag">&lt;/<span class="title">idmef:Alert</span>&gt;</span>
   <span class="tag">&lt;/<span class="title">idmef:IDMEF-Message</span>&gt;</span>
</pre></td></tr></table></figure>

<h3>3 参考资料</h3>
<pre><code><span class="comment">1</span>. <span class="comment">RFC4765</span> <span class="literal">-</span> <span class="comment">The</span> <span class="comment">Intrusion</span> <span class="comment">Detection</span> <span class="comment">Message</span> <span class="comment">Exchange</span> <span class="comment">Format</span> <span class="comment">(IDMEF)</span>
<span class="comment">2</span>. <span class="comment">RFC4767</span> <span class="literal">-</span> <span class="comment">The</span> <span class="comment">Intrusion</span> <span class="comment">Detection</span> <span class="comment">Exchange</span> <span class="comment">Protocol</span> <span class="comment">(IDXP)</code></pre>
]]></content>
    <category scheme="http://hutaow.net/blog/tags/IDS/" term="IDS"/>
    <category scheme="http://hutaow.net/blog/tags/入侵检测/" term="入侵检测"/>
    <category scheme="http://hutaow.net/blog/categories/Security/" term="Security"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[字符串中单词逆序的实现]]></title>
    <link href="http://hutaow.net/blog/2010/04/13/reverse-order-of-words-in-a-string/"/>
    <id>http://hutaow.net/blog/2010/04/13/reverse-order-of-words-in-a-string/</id>
    <published>2010-04-13T11:35:00.000Z</published>
    <updated>2013-10-14T14:35:22.000Z</updated>
    <content type="html"><![CDATA[<p>在Java中可以用压栈/弹栈的方式：</p>
<a id="more"></a>

<figure class="highlight lang-java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">import</span> java.util.Stack;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTest</span> {</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String argv[]) {
        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;String&gt;();
        <span class="keyword">for</span>(String s : <span class="string">"I have a round peach"</span>.split(<span class="string">" "</span>)) {
            <span class="comment">// 按字符串原顺序压栈</span>
            stack.push(s);
        }

        <span class="keyword">while</span>(!stack.empty()) {
            <span class="comment">// 弹栈并输出</span>
            System.out.print(stack.pop() + <span class="string">" "</span>);
        }
    }
}
</pre></td></tr></table></figure>

<p>运行后系统将输出 “peach round a have I ”。</p>
]]></content>
    <category scheme="http://hutaow.net/blog/tags/Java/" term="Java"/>
    <category scheme="http://hutaow.net/blog/tags/开发/" term="开发"/>
    <category scheme="http://hutaow.net/blog/categories/Programming/" term="Programming"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[正斜杠与反斜杠的分析]]></title>
    <link href="http://hutaow.net/blog/2010/01/30/analysis-of-the-forward-slash-and-backslash/"/>
    <id>http://hutaow.net/blog/2010/01/30/analysis-of-the-forward-slash-and-backslash/</id>
    <published>2010-01-29T16:29:00.000Z</published>
    <updated>2013-10-14T14:35:22.000Z</updated>
    <content type="html"><![CDATA[<p>正斜杠(左斜杠)，符号是“/”；反斜杠(右斜杠)，符号是&quot;\&quot;。</p>
<p>　　在Unix/Linux中，路径的分隔采用正斜杠“/”，比如“/home/hutaow”；而在Windows中，路径分隔采用反斜杠&quot;\“，比如”C:\Windows\System&quot;。</p>
<p>　　有时我们会看到这样的路径写法，&quot;C:\\Windows\\System“，也就是用两个反斜杠来分隔路径，这种写法在网络应用或编程中经常看到，事实上，上面这个路径可以用”C:/Windows/System“来代替，不会出错。但是如果写成了”C:\Windows\System&quot;，那就可能会出现各种奇怪的错误了。</p>
<a id="more"></a>

<p>　　至于上述问题出现的原因，要从字符串解析这方面来分析。</p>
<p>　　学过编程的人都应该知道，在C里面，输出字符串时，如果想输出一个换行，那就要加上&#39;\n‘这个标志，类似的，输出一个TAB，就加上’\t&#39;，也就是说，反斜杠(&quot;\“)这个符号会把跟在它后面的字符结合起来转义成其它字符。根据这个原理，如果想输出双引号(‘”’)，就需要输入&#39;\&quot;‘，这样才会将包含了双引号的字符串正确的写入内存中。那么如果想输入一个反斜杠呢？很简单，只要敲’\\&#39;就可以了。</p>
<p>　　看到这里或许有些人已经看出眉目了，如果&quot;C:\Windows\System“这个路径字符串交给C编译器编译，实际写入内存的字符串并没有包含反斜杠”\&quot;，甚至紧跟在反斜杠后面的字母也一起被转义成了其它的字符，再次调用的话势必会出问题。</p>
<p>　　字符串解析不仅仅局限于C编译器，Java编译器、一些配置文件的解析、Web服务器等等，都会遇到对字符串进行解析的这个问题，由于传统的Windows采用的是单个斜杠的路径分隔形式，导致在对文件路径进行解析的时候可能发生不必要的错误，所以就出现了用双反斜杠&quot;\\“分隔路径的形式。不管解析引擎是否将反斜杠解析成转义字符，最终在内存中得到的都是”\&quot;，结果也就不会出问题了。</p>
<p>　　由此也可以看出Windows或者说DOS在设计初期考虑不够周全，为了和Unix一些特征区别开来，将Unix中的正斜杠“/”分隔路径方式改变成了反斜杠&quot;\“。这样改变导致的一个问题就是在早期DOS命令行中，正常的文件名是不能包含空格的，如果包含了空格，会导致输入这样的文件名时，命令解析无法将其和参数区分开。例如，想要进入”hutaow yuan“这个目录（在此先忽略8.3命名规则），直接输入”cd hutaow yuan“，命令行会将其解析为进入”hutaow“目录，而后面的”yuan&quot;做参数，这显然不是所期望的。</p>
<p>　　而在Unix中，文件名如果包含空格，可以直接在空格前加上反斜杠&quot;\“进行转义，从而很好的和命令参数区别出来（参数之间一般使用空格分隔）。还是上面的例子，在Unix中，只要输入”cd hutaow\ yuan“(在yuan前面的空格前加上”\“)，命令行会正确的辨认出”hutaow yuan&quot;并进入这个目录。</p>
<p>　　当然，现在Windows的后续版本已经使用其它方法（比如文件名用双引号括住）解决了空格问题。</p>
]]></content>
    <category scheme="http://hutaow.net/blog/categories/Technology/" term="Technology"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[HTC Diamond 两个有意思的功能]]></title>
    <link href="http://hutaow.net/blog/2010/01/14/interesting-features-in-htc-diamond/"/>
    <id>http://hutaow.net/blog/2010/01/14/interesting-features-in-htc-diamond/</id>
    <published>2010-01-14T12:28:00.000Z</published>
    <updated>2013-10-14T14:35:22.000Z</updated>
    <content type="html"><![CDATA[<p>这两天一直折腾 HTC Diamond，发现了两个很有意思的功能：</p>
<ol>
<li><p>Diamond的手写笔不像其它手机那样有卡槽卡住，而是像有磁铁一样把笔“吸”进去，实际上功能远不止这个。在Diamond关闭屏幕时，拔出手写笔，屏幕会自动亮起，还有比这更神奇的，在打电话时，如果拔出手写笔，Diamond会打开便签，并且便签已经包含了通话对象、时间等信息，方便记录；</p>
</li>
<li><p>Diamond的重力感应不仅用在玩游戏上，来电话时，只要把手机面向下放，就可以关闭铃声（静音）。这避免了在开会等类似场合突然遇到来电手忙脚乱情况的发生。</p>
</li>
</ol>
]]></content>
    <category scheme="http://hutaow.net/blog/tags/折腾/" term="折腾"/>
    <category scheme="http://hutaow.net/blog/categories/Technology/" term="Technology"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Xmarks(原Foxmarks)被墙之后更新的方法]]></title>
    <link href="http://hutaow.net/blog/2010/01/12/slove-the-problem-that-xmarks-was-block-by-gfw/"/>
    <id>http://hutaow.net/blog/2010/01/12/slove-the-problem-that-xmarks-was-block-by-gfw/</id>
    <published>2010-01-12T14:53:00.000Z</published>
    <updated>2013-10-14T14:35:22.000Z</updated>
    <content type="html"><![CDATA[<p>最近重新装上Xmarks书签同步之后，发现不能用了，还以为设置出了问题，上官网发现已经上不去了，被GFW屏蔽了。于是上网查找解决办法，总结如下：</p>
<h4>1. 手动添加域名解析的地址，即向“C:\Windows\System32\Drivers\etc\hosts&quot;文件中添加如下内容：</h4>
<a id="more"></a>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="preprocessor"># Xmarks</span>
<span class="number">64.147</span><span class="number">.188</span><span class="number">.86</span> www<span class="variable">.xmarks</span><span class="variable">.com</span>
<span class="number">64.147</span><span class="number">.188</span><span class="number">.92</span> api<span class="variable">.xmarks</span><span class="variable">.com</span>
<span class="number">64.147</span><span class="number">.188</span><span class="number">.89</span> login<span class="variable">.xmarks</span><span class="variable">.com</span>
<span class="number">64.147</span><span class="number">.188</span><span class="number">.87</span> sync<span class="variable">.xmarks</span><span class="variable">.com</span>
<span class="number">64.147</span><span class="number">.188</span><span class="number">.86</span> <span class="keyword">static</span><span class="variable">.xmarks</span><span class="variable">.com</span>
<span class="number">64.147</span><span class="number">.188</span><span class="number">.86</span> download<span class="variable">.xmarks</span><span class="variable">.com</span>
<span class="number">64.147</span><span class="number">.188</span><span class="number">.86</span> my<span class="variable">.xmarks</span><span class="variable">.com</span>
</pre></td></tr></table></figure>

<h4>2. 设置Xmarks连接及传输数据过程中加密，即在“Connection Security”中选择“Encrypt All”。</h4>
<p>以上两步即可解决Xmarks不能同步的问题。</p>
<h4>分析原因：</h4>
<ol>
<li><p>第一步操作的原因在于GFW是根据URL而不是IP进行过滤的，所以在请求解析诸如“xmarks.com”等类似的域名时，返回结果被GFW拦截，所以要手动添加xmarks.com一系列服务器的域名IP；</p>
</li>
<li><p>第二步操作让Xmarks在同步时对数据进行加密，GFW是无法认出加密的数据的，也就无法进一步拦截了。</p>
</li>
</ol>
]]></content>
    <category scheme="http://hutaow.net/blog/tags/Xmarks/" term="Xmarks"/>
    <category scheme="http://hutaow.net/blog/tags/Foxmarks/" term="Foxmarks"/>
    <category scheme="http://hutaow.net/blog/categories/Technology/" term="Technology"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[标记ATL控件为安全控件]]></title>
    <link href="http://hutaow.net/blog/2009/05/02/mark-atl-control-as-a-safe-control/"/>
    <id>http://hutaow.net/blog/2009/05/02/mark-atl-control-as-a-safe-control/</id>
    <published>2009-05-02T06:02:00.000Z</published>
    <updated>2013-10-14T14:35:22.000Z</updated>
    <content type="html"><![CDATA[<p>用ATL开发网页控件时，IE总会出现“该控件不是安全的”之类的提示，去掉这个提示的方法就是使用 IObjectSafety 将其标记为可安全初始化的控件。</p>
<p>实现方法如下：</p>
<p>首先在需要将 IObjectSafetyImpl 添加到该控件的派生类中，然后在映射列表中添加 IObjectSafety，具体添加的代码如下：</p>
<a id="more"></a>

<figure class="highlight lang-c++"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre>class CHutaow : 
    // 添加到控件的派生类列表中
    public IObjectSafetyImpl&lt;CHutaow, INTERFACESAFE_FOR_UNTRUSTED_CALLER|INTERFACESAFE_FOR_UNTRUSTED_DATA&gt;
    <span class="keyword">...</span>
    {
        public:

        BEGIN_COM_MAP(CHutaow)
        
        COM_INTERFACE_ENTRY(IObjectSafety) //创建IObjectSafety的映射
        
        <span class="keyword">...</span>

        END_COM_MAP()
        <span class="keyword">...</span>
    }
</pre></td></tr></table></figure>

<p>PS: 如果出现“‘IObjectSafetyImpl’ : base class undefined”的错误，则需要添加“atlctl.h”头文件。</p>
]]></content>
    <category scheme="http://hutaow.net/blog/tags/ATL/" term="ATL"/>
    <category scheme="http://hutaow.net/blog/tags/开发/" term="开发"/>
    <category scheme="http://hutaow.net/blog/tags/控件/" term="控件"/>
    <category scheme="http://hutaow.net/blog/categories/Programming/" term="Programming"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[SQL语句实现某一字符串的替换]]></title>
    <link href="http://hutaow.net/blog/2009/04/02/sql-statements-batch-replace-a-string/"/>
    <id>http://hutaow.net/blog/2009/04/02/sql-statements-batch-replace-a-string/</id>
    <published>2009-04-02T02:55:00.000Z</published>
    <updated>2013-10-14T14:35:22.000Z</updated>
    <content type="html"><![CDATA[<p>使用update+replace语句：</p>
<figure class="highlight lang-mysql"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="operator"><span class="keyword">update</span> table_name <span class="keyword">set</span> column_name = <span class="keyword">replace</span>(column_name,’hutaow_original_string’,<span class="string">'hutaow_new_string’);
</pre></td></tr></table></figure>

<p>其中，table_name是表的名字，column_name是要替换数据的列的名字，hutaow_original_string是待替换的原始字符串，hutaow_new_string是新字符串，MySQL下验证成功。</p>
]]></content>
    <category scheme="http://hutaow.net/blog/tags/数据库/" term="数据库"/>
    <category scheme="http://hutaow.net/blog/tags/SQL/" term="SQL"/>
    <category scheme="http://hutaow.net/blog/tags/MySQL/" term="MySQL"/>
    <category scheme="http://hutaow.net/blog/categories/Database/" term="Database"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Java中十六进制字符串与字节数组的相互转换]]></title>
    <link href="http://hutaow.net/blog/2008/08/14/convert-between-byte-array-and-hex-string/"/>
    <id>http://hutaow.net/blog/2008/08/14/convert-between-byte-array-and-hex-string/</id>
    <published>2008-08-14T11:05:00.000Z</published>
    <updated>2013-10-14T14:35:22.000Z</updated>
    <content type="html"><![CDATA[<p>原理很简单，直接贴源代码吧。</p>
<a id="more"></a>

<figure class="highlight lang-java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre></td><td class="code"><pre><span class="javadoc">/**
 * <span class="javadoctag">@author</span> wangtao
 * <span class="javadoctag">@version</span> 2008.8.14
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Util</span> {</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span>[] hexDigits = 
    {<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>};

    <span class="javadoc">/**
     * <span class="javadoctag">@notes</span> 字节数组转化为字符串
     * <span class="javadoctag">@param</span> bytes
     * <span class="javadoctag">@return</span> String
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> String toHexString(<span class="keyword">byte</span>[] bytes) {
        <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[bytes.length * <span class="number">2</span>];

        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) {
            <span class="keyword">int</span> b = bytes[i];
            chars[i * <span class="number">2</span>] = Util.hexDigits[(b & <span class="number">0xF0</span>) &gt;&gt; <span class="number">4</span>];
            chars[i * <span class="number">2</span> + <span class="number">1</span>] = Util.hexDigits[b & <span class="number">0x0F</span>];
        }

        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);
    }

    <span class="javadoc">/**
     * <span class="javadoctag">@notes</span> 字符串转化为字节数组
     * <span class="javadoctag">@param</span> str
     * <span class="javadoctag">@return</span> byte[]
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] toByteArray(String str) { 
        <span class="keyword">int</span> length = str.length() / <span class="number">2</span>;
        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];
        <span class="keyword">byte</span>[] source = str.getBytes();

        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; ++i) {
            <span class="keyword">byte</span> bh = Byte.decode(<span class="string">"0x"</span> + <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">byte</span>[]{source[i * <span class="number">2</span>]})).byteValue();
            bh = (<span class="keyword">byte</span>)(bh &lt;&lt; <span class="number">4</span>);
            <span class="keyword">byte</span> bl = Byte.decode(<span class="string">"0x"</span> + <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">byte</span>[]{source[i * <span class="number">2</span> + <span class="number">1</span>]})).byteValue();
            bytes[i] = (<span class="keyword">byte</span>)(bh ^ bl);
        }

        <span class="keyword">return</span> bytes;
    }
}
</pre></td></tr></table></figure>

]]></content>
    <category scheme="http://hutaow.net/blog/tags/Java/" term="Java"/>
    <category scheme="http://hutaow.net/blog/tags/开发/" term="开发"/>
    <category scheme="http://hutaow.net/blog/categories/Programming/" term="Programming"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[终端下使用代理的方法]]></title>
    <link href="http://hutaow.net/blog/2008/08/10/config-proxy-in-linux-terminal/"/>
    <id>http://hutaow.net/blog/2008/08/10/config-proxy-in-linux-terminal/</id>
    <published>2008-08-10T07:12:00.000Z</published>
    <updated>2013-10-14T14:35:22.000Z</updated>
    <content type="html"><![CDATA[<p>很长时间都不知道怎么设置，今天突然发现，设置四个环境变量就行了，&quot;HTTP_PROXY“、”http_proxy“和”FTP_PROXY“、”ftp_proxy“，在”~/.bash_profile&quot;中添加以下几行：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>export <span class="class">HTTP_PROXY</span>=<span class="method">http:</span>//<span class="method">username:</span>password@proxy.<span class="method">server:</span><span class="number">8080</span>
export <span class="class">FTP_PROXY</span>=<span class="method">http:</span>//<span class="method">username:</span>password@proxy.<span class="method">server:</span><span class="number">8080</span>
export http_proxy=<span class="method">http:</span>//<span class="method">username:</span>password@proxy.<span class="method">server:</span><span class="number">8080</span>
export ftp_proxy=<span class="method">http:</span>//<span class="method">username:</span>password@proxy.<span class="method">server:</span><span class="number">8080</span>
</pre></td></tr></table></figure>

<p>其中，username和password是用户名和密码，用在需要验证的代理服务器上；proxy.server是代理服务器的地址，后面的8080是端口号。</p>
<p>修改保存后重启终端或在执行&quot;source ~/.bash_proxy&quot;生效。</p>
]]></content>
    <category scheme="http://hutaow.net/blog/tags/Linux/" term="Linux"/>
    <category scheme="http://hutaow.net/blog/tags/代理/" term="代理"/>
    <category scheme="http://hutaow.net/blog/categories/Linux/" term="Linux"/>
  </entry>
</feed>
