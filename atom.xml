<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[胡桃夹子]]></title>
  <subtitle><![CDATA[open source, world shares.]]></subtitle>
  <link href="http://hutaow.com/atom.xml" rel="self"/>
  <link href="http://hutaow.com"/>
  <updated>2013-12-27T17:53:54.821Z</updated>
  <id>http://hutaow.com/</id>
  <author>
    <name><![CDATA[Wang Tao]]></name>
    <email><![CDATA[hutaow@gmail.com]]></email>
  </author>
  <generator uri="http://zespia.tw/hexo">Hexo</generator>
  <entry>
    <title type="html"><![CDATA[将 Python 脚本转换为可执行程序]]></title>
    <link href="http://hutaow.com/blog/2013/12/24/convert-python-script-to-executable-program/"/>
    <id>http://hutaow.com/blog/2013/12/24/convert-python-script-to-executable-program/</id>
    <published>2013-12-23T16:00:01.000Z</published>
    <updated>2013-12-23T17:40:27.000Z</updated>
    <content type="html"><![CDATA[<p>本文所使用的工具是cx_Freeze，相对py2exe和PyInstaller来说，cx_Freeze的兼容性更好，支持最新的Python 3.X，支持PyQT，并且可以跨平台支持Windows和Linux系统。</p>
<p>cx_Freeze的官方主页为<a href="http://cx-freeze.sourceforge.net" target="_blank"><a href="http://cx-freeze.sourceforge.net">http://cx-freeze.sourceforge.net</a></a>，下面以Windows系统为例介绍一下它的使用方法。</p>
<a id="more"></a>

<h3>1 配置转换脚本</h3>
<p>新建一个Python脚本文件，如<code>setup.py</code>，内容如下：</p>
<figure class="highlight lang-python"><figcaption><span>Setup Script </span><a href="/downloads/code/setup.py">download</a></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">import</span> sys
<span class="keyword">from</span> cx_Freeze <span class="keyword">import</span> setup, Executable

base = <span class="built_in">None</span>
<span class="keyword">if</span> sys.platform == <span class="string">"win32"</span>:
    base = <span class="string">"Win32GUI"</span>

setup(  name = <span class="string">"MyApp"</span>,
        version = <span class="string">"0.1"</span>,
        description = <span class="string">"My PyQT application!"</span>,
        executables = [Executable(<span class="string">"pyqt_example.py"</span>, base=base)])

</pre></td></tr></table></figure>


<p>其中<code>pyqt_example.py</code>为将要转换的脚本文件，其它字段为描述信息，根据实际情况修改即可。</p>
<h3>2 执行转换脚本</h3>
<p>在脚本所在的目录执行下面的命令，其中<code>build</code>为转换后的程序存放目录：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">python</span> setup.py build
</pre></td></tr></table></figure>

<p>执行后即会在<code>build</code>目录中生成对应的可执行程序了，并且程序运行过程中依赖的库文件也自动拷贝好了。</p>
]]></content>
    <category scheme="http://hutaow.com/blog/tags/Python/" term="Python"/>
    <category scheme="http://hutaow.com/blog/categories/Programming/" term="Programming"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[使用 PyQT 作为 Python 的图形界面]]></title>
    <link href="http://hutaow.com/blog/2013/12/16/using-pyqt-as-graphical-interface-for-python/"/>
    <id>http://hutaow.com/blog/2013/12/16/using-pyqt-as-graphical-interface-for-python/</id>
    <published>2013-12-16T15:02:24.000Z</published>
    <updated>2013-12-20T15:39:28.000Z</updated>
    <content type="html"><![CDATA[<p>以前Python写出来的脚本都是靠命令行执行，输入要是复杂点就得靠加参数，甚至加配置文件来搞定，自己用下还行，给别人用的时候总是不太方便，就一直想找个好用的图形界面库。</p>
<p>有试过Python内置的Tkinter，部署倒是挺简单，不需要额外安装库，但是开发效率还是不够高，而且需要手写不少界面相关的重复代码，用起来不太方便。</p>
<p>最近开始尝试第三方的界面库，几经权衡，最终在PyGTK、wxPython、PyQT中选择了PyQT，试了一下，确实很不错，下面就介绍一下PyQT的使用方法。</p>
<a id="more"></a>

<h3>1 介绍</h3>
<p>PyQT以QT为基础，跨平台（可以运行在Windows、Linux/Unix、MacOS等操作系统上），同时PyQT的界面可以直接用QT Designer做出来，可以很容易移植到其它语言上（C++、C#、Java、Perl等）。</p>
<h3>2 例子</h3>
<p>为了更好了了解PyQT，先写一段简单的示例代码，例子中通过点击按钮，来改变文本框所显示的内容，具体代码含义直接通过注释说明了。</p>
<figure class="highlight lang-python"><figcaption><span>Example of PyQT </span><a href="/downloads/code/pyqt_example.py">download</a></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="code"><pre><span class="comment"># -*- coding: utf-8 -*-</span>

<span class="keyword">import</span> sys
<span class="keyword">from</span> PyQt4 <span class="keyword">import</span> QtCore, QtGui

<span class="comment"># 自定义的窗口类</span>
<span class="class"><span class="keyword">class</span> <span class="title">TestWindow</span><span class="params">(QtGui.QWidget)</span>:</span>
    <span class="comment"># 窗口初始化</span>
    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent = None)</span>:</span>
        super(TestWindow, self).__init__(parent)
        self.setWindowTitle(<span class="string">u'胡桃夹子'</span>)

        <span class="comment"># 创建按钮</span>
        self.pushButton = QtGui.QPushButton(<span class="string">u'测试按钮'</span>)

        <span class="comment"># 创建文本框</span>
        self.textEdit = QtGui.QTextEdit()

        <span class="comment"># 创建垂直布局</span>
        layout = QtGui.QVBoxLayout()

        <span class="comment"># 将控件添加到布局中</span>
        layout.addWidget(self.textEdit)
        layout.addWidget(self.pushButton)

        <span class="comment"># 设置窗口布局</span>
        self.setLayout(layout)

        <span class="comment"># 设置按钮单击动作</span>
        self.pushButton.clicked.connect(self.sayHello)

    <span class="comment"># 按钮动作处理</span>
    <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span><span class="params">(self)</span>:</span>
        self.textEdit.setText(<span class="string">'Hello World!'</span>)

<span class="comment"># 程序主入口</span>
<span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:
    app = QtGui.QApplication(sys.argv)
    mainWindow = TestWindow()
    mainWindow.show()
    sys.exit(app.exec_())


</pre></td></tr></table></figure>


<p>运行效果如下图，点击按钮后，文本框中会显示<code>Hello World!</code>字符串：</p>
<p><img src="/images/articles/201312/pyqt_example.png" alt="Example of PyQT"></p>
<h3>3 设计界面</h3>
<p>了解了PyQT之后，设计界面的工作就可以交给QT设计器来完成，不再需要手写界面代码，最大限度的提高界面开发速度。下面通过QT设计器的方式再完成一次上面例子中的功能。</p>
<p>在QT设计器中，新建一个<code>Dialog</code>类型的窗体，然后向窗体中分别加入<code>Vertical Layout</code>、<code>Push Button</code>和<code>Text Edit</code>三个控件，并界面摆成下图的样子：</p>
<p><img src="/images/articles/201312/qt_designer.png" alt="Example of QT Designer for PyQT"></p>
<p>还可以通过设置各控件的属性来修改界面显示的文字、效果等，此处不过多叙述，下面将设计好的界面保存为<code>qt_designer_example.ui</code>文件，文件内容如下：</p>
<figure class="highlight lang-xml"><figcaption><span>Example of QT Designer for PyQT </span><a href="/downloads/code/qt_designer_example.ui">download</a></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre></td><td class="code"><pre><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="tag">&lt;<span class="title">ui</span> <span class="attribute">version</span>=<span class="value">"4.0"</span>&gt;</span>
 <span class="tag">&lt;<span class="title">class</span>&gt;</span>Dialog<span class="tag">&lt;/<span class="title">class</span>&gt;</span>
 <span class="tag">&lt;<span class="title">widget</span> <span class="attribute">class</span>=<span class="value">"QDialog"</span> <span class="attribute">name</span>=<span class="value">"Dialog"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"windowModality"</span>&gt;</span>
   <span class="tag">&lt;<span class="title">enum</span>&gt;</span>Qt::NonModal<span class="tag">&lt;/<span class="title">enum</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
  <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"geometry"</span>&gt;</span>
   <span class="tag">&lt;<span class="title">rect</span>&gt;</span>
    <span class="tag">&lt;<span class="title">x</span>&gt;</span>0<span class="tag">&lt;/<span class="title">x</span>&gt;</span>
    <span class="tag">&lt;<span class="title">y</span>&gt;</span>0<span class="tag">&lt;/<span class="title">y</span>&gt;</span>
    <span class="tag">&lt;<span class="title">width</span>&gt;</span>280<span class="tag">&lt;/<span class="title">width</span>&gt;</span>
    <span class="tag">&lt;<span class="title">height</span>&gt;</span>240<span class="tag">&lt;/<span class="title">height</span>&gt;</span>
   <span class="tag">&lt;/<span class="title">rect</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
  <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"windowTitle"</span>&gt;</span>
   <span class="tag">&lt;<span class="title">string</span>&gt;</span>Dialog<span class="tag">&lt;/<span class="title">string</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
  <span class="tag">&lt;<span class="title">widget</span> <span class="attribute">class</span>=<span class="value">"QWidget"</span> <span class="attribute">name</span>=<span class="value">"verticalLayoutWidget"</span>&gt;</span>
   <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"geometry"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">rect</span>&gt;</span>
     <span class="tag">&lt;<span class="title">x</span>&gt;</span>10<span class="tag">&lt;/<span class="title">x</span>&gt;</span>
     <span class="tag">&lt;<span class="title">y</span>&gt;</span>10<span class="tag">&lt;/<span class="title">y</span>&gt;</span>
     <span class="tag">&lt;<span class="title">width</span>&gt;</span>258<span class="tag">&lt;/<span class="title">width</span>&gt;</span>
     <span class="tag">&lt;<span class="title">height</span>&gt;</span>221<span class="tag">&lt;/<span class="title">height</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">rect</span>&gt;</span>
   <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
   <span class="tag">&lt;<span class="title">layout</span> <span class="attribute">class</span>=<span class="value">"QVBoxLayout"</span> <span class="attribute">name</span>=<span class="value">"verticalLayout"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">item</span>&gt;</span>
     <span class="tag">&lt;<span class="title">widget</span> <span class="attribute">class</span>=<span class="value">"QTextEdit"</span> <span class="attribute">name</span>=<span class="value">"textEdit"</span>/&gt;</span>
    <span class="tag">&lt;/<span class="title">item</span>&gt;</span>
    <span class="tag">&lt;<span class="title">item</span>&gt;</span>
     <span class="tag">&lt;<span class="title">widget</span> <span class="attribute">class</span>=<span class="value">"QPushButton"</span> <span class="attribute">name</span>=<span class="value">"pushButton"</span>&gt;</span>
      <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"text"</span>&gt;</span>
       <span class="tag">&lt;<span class="title">string</span>&gt;</span>PushButton<span class="tag">&lt;/<span class="title">string</span>&gt;</span>
      <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
     <span class="tag">&lt;/<span class="title">widget</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">item</span>&gt;</span>
   <span class="tag">&lt;/<span class="title">layout</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">widget</span>&gt;</span>
 <span class="tag">&lt;/<span class="title">widget</span>&gt;</span>
 <span class="tag">&lt;<span class="title">resources</span>/&gt;</span>
 <span class="tag">&lt;<span class="title">connections</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">ui</span>&gt;</span>

</pre></td></tr></table></figure>


<p>可以看出，QT设计器所保存的界面是XML文件格式的，事实上，QT设计器所生成的界面可以很自由的移植到不同语言中，甚至不需要太多额外的适配工作，非常方便。</p>
<h3>4 生成代码</h3>
<p>有了QT界面，下一步就需要用<code>pyuic</code>这个工具来将QT界面转换为Python代码（基于PyQT库），转换命令如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="comment">pyuic4</span> <span class="literal">-</span><span class="comment">x</span> <span class="literal">-</span><span class="comment">o</span> <span class="comment">qt_designer_example</span>.<span class="comment">py</span> <span class="comment">qt_designer_example</span>.<span class="comment">ui
</pre></td></tr></table></figure>

<p>其中<code>-o qt_designer_example.py</code>用来标识输出文件名；这里需要特别说明的是<code>-x</code>参数，该参数表示是否生成额外的测试代码来显示窗口，建议加上该参数，这样的话可以方便直接调试运行。</p>
<p>下面是通过<code>pyuic</code>工具生成的Python代码：</p>
<figure class="highlight lang-python"><figcaption><span>Example of QT Designer for PyQT </span><a href="/downloads/code/qt_designer_example.py">download</a></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre></td><td class="code"><pre><span class="comment"># -*- coding: utf-8 -*-</span>

<span class="comment"># Form implementation generated from reading ui file 'qt_designer_example.ui'</span>
<span class="comment">#</span>
<span class="comment"># Created: Wed Dec 18 22:52:55 2013</span>
<span class="comment">#      by: PyQt4 UI code generator 4.10.3</span>
<span class="comment">#</span>
<span class="comment"># WARNING! All changes made in this file will be lost!</span>

<span class="keyword">from</span> PyQt4 <span class="keyword">import</span> QtCore, QtGui

<span class="keyword">try</span>:
    _fromUtf8 = QtCore.QString.fromUtf8
<span class="keyword">except</span> AttributeError:
    <span class="function"><span class="keyword">def</span> <span class="title">_fromUtf8</span><span class="params">(s)</span>:</span>
        <span class="keyword">return</span> s

<span class="keyword">try</span>:
    _encoding = QtGui.QApplication.UnicodeUTF8
    <span class="function"><span class="keyword">def</span> <span class="title">_translate</span><span class="params">(context, text, disambig)</span>:</span>
        <span class="keyword">return</span> QtGui.QApplication.translate(context, text, disambig, _encoding)
<span class="keyword">except</span> AttributeError:
    <span class="function"><span class="keyword">def</span> <span class="title">_translate</span><span class="params">(context, text, disambig)</span>:</span>
        <span class="keyword">return</span> QtGui.QApplication.translate(context, text, disambig)

<span class="class"><span class="keyword">class</span> <span class="title">Ui_Dialog</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">setupUi</span><span class="params">(self, Dialog)</span>:</span>
        Dialog.setObjectName(_fromUtf8(<span class="string">"Dialog"</span>))
        Dialog.setWindowModality(QtCore.Qt.NonModal)
        Dialog.resize(<span class="number">279</span>, <span class="number">262</span>)
        self.verticalLayoutWidget = QtGui.QWidget(Dialog)
        self.verticalLayoutWidget.setGeometry(QtCore.QRect(<span class="number">10</span>, <span class="number">20</span>, <span class="number">258</span>, <span class="number">221</span>))
        self.verticalLayoutWidget.setObjectName(_fromUtf8(<span class="string">"verticalLayoutWidget"</span>))
        self.verticalLayout = QtGui.QVBoxLayout(self.verticalLayoutWidget)
        self.verticalLayout.setMargin(<span class="number">0</span>)
        self.verticalLayout.setObjectName(_fromUtf8(<span class="string">"verticalLayout"</span>))
        self.textEdit = QtGui.QTextEdit(self.verticalLayoutWidget)
        self.textEdit.setObjectName(_fromUtf8(<span class="string">"textEdit"</span>))
        self.verticalLayout.addWidget(self.textEdit)
        self.pushButton = QtGui.QPushButton(self.verticalLayoutWidget)
        self.pushButton.setObjectName(_fromUtf8(<span class="string">"pushButton"</span>))
        self.verticalLayout.addWidget(self.pushButton)

        self.retranslateUi(Dialog)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    <span class="function"><span class="keyword">def</span> <span class="title">retranslateUi</span><span class="params">(self, Dialog)</span>:</span>
        Dialog.setWindowTitle(_translate(<span class="string">"Dialog"</span>, <span class="string">"Dialog"</span>, <span class="built_in">None</span>))
        self.pushButton.setText(_translate(<span class="string">"Dialog"</span>, <span class="string">"PushButton"</span>, <span class="built_in">None</span>))


<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    <span class="keyword">import</span> sys
    app = QtGui.QApplication(sys.argv)
    Dialog = QtGui.QDialog()
    ui = Ui_Dialog()
    ui.setupUi(Dialog)
    Dialog.show()
    sys.exit(app.exec_())


</pre></td></tr></table></figure>


<h3>5 处理事件</h3>
<p>QT采用的是<code>Signal</code>（信号）和<code>Slot</code>（槽）的机制来处理事件，Signal负责发送消息来触发事件动作，Slot负责接收消息并进行相应的事件处理（在PyQT中，Signal和Slot可以是任何类型）。</p>
<p>有两种方式可以连接Signal和Slot：</p>
<p><strong>方法一：传统QT的连接方式</strong></p>
<figure class="highlight lang-python"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>self.connect(self.sender, SIGNAL(<span class="string">"sndSignal(int)"</span>), self.receiver, SLOT(<span class="string">"rcvSlot(int)"</span>))
</pre></td></tr></table></figure>

<p><strong>方法二：适用于Python的连接方式</strong></p>
<figure class="highlight lang-python"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>self.sndSignal.connect(self.receiver.rcvSlot)
</pre></td></tr></table></figure>

<p>本例中我们在<code>Ui_Dialog</code>类的<code>setupUi</code>函数中增加Signal/Slot的连接，然后再增加一个<code>sayHello</code>的事件（Slot）处理函数，先来看下方法一的连接方式：</p>
<figure class="highlight lang-python"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">Ui_Dialog</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">setupUi</span><span class="params">(self, Dialog)</span>:</span>
        ... ...
        QtCore.QObject.connect(self.pushButton, QtCore.SIGNAL(<span class="string">"clicked()"</span>), self.sayHello)

    <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span><span class="params">(self)</span>:</span>
        self.textEdit.setText(<span class="string">'Hello World!'</span>)
</pre></td></tr></table></figure>

<p>下面是方法二的连接方式：</p>
<figure class="highlight lang-python"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">Ui_Dialog</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">setupUi</span><span class="params">(self, Dialog)</span>:</span>
        ... ...
        self.pushButton.clicked.connect(self.sayHello)

    <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span><span class="params">(self)</span>:</span>
        self.textEdit.setText(<span class="string">'Hello World!'</span>)
</pre></td></tr></table></figure>

<p>可以看出方法二的连接方式使用更简单，也更符合Python的编程风格。</p>
<h3>6 后记</h3>
<p>完成上述步骤后，就可以运行Python脚本了，运行后界面功能和开头中的例子基本相同，只不过这个是用QT设计器辅助完成的，相比手写界面代码来说，效率高了不少。</p>
]]></content>
    <category scheme="http://hutaow.com/blog/tags/Python/" term="Python"/>
    <category scheme="http://hutaow.com/blog/tags/QT/" term="QT"/>
    <category scheme="http://hutaow.com/blog/tags/PyQT/" term="PyQT"/>
    <category scheme="http://hutaow.com/blog/tags/脚本/" term="脚本"/>
    <category scheme="http://hutaow.com/blog/categories/Programming/" term="Programming"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[类型转换导致字符串大小计算错误的问题]]></title>
    <link href="http://hutaow.com/blog/2013/12/05/string-size-calculation/"/>
    <id>http://hutaow.com/blog/2013/12/05/string-size-calculation/</id>
    <published>2013-12-04T17:17:30.000Z</published>
    <updated>2013-12-04T18:29:37.000Z</updated>
    <content type="html"><![CDATA[<p>今天在定位问题时，发现有一个字符串关键字在搜索时死活不命中，但实际那个关键字在数据中是存在的，跟踪发现是一个不起眼的细节导致的。</p>
<a id="more"></a>

<p>用一段简短的代码来说明一下问题出在哪里：</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="comment">#include &lt;stdio.h&gt;</span>

<span class="comment">#define M_STRING_1 "test"</span>
<span class="comment">#define M_STRING_2 (char *)"test"</span>

<span class="keyword">int</span> main(<span class="keyword">int</span> argc, char <span class="variable">*argv</span>[])
{
    char <span class="variable">*pcStr</span> = M_STRING_1;

    <span class="keyword">printf</span>(<span class="string">"Size of string macro 1      : <span class="variable">%u</span> bytes \r\n"</span>, sizeof(M_STRING_1));
    <span class="keyword">printf</span>(<span class="string">"Size of string pointer 1    : <span class="variable">%u</span> bytes \r\n"</span>, sizeof(pcStr));
    <span class="keyword">printf</span>(<span class="string">"Size of string macro 2      : <span class="variable">%u</span> bytes \r\n"</span>, sizeof(M_STRING_2));

    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>

<p>程序运行结果：</p>
<pre><code>Size <span class="keyword">of</span> <span class="typename">string</span> macro <span class="number">1</span>      : <span class="number">5</span> bytes 
Size <span class="keyword">of</span> <span class="typename">string</span> pointer <span class="number">1</span>    : <span class="number">8</span> bytes 
Size <span class="keyword">of</span> <span class="typename">string</span> macro <span class="number">2</span>      : <span class="number">8</span> bytes</code></pre>
<p><strong>第一行</strong>：宏定义字符串长度为4字节，<code>sizeof(M_STRING_1)</code>加上<code>0x00</code>结束符，大小是5字节没问题。<br><strong>第二行</strong>：<code>sizeof(pcStr)</code>是在计算指针的长度，计算出的值和CPU寄存器的宽度有关，我的机器是64位，所以得到的大小是8字节，这个也是在预料之中。<br><strong>第三行</strong>：问题就发生在这里，本来以为会和第一行计算结果一样是5字节，实际结果却是预料之外的8字节（指针长度）！</p>
<p>分析发现，<code>M_STRING_2</code>宏定义中的字符串多了一个<code>(char *)</code>的强制转换，正是这个转换导致<code>sizeof</code>的入参从字符串常量变成了指针，从而计算出的大小为指针的长度而非字符串的大小。</p>
<p>开头提到的关键字不匹配问题，也正是由于关键字长度超出实际值，导致访问越界，而越界部分的值是不可预知的，最终造成了无法命中的问题。</p>
]]></content>
    <category scheme="http://hutaow.com/blog/tags/C/" term="C"/>
    <category scheme="http://hutaow.com/blog/tags/开发/" term="开发"/>
    <category scheme="http://hutaow.com/blog/categories/Programming/" term="Programming"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[配置 VIM 开发环境]]></title>
    <link href="http://hutaow.com/blog/2013/11/22/vim-development-environment/"/>
    <id>http://hutaow.com/blog/2013/11/22/vim-development-environment/</id>
    <published>2013-11-22T14:43:22.000Z</published>
    <updated>2013-12-07T17:03:15.000Z</updated>
    <content type="html"><![CDATA[<h3>1 插件列表</h3>
<h4>1.1 CTags</h4>
<p>CTags用来给源代码生成索引文件，以便于文本编辑器快速定位符号位置（变量、函数、类等）。</p>
<p>下载地址：<a href="http://ctags.sourceforge.net" target="_blank"><a href="http://ctags.sourceforge.net">http://ctags.sourceforge.net</a></a></p>
<p>使用方式：在代码的根目录执行如下命令即可生成tag文件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="comment">ctags</span> <span class="literal">-</span><span class="comment">R</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">c</span>+<span class="literal">+</span><span class="literal">-</span><span class="comment">kinds=</span>+<span class="comment">p</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">fields=</span>+<span class="comment">iaS</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">extra=</span>+<span class="comment">q</span> <span class="string">.</span>
</pre></td></tr></table></figure>

<a id="more"></a>

<p>这个命令有点长，可以在<code>.vimrc</code>的文件中加个键盘映射，像下面的样子，这样只需要按下<code>CTRL+F12</code>即可生成tag文件了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="stl_container"><span class="built_in">map</span> &lt;C-F12&gt;</span> :!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q .
</pre></td></tr></table></figure>

<p>另外，如果需要指明源代码的语言，则需要加上<code>--languages=c</code>（使用C语言）的参数。</p>
<h4>1.2 TagList</h4>
<p>TagList是一款基于CTags的VIM插件，用来显示代码的结构概况。</p>
<p>下载地址：<a href="http://www.vim.org/scripts/script.php?script_id=273" target="_blank"><a href="http://www.vim.org/scripts/script.php?script_id=273">http://www.vim.org/scripts/script.php?script_id=273</a></a></p>
<p>配置方式：在<code>~/.vimrc</code>文件中，增加如下配置：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">let</span> <span class="variable">Tlist_Auto_Open</span> = <span class="number">1</span>
<span class="keyword">let</span> <span class="variable">Tlist_Show_One_File</span> = <span class="number">1</span>
<span class="keyword">let</span> <span class="variable">Tlist_Exit_OnlyWindow</span> = <span class="number">1</span>
</pre></td></tr></table></figure>

<p>其中第一行配置为当发现开启的文件为源代码时，则自动打开TagList，建议打开这个选项，不然每次都都手动执行<code>TlistToggle</code>来开关TagList窗口。</p>
<h4>1.3 CScope</h4>
<p>CScope是一个C语言的浏览工具，可以快速找到函数、变量的定义位置及调用信息。</p>
<p>下载地址：<a href="http://cscope.sourceforge.net" target="_blank"><a href="http://cscope.sourceforge.net">http://cscope.sourceforge.net</a></a></p>
<p>使用方式：在代码的根目录执行下面的命令，即可生成CScope的索引文件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">cscope</span> -Rbkq
</pre></td></tr></table></figure>

<p>其中，<code>-R</code>表示递归建立索引，<code>-b</code>表示不启动CScope的用户界面，<code>-k</code>表示生成索引文件时不搜索<code>/usr/include</code>目录，<code>-q</code>表示生成<code>cscope.in.out</code>和<code>cscope.po.out</code>文件，以加快索引速度。</p>
<h4>1.4 OmniCppComplete</h4>
<p>OmniCppComplete是VIM中对结构体的成员变量、类的属性或方法提供实时提示及补全功能的插件，依赖CTags工具生成的索引文件。</p>
<p>下载地址：<a href="http://www.vim.org/scripts/script.php?script_id=1520" target="_blank"><a href="http://www.vim.org/scripts/script.php?script_id=1520">http://www.vim.org/scripts/script.php?script_id=1520</a></a></p>
<p>配置方式：无需配置，插件安装后即自动生效，在写代码时，输入一个结构体变量的名称后，当继续输入<code>.</code>或<code>-&gt;</code>字符后，会自动弹出该结构体中的所有变量列表，可以上下选择，然后按回车自动补全。</p>
<h4>1.5 SuperTab</h4>
<p>SuperTab可以简化补全代码的方式，直接按<code>TAB</code>键即可（之前需要按<code>CTRL+X</code>和<code>CTRL+O</code>）。</p>
<p>下载地址：<a href="http://www.vim.org/scripts/script.php?script_id=1643" target="_blank"><a href="http://www.vim.org/scripts/script.php?script_id=1643">http://www.vim.org/scripts/script.php?script_id=1643</a></a></p>
<p>配置方式：SuperTab插件是Vimball的安装格式，不需要手动拷贝插件，直接用VIM打开，然后执行<code>:so %</code>即可完成安装。安装后需要在<code>~/.vimrc</code>文件中增加如下配置：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>let g:SuperTabRetainCompletionType=2
let g:SuperTabDefaultCompletionType="<span class="tag">&lt;<span class="title">C-X</span>&gt;</span><span class="tag">&lt;<span class="title">C-O</span>&gt;</span>"
</pre></td></tr></table></figure>

<h4>1.6 MiniBufExplorer</h4>
<p>当需要同时编辑多个文件的时候，MiniBufExplorer可以在VIM顶部以标签形式显示当前打开的文件列表，并可以在各文件间快速切换。</p>
<p>下载地址：<a href="http://www.vim.org/scripts/script.php?script_id=159" target="_blank"><a href="http://www.vim.org/scripts/script.php?script_id=159">http://www.vim.org/scripts/script.php?script_id=159</a></a></p>
<p>配置方式：在<code>~/.vimrc</code>文件中增加如下配置：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">let</span> g:mini<span class="variable">BufExplMapWindowNavVim</span> = <span class="number">1</span> 
<span class="keyword">let</span> g:mini<span class="variable">BufExplMapWindowNavArrows</span> = <span class="number">1</span> 
<span class="keyword">let</span> g:mini<span class="variable">BufExplMapCTabSwitchBufs</span> = <span class="number">1</span> 
<span class="keyword">let</span> g:mini<span class="variable">BufExplModSelTarget</span> = <span class="number">1</span>
</pre></td></tr></table></figure>

<h4>1.7 Command-T</h4>
<p>Command-T用于在VIM快速定位文件，通过<code>:CommandT</code>呼出Command-T窗口，然后直接输入文件名，在输入的过程中文件列表会逐渐缩小范围，并可以通过<code>CTRL+k</code>和<code>CTRL+j</code>上下选择文件，选定后按回车即可打开文件。</p>
<p>下载地址：<a href="http://www.vim.org/scripts/script.php?script_id=3025" target="_blank"><a href="http://www.vim.org/scripts/script.php?script_id=3025">http://www.vim.org/scripts/script.php?script_id=3025</a></a></p>
<p>安装方式：Command-T插件为Vimball安装格式，首先用VIM打开安装文件，执行<code>:so %</code>安装插件，然后执行下面的命令：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="title">cd</span> ~/.vim/ruby/command-t
<span class="title">ruby</span> extconf.rb
<span class="title">make</span>
</pre></td></tr></table></figure>

<p>注：安装需要Ruby开发环境。</p>
<h4>1.8 CtrlP</h4>
<p>CtrlP是另一个快速定位文件的插件，通过<code>:CtrlP</code>呼出查找窗口，用法和Command-T一样，而且支持正则，另外不需要Ruby运行环境，安装起来更方便。</p>
<p>下载地址：<a href="http://www.vim.org/scripts/script.php?script_id=3736" target="_blank"><a href="http://www.vim.org/scripts/script.php?script_id=3736">http://www.vim.org/scripts/script.php?script_id=3736</a></a></p>
<p>配置方式：在<code>~/.vimrc</code>中增加如下配置选项：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>let g:ctrlp_working_path_mode = 'ra'

"" MacOSX/Linux
set wildignore+=*/tmp/*,*.so,*.swp,*.zip

"" Windows
set wildignore+=*<span class="command">\\</span>tmp<span class="command">\\</span>*,*.swp,*.zip,*.exe

let g:ctrlp_custom_ignore = <span class="special">{</span>
  <span class="command">\ </span>'dir':  '<span class="command">\v</span><span class="special">[</span><span class="command">\/</span><span class="special">]</span><span class="command">\.</span>(git|hg|svn)<span class="formula">$',
  <span class="command">\ </span>'file': '<span class="command">\v</span><span class="command">\.</span>(exe|so|dll)$</span>',
  <span class="command">\ </span>'link': 'some_bad_symbolic_links',
  <span class="command">\ </span><span class="special">}</span>
</pre></td></tr></table></figure>

<h4>1.9 A.VIM</h4>
<p>A.VIM是用于<code>.c</code>和<code>.h</code>文件间的快速切换的插件。</p>
<p>下载地址：<a href="http://www.vim.org/scripts/script.php?script_id=31" target="_blank"><a href="http://www.vim.org/scripts/script.php?script_id=31">http://www.vim.org/scripts/script.php?script_id=31</a></a></p>
<p>配置方式：无需配置，插件安装后执行<code>:A</code>即可完成<code>.c</code>和<code>.h</code>文件间的切换。</p>
<h3>2 运行效果</h3>
<p><img src="/images/articles/201311/vim_development_environment.png" alt="VIM开发环境配置效果"></p>
<p>注：图中的效果除了上面的插件配置，还包括了其它对VIM的基本配置，见<a href="/blog/2007/08/19/my-vi-config">《我的VI配置文件》</a>。</p>
]]></content>
    <category scheme="http://hutaow.com/blog/tags/VI/" term="VI"/>
    <category scheme="http://hutaow.com/blog/tags/CTags/" term="CTags"/>
    <category scheme="http://hutaow.com/blog/tags/TagList/" term="TagList"/>
    <category scheme="http://hutaow.com/blog/tags/CScope/" term="CScope"/>
    <category scheme="http://hutaow.com/blog/categories/Linux/" term="Linux"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[在 ArchLinux 中使用 Fcitx 输入法]]></title>
    <link href="http://hutaow.com/blog/2013/11/18/configure-the-fcitx-in-archlinux/"/>
    <id>http://hutaow.com/blog/2013/11/18/configure-the-fcitx-in-archlinux/</id>
    <published>2013-11-18T14:37:16.000Z</published>
    <updated>2013-11-18T16:18:07.000Z</updated>
    <content type="html"><![CDATA[<p>Fcitx是Linux中以轻量箸称的输入法框架，短小精悍且兼容性非常好。简单记录一下Fcitx在ArchLinux中的安装配置方式。</p>
<a id="more"></a>

<h3>安装输入法</h3>
<p>执行下面的命令安装FCITX：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">pacman</span> -S fcitx-im
</pre></td></tr></table></figure>

<h3>配置环境变量</h3>
<p>将下面的环境变量设置加入到显示管理器的配置文件中（KDM、GDM、LightDM的配置文件为<code>~/.xprofile</code>，startx、Slim的配置文件为<code>~/.xinitrc</code>）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">export</span> GTK_IM_MODULE=fcitx
<span class="keyword">export</span> QT_IM_MODULE=fcitx
<span class="keyword">export</span> XMODIFIERS=<span class="string">"@im=fcitx"</span>
</pre></td></tr></table></figure>

<p>配置后重新登录生效，使用<code>CTRL+空格</code>激活输入法，如果发现fcitx没有运行，则直接在命令行里执行<code>fcitx</code>即可。</p>
]]></content>
    <category scheme="http://hutaow.com/blog/tags/Linux/" term="Linux"/>
    <category scheme="http://hutaow.com/blog/tags/ArchLinux/" term="ArchLinux"/>
    <category scheme="http://hutaow.com/blog/tags/Fcitx/" term="Fcitx"/>
    <category scheme="http://hutaow.com/blog/categories/Linux/" term="Linux"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[MySQL协议分析]]></title>
    <link href="http://hutaow.com/blog/2013/11/06/mysql-protocol-analysis/"/>
    <id>http://hutaow.com/blog/2013/11/06/mysql-protocol-analysis/</id>
    <published>2013-11-05T16:34:54.000Z</published>
    <updated>2013-11-22T14:28:42.000Z</updated>
    <content type="html"><![CDATA[<h2>1 交互过程</h2>
<p>MySQL客户端与服务器的交互主要分为两个阶段：握手认证阶段和命令执行阶段。</p>
<h3>1.1 握手认证阶段</h3>
<p>握手认证阶段为客户端与服务器建立连接后进行，交互过程如下：</p>
<ul>
<li>服务器 -&gt; 客户端：握手初始化消息</li>
<li>客户端 -&gt; 服务器：登陆认证消息</li>
<li>服务器 -&gt; 客户端：认证结果消息</li>
</ul>
<h3>1.2 命令执行阶段</h3>
<p>客户端认证成功后，会进入命令执行阶段，交互过程如下：</p>
<ul>
<li>客户端 -&gt; 服务器：执行命令消息</li>
<li>服务器 -&gt; 客户端：命令执行结果</li>
</ul>
<a id="more"></a>

<p><strong>MySQL客户端与服务器的完整交互过程如下</strong>：</p>
<p><img src="/images/articles/201311/mysql_protocol_message.png" alt="MySQL客户端与服务器交互示意图"></p>
<h2>2 基本类型</h2>
<h3>2.1 整型值</h3>
<p>MySQL报文中整型值分别有1、2、3、4、8字节长度，使用小字节序传输。</p>
<h3>2.2 字符串（以NULL结尾）（Null-Terminated String）</h3>
<p>字符串长度不固定，当遇到‘NULL’（0x00）字符时结束。</p>
<h3>2.3 二进制数据（长度编码）（Length Coded Binary）</h3>
<p>数据长度不固定，长度值由数据前的1-9个字节决定，其中长度值所占的字节数不定，字节数由第1个字节决定，如下表：</p>
<table>
<thead>
<tr>
<th>第一个字节值</th>
<th>后续字节数</th>
<th>长度值说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>0-250</td>
<td>0</td>
<td>第一个字节值即为数据的真实长度</td>
</tr>
<tr>
<td>251</td>
<td>0</td>
<td>空数据，数据的真实长度为零</td>
</tr>
<tr>
<td>252</td>
<td>2</td>
<td>后续额外2个字节标识了数据的真实长度</td>
</tr>
<tr>
<td>253</td>
<td>3</td>
<td>后续额外3个字节标识了数据的真实长度</td>
</tr>
<tr>
<td>254</td>
<td>8</td>
<td>后续额外8个字节标识了数据的真实长度</td>
</tr>
</tbody>
</table>
<h3>2.4 字符串（长度编码）（Length Coded String）</h3>
<p>字符串长度不固定，无‘NULL’（0x00）结束符，编码方式与上面的 Length Coded Binary 相同。</p>
<h2>3 报文结构</h2>
<p>报文分为消息头和消息体两部分，其中消息头占用固定的4个字节，消息体长度由消息头中的长度字段决定，报文结构如下：</p>
<!--
    ┏━━━━━━━━━━━━━━━━━━━━━━━━┯━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
    ┃                        │        ┃                                             ┃
    ┃         3 Bytes        │ 1 Byte ┃                   n Bytes                   ┃
    ┃                        │        ┃                                             ┃
    ┗━━━━━━━━━━━━━━━━━━━━━━━━┷━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
    |<-       消息长度     ->|<-序号->|<-                 报文数据                ->|
    |                                 |                                             |
    |<-             消息头          ->|<-                  消息体                 ->|
-->

<p><img src="/images/articles/201311/mysql_protocol_struct.png" alt="MySQL报文结构"></p>
<h3>3.1 消息头</h3>
<h4>3.1.1 报文长度</h4>
<p>用于标记当前请求消息的实际数据长度值，以字节为单位，占用3个字节，最大值为 0xFFFFFF，即接近 16 MB 大小（比16MB少1个字节）。</p>
<h4>3.1.2 序号</h4>
<p>在一次完整的请求/响应交互过程中，用于保证消息顺序的正确，每次客户端发起请求时，序号值都会从0开始计算。</p>
<h3>3.2 消息体</h3>
<p>消息体用于存放请求的内容及响应的数据，长度由消息头中的长度值决定。</p>
<h2>4 报文类型</h2>
<h3>4.1 登陆认证交互报文</h3>
<h4>4.1.1 握手初始化报文（服务器 -&gt; 客户端）</h4>
<!--
    0                                   16                                  32
    ┏━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
    ┃     1 Byte      │          n Bytes (Null-Termimated String)           ┃
    ┃   协议版本号    │                服务器版本信息                       ┃
    ┣━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ┃                                4 Bytes                                ┃
    ┃                              服务器线程ID                             ┃
    ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ┃                                                                       ┃
    ┃                                8 Bytes                                ┃
    ┃                              挑战随机数                               ┃
    ┃                                                                       ┃
    ┣━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━┫
    ┃     1 Byte      │              2 Bytes              │     1 Byte      ┃
    ┃   填充值(0x00)  │           服务器权能标志          │    字符编码     ┃
    ┣━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━┫
    ┃              2 Bytes              ┃              2 Bytes              ┃
    ┃            服务器状态             ┃        服务器权能标志(高16位)     ┃
    ┣━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ┃     1 Byte      │                                                     ┃
    ┃ 挑战长度(未使用)│                                                     ┃
    ┣━━━━━━━━━━━━━━━━━┷┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┫
    ┃                               10 Bytes                                ┃
    ┃                             填充值(0x00)                              ┃
    ┣┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┯━━━━━━━━━━━━━━━━━┫
    ┃                                                     │                 ┃
    ┃                                                     │                 ┃
    ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┷┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┫
    ┃                                                                       ┃
    ┃                                                                       ┃
    ┣┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┫
    ┃                               n Bytes                                 ┃
    ┃                    挑战随机数(第二部分，至少12字节)                   ┃
    ┣┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┯━━━━━━━━━━━━━━━━━┫
    ┃                                                     │     1 Byte      ┃
    ┃                                                     │ 挑战数结束(0x00)┃
    ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━┛
-->

<p><img src="/images/articles/201311/mysql_protocol_handshake.png" alt="MySQL握手初始化报文"></p>
<p><strong>服务协议版本号</strong>：该值由 PROTOCOL_VERSION 宏定义决定（参考MySQL源代码<code>/include/mysql_version.h</code>头文件定义）</p>
<p><strong>服务版本信息</strong>：该值为字符串，由 MYSQL_SERVER_VERSION 宏定义决定（参考MySQL源代码<code>/include/mysql_version.h</code>头文件定义）</p>
<p><strong>服务器线程ID</strong>：服务器为当前连接所创建的线程ID。</p>
<p><strong>挑战随机数</strong>：MySQL数据库用户认证采用的是挑战/应答的方式，服务器生成该挑战数并发送给客户端，由客户端进行处理并返回相应结果，然后服务器检查是否与预期的结果相同，从而完成用户认证的过程。</p>
<p><strong>服务器权能标志</strong>：用于与客户端协商通讯方式，各标志位含义如下（参考MySQL源代码<code>/include/mysql_com.h</code>中的宏定义）：</p>
<table>
<thead>
<tr>
<th>标志位名称</th>
<th>标志位</th>
<th>说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td>CLIENT_LONG_PASSWORD</td>
<td>0x0001</td>
<td>new more secure passwords</td>
</tr>
<tr>
<td>CLIENT_FOUND_ROWS</td>
<td>0x0002</td>
<td>Found instead of affected rows</td>
</tr>
<tr>
<td>CLIENT_LONG_FLAG</td>
<td>0x0004</td>
<td>Get all column flags</td>
</tr>
<tr>
<td>CLIENT_CONNECT_WITH_DB</td>
<td>0x0008</td>
<td>One can specify db on connect</td>
</tr>
<tr>
<td>CLIENT_NO_SCHEMA</td>
<td>0x0010</td>
<td>Do not allow database.table.column</td>
</tr>
<tr>
<td>CLIENT_COMPRESS</td>
<td>0x0020</td>
<td>Can use compression protocol</td>
</tr>
<tr>
<td>CLIENT_ODBC</td>
<td>0x0040</td>
<td>Odbc client</td>
</tr>
<tr>
<td>CLIENT_LOCAL_FILES</td>
<td>0x0080</td>
<td>Can use LOAD DATA LOCAL</td>
</tr>
<tr>
<td>CLIENT_IGNORE_SPACE</td>
<td>0x0100</td>
<td>Ignore spaces before ‘(’</td>
</tr>
<tr>
<td>CLIENT_PROTOCOL_41</td>
<td>0x0200</td>
<td>New 4.1 protocol</td>
</tr>
<tr>
<td>CLIENT_INTERACTIVE</td>
<td>0x0400</td>
<td>This is an interactive client</td>
</tr>
<tr>
<td>CLIENT_SSL</td>
<td>0x0800</td>
<td>Switch to SSL after handshake</td>
</tr>
<tr>
<td>CLIENT_IGNORE_SIGPIPE</td>
<td>0x1000</td>
<td>IGNORE sigpipes</td>
</tr>
<tr>
<td>CLIENT_TRANSACTIONS</td>
<td>0x2000</td>
<td>Client knows about transactions</td>
</tr>
<tr>
<td>CLIENT_RESERVED</td>
<td>0x4000</td>
<td>Old flag for 4.1 protocol </td>
</tr>
<tr>
<td>CLIENT_SECURE_CONNECTION</td>
<td>0x8000</td>
<td>New 4.1 authentication</td>
</tr>
<tr>
<td>CLIENT_MULTI_STATEMENTS</td>
<td>0x0001 0000</td>
<td>Enable/disable multi-stmt support</td>
</tr>
<tr>
<td>CLIENT_MULTI_RESULTS</td>
<td>0x0002 0000</td>
<td>Enable/disable multi-results</td>
</tr>
</tbody>
</table>
<p><strong>字符编码</strong>：标识服务器所使用的字符集。</p>
<p><strong>服务器状态</strong>：状态值定义如下（参考MySQL源代码<code>/include/mysql_com.h</code>中的宏定义）：</p>
<table>
<thead>
<tr>
<th>状态名称</th>
<th>状态值</th>
</tr>
</thead>
<tbody>
<tr>
<td>SERVER_STATUS_IN_TRANS</td>
<td>0x0001</td>
</tr>
<tr>
<td>SERVER_STATUS_AUTOCOMMIT</td>
<td>0x0002</td>
</tr>
<tr>
<td>SERVER_STATUS_CURSOR_EXISTS</td>
<td>0x0040</td>
</tr>
<tr>
<td>SERVER_STATUS_LAST_ROW_SENT</td>
<td>0x0080</td>
</tr>
<tr>
<td>SERVER_STATUS_DB_DROPPED</td>
<td>0x0100</td>
</tr>
<tr>
<td>SERVER_STATUS_NO_BACKSLASH_ESCAPES</td>
<td>0x0200</td>
</tr>
<tr>
<td>SERVER_STATUS_METADATA_CHANGED</td>
<td>0x0400</td>
</tr>
</tbody>
</table>
<h4>4.1.2 登陆认证报文（客户端 -&gt; 服务器）</h4>
<p><strong> MySQL 4.0 及之前的版本</strong></p>
<!--
    0                                   16                                  32
    ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
    ┃              2 Bytes              ┃              3 Bytes              ┋
    ┃           客户端权能标志          ┃           最大消息长度            ┋
    ┣━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ┋                 │                                                     ┃
    ┋                 │                                                     ┃
    ┣━━━━━━━━━━━━━━━━━┷┉┉┉┉┉┉┉┉┉┉┉┉ n Bytes ┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┫
    ┃                     用户名(Null-Terminated String)                    ┃
    ┃                                                                       ┃
    ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ┃                                                                       ┃
    ┃                                                                       ┃
    ┣┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉ 8 Bytes ┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┫
    ┃                   挑战认证数据(Length Coded Binary)                   ┃
    ┃                                                                       ┃
    ┣━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
    ┃      1 Byte     ┃
    ┃  数据结束(0x00) ┃
    ┗━━━━━━━━━━━━━━━━━┛
-->

<p><img src="/images/articles/201311/mysql_protocol_auth_40.png" alt="MySQL登陆认证报文(4.0及之前的版本)"></p>
<p><strong> MySQL 4.1 及之后的版本</strong></p>
<!--
    0                                   16                                  32
    ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
    ┃              2 Bytes              ┃              2 Bytes              ┃
    ┃           客户端权能标志          ┃        客户端权能标志（扩展）     ┃
    ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ┃                                4 Bytes                                ┃
    ┃                             最大消息长度                              ┃
    ┣━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ┃     1 Byte      │                                                     ┃
    ┃    字符编码     │                                                     ┃
    ┣━━━━━━━━━━━━━━━━━┷┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┫
    ┃                                                                       ┃
    ┃                                                                       ┃
    ┣┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┫
    ┃                                                                       ┃
    ┃                                                                       ┃
    ┣┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉ 23 Bytes ┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┫
    ┃                            填充值(0x00)                               ┃
    ┃                                                                       ┃
    ┣┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┫
    ┃                                                                       ┃
    ┃                                                                       ┃
    ┣┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┫
    ┃                                                                       ┃
    ┃                                                                       ┃
    ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ┃                               n Bytes                                 ┃
    ┃                     用户名(Null-Terminated String)                    ┃
    ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ┃                               n Bytes                                 ┃
    ┃                   挑战认证数据(Length Coded Binary)                   ┃
    ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ┃                               n Bytes                                 ┃
    ┃                 数据库名称(Null-Terminated String)(可选)              ┃
    ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
-->

<p><img src="/images/articles/201311/mysql_protocol_auth_41.png" alt="MySQL登陆认证报文(4.1及之后的版本)"></p>
<p><strong>客户端权能标志</strong>：用于与客户端协商通讯方式，标志位含义与握手初始化报文中的相同。客户端收到服务器发来的初始化报文后，会对服务器发送的权能标志进行修改，保留自身所支持的功能，然后将权能标返回给服务器，从而保证服务器与客户端通讯的兼容性。</p>
<p><strong>最大消息长度</strong>：客户端发送请求报文时所支持的最大消息长度值。</p>
<p><strong>字符编码</strong>：标识通讯过程中使用的字符编码，与服务器在认证初始化报文中发送的相同。</p>
<p><strong>用户名</strong>：客户端登陆用户的用户名称。</p>
<p><strong>挑战认证数据</strong>：客户端用户密码使用服务器发送的挑战随机数进行加密后，生成挑战认证数据，然后返回给服务器，用于对用户身份的认证。</p>
<p><strong>数据库名称</strong>：当客户端的权能标志位 CLIENT_CONNECT_WITH_DB 被置位时，该字段必须出现。</p>
<h3>4.2 客户端命令请求报文（客户端 -&gt; 服务器）</h3>
<!--
    ┏━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
    ┃                │                                                              ┃
    ┃     1 Byte     │                         n Bytes                              ┃
    ┃                │                                                              ┃
    ┗━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
    |<-    命令    ->|<-                        参数                              ->|
    |                                                                               |
    |<-                                消息体                                     ->|
-->

<p><img src="/images/articles/201311/mysql_protocol_command.png" alt="MySQL客户端命令请求报文"></p>
<p><strong>命令</strong>：用于标识当前请求消息的类型，例如切换数据库（0x02）、查询命令（0x03）等。命令值的取值范围及说明如下表（参考MySQL源代码<code>/include/mysql_com.h</code>头文件中的定义）：</p>
<table>
<thead>
<tr>
<th>类型值</th>
<th>命令</th>
<th>功能</th>
<th>关联函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>COM_SLEEP</td>
<td>（内部线程状态）</td>
<td>（无）</td>
</tr>
<tr>
<td>0x01</td>
<td>COM_QUIT</td>
<td>关闭连接</td>
<td>mysql_close</td>
</tr>
<tr>
<td>0x02</td>
<td>COM_INIT_DB</td>
<td>切换数据库</td>
<td>mysql_select_db </td>
</tr>
<tr>
<td>0x03</td>
<td>COM_QUERY</td>
<td>SQL查询请求</td>
<td>mysql_real_query</td>
</tr>
<tr>
<td>0x04</td>
<td>COM_FIELD_LIST</td>
<td>获取数据表字段信息</td>
<td>mysql_list_fields</td>
</tr>
<tr>
<td>0x05</td>
<td>COM_CREATE_DB</td>
<td>创建数据库</td>
<td>mysql_create_db</td>
</tr>
<tr>
<td>0x06</td>
<td>COM_DROP_DB</td>
<td>删除数据库</td>
<td>mysql_drop_db</td>
</tr>
<tr>
<td>0x07</td>
<td>COM_REFRESH</td>
<td>清除缓存</td>
<td>mysql_refresh</td>
</tr>
<tr>
<td>0x08</td>
<td>COM_SHUTDOWN</td>
<td>停止服务器</td>
<td>mysql_shutdown</td>
</tr>
<tr>
<td>0x09</td>
<td>COM_STATISTICS</td>
<td>获取服务器统计信息</td>
<td>mysql_stat</td>
</tr>
<tr>
<td>0x0A</td>
<td>COM_PROCESS_INFO</td>
<td>获取当前连接的列表</td>
<td>mysql_list_processes</td>
</tr>
<tr>
<td>0x0B</td>
<td>COM_CONNECT</td>
<td>（内部线程状态）</td>
<td>（无）</td>
</tr>
<tr>
<td>0x0C</td>
<td>COM_PROCESS_KILL</td>
<td>中断某个连接</td>
<td>mysql_kill</td>
</tr>
<tr>
<td>0x0D</td>
<td>COM_DEBUG</td>
<td>保存服务器调试信息</td>
<td>mysql_dump_debug_info</td>
</tr>
<tr>
<td>0x0E</td>
<td>COM_PING</td>
<td>测试连通性</td>
<td>mysql_ping</td>
</tr>
<tr>
<td>0x0F</td>
<td>COM_TIME</td>
<td>（内部线程状态）</td>
<td>（无）</td>
</tr>
<tr>
<td>0x10</td>
<td>COM_DELAYED_INSERT</td>
<td>（内部线程状态）</td>
<td>（无）</td>
</tr>
<tr>
<td>0x11</td>
<td>COM_CHANGE_USER</td>
<td>重新登陆（不断连接）</td>
<td>mysql_change_user</td>
</tr>
<tr>
<td>0x12</td>
<td>COM_BINLOG_DUMP</td>
<td>获取二进制日志信息</td>
<td>（无）</td>
</tr>
<tr>
<td>0x13</td>
<td>COM_TABLE_DUMP</td>
<td>获取数据表结构信息</td>
<td>（无）</td>
</tr>
<tr>
<td>0x14</td>
<td>COM_CONNECT_OUT</td>
<td>（内部线程状态）</td>
<td>（无）</td>
</tr>
<tr>
<td>0x15</td>
<td>COM_REGISTER_SLAVE</td>
<td>从服务器向主服务器进行注册</td>
<td>（无）</td>
</tr>
<tr>
<td>0x16</td>
<td>COM_STMT_PREPARE</td>
<td>预处理SQL语句</td>
<td>mysql_stmt_prepare</td>
</tr>
<tr>
<td>0x17</td>
<td>COM_STMT_EXECUTE</td>
<td>执行预处理语句</td>
<td>mysql_stmt_execute</td>
</tr>
<tr>
<td>0x18</td>
<td>COM_STMT_SEND_LONG_DATA</td>
<td>发送BLOB类型的数据</td>
<td>mysql_stmt_send_long_data</td>
</tr>
<tr>
<td>0x19</td>
<td>COM_STMT_CLOSE</td>
<td>销毁预处理语句</td>
<td>mysql_stmt_close</td>
</tr>
<tr>
<td>0x1A</td>
<td>COM_STMT_RESET</td>
<td>清除预处理语句参数缓存</td>
<td>mysql_stmt_reset</td>
</tr>
<tr>
<td>0x1B</td>
<td>COM_SET_OPTION</td>
<td>设置语句选项</td>
<td>mysql_set_server_option</td>
</tr>
<tr>
<td>0x1C</td>
<td>COM_STMT_FETCH</td>
<td>获取预处理语句的执行结果</td>
<td>mysql_stmt_fetch</td>
</tr>
</tbody>
</table>
<p><strong>参数</strong>：内容是用户在MySQL客户端输入的命令（不包括每行命令结尾的“;”分号）。另外这个字段的字符串不是以NULL字符结尾，而是通过消息头中的长度值计算而来。</p>
<p>例如：当我们在MySQL客户端中执行<code>use hutaow;</code>命令时（切换到<code>hutaow</code>数据库），发送的请求报文数据会是下面的样子：</p>
<pre><code>0x02 0x68 0x75 0x74 0x61 0x6f 0x77</code></pre>
<p>其中，<code>0x02</code>为请求类型值<code>COM_INIT_DB</code>，后面的<code>0x68 0x75 0x74 0x61 0x6f 0x77</code>为ASCII字符<code>hutaow</code>。</p>
<h4>4.2.1 COM_QUIT 消息报文</h4>
<p><strong>功能</strong>：关闭当前连接（客户端退出），无参数。</p>
<h4>4.2.2 COM_INIT_DB 消息报文</h4>
<p><strong>功能</strong>：切换数据库，对应的SQL语句为<code>USE &lt;database&gt;</code>。</p>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>n</td>
<td>数据库名称（字符串到达消息尾部时结束，无结束符）</td>
</tr>
</tbody>
</table>
<h4>4.2.3 COM_QUERY 消息报文</h4>
<p><strong>功能</strong>：最常见的请求消息类型，当用户执行SQL语句时发送该消息。</p>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>n</td>
<td>SQL语句（字符串到达消息尾部时结束，无结束符）</td>
</tr>
</tbody>
</table>
<h4>4.2.4 COM_FIELD_LIST 消息报文</h4>
<p><strong>功能</strong>：查询某表的字段（列）信息，等同于SQL语句<code>SHOW [FULL] FIELDS FROM ...</code>。</p>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>n</td>
<td>表格名称（Null-Terminated String）</td>
</tr>
<tr>
<td>n</td>
<td>字段（列）名称或通配符（可选）</td>
</tr>
</tbody>
</table>
<h4>4.2.5 COM_CREATE_DB 消息报文</h4>
<p><strong>功能</strong>：创建数据库，该消息已过时，而被SQL语句<code>CREATE DATABASE</code>代替。</p>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>n</td>
<td>数据库名称（字符串到达消息尾部时结束，无结束符）</td>
</tr>
</tbody>
</table>
<h4>4.2.6 COM_DROP_DB 消息报文</h4>
<p><strong>功能</strong>：删除数据库，该消息已过时，而被SQL语句<code>DROP DATABASE</code>代替。</p>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>n</td>
<td>数据库名称（字符串到达消息尾部时结束，无结束符）</td>
</tr>
</tbody>
</table>
<h4>4.2.7 COM_REFRESH 消息报文</h4>
<p><strong>功能</strong>：清除缓存，等同于SQL语句<code>FLUSH</code>，或是执行<code>mysqladmin flush-foo</code>命令时发送该消息。</p>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>清除缓存选项（位图方式存储，各标志位含义如下）</td>
</tr>
<tr>
<td></td>
<td>0x01: REFRESH_GRANT</td>
</tr>
<tr>
<td></td>
<td>0x02: REFRESH_LOG</td>
</tr>
<tr>
<td></td>
<td>0x04: REFRESH_TABLES</td>
</tr>
<tr>
<td></td>
<td>0x08: REFRESH_HOSTS</td>
</tr>
<tr>
<td></td>
<td>0x10: REFRESH_STATUS</td>
</tr>
<tr>
<td></td>
<td>0x20: REFRESH_THREADS</td>
</tr>
<tr>
<td></td>
<td>0x40: REFRESH_SLAVE</td>
</tr>
<tr>
<td></td>
<td>0x80: REFRESH_MASTER</td>
</tr>
</tbody>
</table>
<h4>4.2.8 COM_SHUTDOWN 消息报文</h4>
<p><strong>功能</strong>：停止MySQL服务。执行<code>mysqladmin shutdown</code>命令时发送该消息。</p>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>停止服务选项</td>
</tr>
<tr>
<td></td>
<td>0x00: SHUTDOWN_DEFAULT</td>
</tr>
<tr>
<td></td>
<td>0x01: SHUTDOWN_WAIT_CONNECTIONS</td>
</tr>
<tr>
<td></td>
<td>0x02: SHUTDOWN_WAIT_TRANSACTIONS</td>
</tr>
<tr>
<td></td>
<td>0x08: SHUTDOWN_WAIT_UPDATES</td>
</tr>
<tr>
<td></td>
<td>0x10: SHUTDOWN_WAIT_ALL_BUFFERS</td>
</tr>
<tr>
<td></td>
<td>0x11: SHUTDOWN_WAIT_CRITICAL_BUFFERS</td>
</tr>
<tr>
<td></td>
<td>0xFE: KILL_QUERY</td>
</tr>
<tr>
<td></td>
<td>0xFF: KILL_CONNECTION</td>
</tr>
</tbody>
</table>
<h4>4.2.9 COM_STATISTICS 消息报文</h4>
<p><strong>功能</strong>：查看MySQL服务的统计信息（例如运行时间、每秒查询次数等）。执行<code>mysqladmin status</code>命令时发送该消息，无参数。</p>
<h4>4.2.10 COM_PROCESS_INFO 消息报文</h4>
<p><strong>功能</strong>：获取当前活动的线程（连接）列表。等同于SQL语句<code>SHOW PROCESSLIST</code>，或是执行<code>mysqladmin processlist</code>命令时发送该消息，无参数。</p>
<h4>4.2.11 COM_PROCESS_KILL 消息报文</h4>
<p><strong>功能</strong>：要求服务器中断某个连接。等同于SQL语句<code>KILL &lt;id&gt;</code>。</p>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>连接ID号（小字节序）</td>
</tr>
</tbody>
</table>
<h4>4.2.12 COM_DEBUG 消息报文</h4>
<p><strong>功能</strong>：要求服务器将调试信息保存下来，保存的信息多少依赖于编译选项设置（debug=no|yes|full）。执行<code>mysqladmin debug</code>命令时发送该消息，无参数。</p>
<h4>4.2.13 COM_PING 消息报文</h4>
<p><strong>功能</strong>：该消息用来测试连通性，同时会将服务器的无效连接（超时）计数器清零。执行<code>mysqladmin ping</code>命令时发送该消息，无参数。</p>
<h4>4.2.14 COM_CHANGE_USER 消息报文</h4>
<p><strong>功能</strong>：在不断连接的情况下重新登陆，该操作会销毁MySQL服务器端的会话上下文（包括临时表、会话变量等）。有些连接池用这种方法实现清除会话上下文。</p>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>n</td>
<td>用户名（字符串以NULL结尾）</td>
</tr>
<tr>
<td>n</td>
<td>密码（挑战数）</td>
</tr>
<tr>
<td></td>
<td>MySQL 3.23 版本：Null-Terminated String（长度9字节）</td>
</tr>
<tr>
<td></td>
<td>MySQL 4.1 版本：Length Coded String（长度1+21字节）</td>
</tr>
<tr>
<td>n</td>
<td>数据库名称（Null-Terminated String）</td>
</tr>
<tr>
<td>2</td>
<td>字符编码</td>
</tr>
</tbody>
</table>
<h4>4.2.15 COM_BINLOG_DUMP 消息报文</h4>
<p><strong>功能</strong>：该消息是备份连接时由从服务器向主服务器发送的最后一个请求，主服务器收到后，会响应一系列的报文，每个报文都包含一个二进制日志事件。如果主服务器出现故障时，会发送一个EOF报文。</p>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>二进制日志数据的起始位置（小字节序）</td>
</tr>
<tr>
<td>4</td>
<td>二进制日志数据标志位（目前未使用，永远为0x00）</td>
</tr>
<tr>
<td>4</td>
<td>从服务器的服务器ID值（小字节序）</td>
</tr>
<tr>
<td>n</td>
<td>二进制日志的文件名称（可选，默认值为主服务器上第一个有效的文件名）</td>
</tr>
</tbody>
</table>
<h4>4.2.16 COM_TABLE_DUMP 消息报文</h4>
<p><strong>功能</strong>：将数据表从主服务器复制到从服务器中，执行SQL语句<code>LOAD TABLE ... FROM MASTER</code>时发送该消息。目前该消息已过时，不再使用。</p>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>n</td>
<td>数据库名称（Length Coded String）</td>
</tr>
<tr>
<td>n</td>
<td>数据表名称（Length Coded String）</td>
</tr>
</tbody>
</table>
<h4>4.2.17 COM_REGISTER_SLAVE 消息报文</h4>
<p><strong>功能</strong>：在从服务器<code>report_host</code>变量设置的情况下，当备份连接时向主服务器发送的注册消息。</p>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>从服务器ID值（小字节序）</td>
</tr>
<tr>
<td>n</td>
<td>主服务器IP地址（Length Coded String）</td>
</tr>
<tr>
<td>n</td>
<td>主服务器用户名（Length Coded String）</td>
</tr>
<tr>
<td>n</td>
<td>主服务器密码（Length Coded String）</td>
</tr>
<tr>
<td>2</td>
<td>主服务器端口号</td>
</tr>
<tr>
<td>4</td>
<td>安全备份级别（由MySQL服务器<code>rpl_recovery_rank</code>变量设置，暂时未使用）</td>
</tr>
<tr>
<td>4</td>
<td>主服务器ID值（值恒为0x00）</td>
</tr>
</tbody>
</table>
<h4>4.2.18 COM_PREPARE 消息报文</h4>
<p><strong>功能</strong>：预处理SQL语句，使用带有“?”占位符的SQL语句时发送该消息。</p>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>n</td>
<td>带有“?”占位符的SQL语句（字符串到达消息尾部时结束，无结束符）</td>
</tr>
</tbody>
</table>
<h4>4.2.19 COM_EXECUTE 消息报文</h4>
<p><strong>功能</strong>：执行预处理语句。</p>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>预处理语句的ID值</td>
</tr>
<tr>
<td>1</td>
<td>标志位</td>
</tr>
<tr>
<td></td>
<td>0x00: CURSOR_TYPE_NO_CURSOR</td>
</tr>
<tr>
<td></td>
<td>0x01: CURSOR_TYPE_READ_ONLY</td>
</tr>
<tr>
<td></td>
<td>0x02: CURSOR_TYPE_FOR_UPDATE</td>
</tr>
<tr>
<td></td>
<td>0x04: CURSOR_TYPE_SCROLLABLE</td>
</tr>
<tr>
<td>4</td>
<td>保留（值恒为0x01）</td>
</tr>
<tr>
<td>如果参数数量大于0</td>
<td></td>
</tr>
<tr>
<td>n</td>
<td>空位图（Null-Bitmap，长度 = (参数数量 + 7) / 8 字节）</td>
</tr>
<tr>
<td>1</td>
<td>参数分隔标志</td>
</tr>
<tr>
<td>如果参数分隔标志值为1</td>
<td></td>
</tr>
<tr>
<td>n</td>
<td>每个参数的类型值（长度 = 参数数量 * 2 字节）</td>
</tr>
<tr>
<td>n</td>
<td>每个参数的值</td>
</tr>
</tbody>
</table>
<h4>4.2.20 COM_LONG_DATA 消息报文</h4>
<p>该消息报文有两种形式，一种用于发送二进制数据，另一种用于发送文本数据。</p>
<p><strong>功能</strong>：用于发送二进制（BLOB）类型的数据（调用<code>mysql_stmt_send_long_data</code>函数）。</p>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>预处理语句的ID值（小字节序）</td>
</tr>
<tr>
<td>2</td>
<td>参数序号（小字节序）</td>
</tr>
<tr>
<td>n</td>
<td>数据负载（数据到达消息尾部时结束，无结束符）</td>
</tr>
</tbody>
</table>
<p><strong>功能</strong>：用于发送超长字符串类型的数据（调用<code>mysql_send_long_data</code>函数）</p>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>预处理语句的ID值（小字节序）</td>
</tr>
<tr>
<td>2</td>
<td>参数序号（小字节序）</td>
</tr>
<tr>
<td>2</td>
<td>数据类型（未使用）</td>
</tr>
<tr>
<td>n</td>
<td>数据负载（数据到达消息尾部时结束，无结束符）</td>
</tr>
</tbody>
</table>
<h4>4.2.21 COM_CLOSE_STMT 消息报文</h4>
<p><strong>功能</strong>：销毁预处理语句。</p>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>预处理语句的ID值（小字节序）</td>
</tr>
</tbody>
</table>
<h4>4.2.22 COM_RESET_STMT 消息报文</h4>
<p><strong>功能</strong>：将预处理语句的参数缓存清空。多数情况和<code>COM_LONG_DATA</code>一起使用。</p>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>预处理语句的ID值（小字节序）</td>
</tr>
</tbody>
</table>
<h4>4.2.23 COM_SET_OPTION 消息报文</h4>
<p><strong>功能</strong>：设置语句选项，选项值为<code>/include/mysql_com.h</code>头文件中定义的<code>enum_mysql_set_option</code>枚举类型：</p>
<ul>
<li>MYSQL_OPTION_MULTI_STATEMENTS_ON</li>
<li>MYSQL_OPTION_MULTI_STATEMENTS_OFF</li>
</ul>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>选项值（小字节序）</td>
</tr>
</tbody>
</table>
<h4>4.2.24 COM_FETCH_STMT 消息报文</h4>
<p><strong>功能</strong>：获取预处理语句的执行结果（一次可以获取多行数据）。</p>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>预处理语句的ID值（小字节序）</td>
</tr>
<tr>
<td>4</td>
<td>数据的行数（小字节序）</td>
</tr>
</tbody>
</table>
<h3>4.3 服务器响应报文（服务器 -&gt; 客户端）</h3>
<p>当客户端发起认证请求或命令请求后，服务器会返回相应的执行结果给客户端。客户端在收到响应报文后，需要首先检查第1个字节的值，来区分响应报文的类型。</p>
<table>
<thead>
<tr>
<th>响应报文类型</th>
<th>第1个字节取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>OK 响应报文</td>
<td>0x00</td>
</tr>
<tr>
<td>Error 响应报文</td>
<td>0xFF</td>
</tr>
<tr>
<td>Result Set 报文</td>
<td>0x01 - 0xFA</td>
</tr>
<tr>
<td>Field 报文</td>
<td>0x01 - 0xFA</td>
</tr>
<tr>
<td>Row Data 报文</td>
<td>0x01 - 0xFA</td>
</tr>
<tr>
<td>EOF 报文</td>
<td>0xFE</td>
</tr>
</tbody>
</table>
<p>注：响应报文的第1个字节在不同类型中含义不同，比如在OK报文中，该字节并没有实际意义，值恒为0x00；而在Result Set报文中，该字节又是长度编码的二进制数据结构（Length Coded Binary）中的第1字节。</p>
<h4>4.3.1 OK 响应报文</h4>
<p>客户端的命令执行正确时，服务器会返回OK响应报文。</p>
<p><strong> MySQL 4.0 及之前的版本</strong></p>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>OK报文，值恒为0x00</td>
</tr>
<tr>
<td>1-9</td>
<td>受影响行数（Length Coded Binary）</td>
</tr>
<tr>
<td>1-9</td>
<td>索引ID值（Length Coded Binary）</td>
</tr>
<tr>
<td>2</td>
<td>服务器状态</td>
</tr>
<tr>
<td>n</td>
<td>服务器消息（字符串到达消息尾部时结束，无结束符）</td>
</tr>
</tbody>
</table>
<p><strong> MySQL 4.1 及之后的版本</strong></p>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>OK报文，值恒为0x00</td>
</tr>
<tr>
<td>1-9</td>
<td>受影响行数（Length Coded Binary）</td>
</tr>
<tr>
<td>1-9</td>
<td>索引ID值（Length Coded Binary）</td>
</tr>
<tr>
<td>2</td>
<td>服务器状态</td>
</tr>
<tr>
<td>2</td>
<td>告警计数</td>
</tr>
<tr>
<td>n</td>
<td>服务器消息（字符串到达消息尾部时结束，无结束符，可选）</td>
</tr>
</tbody>
</table>
<p><strong>受影响行数</strong>：当执行<code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code>语句时所影响的数据行数。</p>
<p><strong>索引ID值</strong>：该值为<code>AUTO_INCREMENT</code>索引字段生成，如果没有索引字段，则为0x00。注意：当<code>INSERT</code>插入语句为多行数据时，该索引ID值为第一个插入的数据行索引值，而非最后一个。</p>
<p><strong>服务器状态</strong>：客户端可以通过该值检查命令是否在事务处理中。</p>
<p><strong>告警计数</strong>：告警发生的次数。</p>
<p><strong>服务器消息</strong>：服务器返回给客户端的消息，一般为简单的描述性字符串，可选字段。</p>
<h4>4.3.2 Error 响应报文</h4>
<p><strong> MySQL 4.0 及之前的版本</strong></p>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Error报文，值恒为0xFF</td>
</tr>
<tr>
<td>2</td>
<td>错误编号（小字节序）</td>
</tr>
<tr>
<td>n</td>
<td>服务器消息</td>
</tr>
</tbody>
</table>
<p><strong> MySQL 4.1 及之后的版本</strong></p>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Error报文，值恒为0xFF</td>
</tr>
<tr>
<td>2</td>
<td>错误编号（小字节序）</td>
</tr>
<tr>
<td>1</td>
<td>服务器状态标志，恒为‘#’字符</td>
</tr>
<tr>
<td>5</td>
<td>服务器状态（5个字符）</td>
</tr>
<tr>
<td>n</td>
<td>服务器消息</td>
</tr>
</tbody>
</table>
<p><strong>错误编号</strong>：错误编号值定义在源代码<code>/include/mysqld_error.h</code>头文件中。</p>
<p><strong>服务器状态</strong>：服务器将错误编号通过<code>mysql_errno_to_sqlstate</code>函数转换为状态值，状态值由5字节的ASCII字符组成，定义在源代码<code>/include/sql_state.h</code>头文件中。</p>
<p><strong>服务器消息</strong>：错误消息字符串到达消息尾时结束，长度可以由消息头中的长度值计算得出。消息长度为0-512字节。</p>
<h4>4.3.3 Result Set 消息</h4>
<p>当客户端发送查询请求后，在没有错误的情况下，服务器会返回结果集（Result Set）给客户端。</p>
<p>Result Set 消息分为五部分，结构如下：</p>
<table>
<thead>
<tr>
<th>结构</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>[Result Set Header]</td>
<td>列数量</td>
</tr>
<tr>
<td>[Field]</td>
<td>列信息（多个）</td>
</tr>
<tr>
<td>[EOF]</td>
<td>列结束</td>
</tr>
<tr>
<td>[Row Data]</td>
<td>行数据（多个）</td>
</tr>
<tr>
<td>[EOF]</td>
<td>数据结束</td>
</tr>
</tbody>
</table>
<h4>4.3.4 Result Set Header 结构</h4>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1-9</td>
<td>Field结构计数（Length Coded Binary）</td>
</tr>
<tr>
<td>1-9</td>
<td>额外信息（Length Coded Binary）</td>
</tr>
</tbody>
</table>
<p><strong>Field结构计数</strong>：用于标识Field结构的数量，取值范围0x00-0xFA。</p>
<p><strong>额外信息</strong>：可选字段，一般情况下不应该出现。只有像<code>SHOW COLUMNS</code>这种语句的执行结果才会用到额外信息（标识表格的列数量）。</p>
<h4>4.3.5 Field 结构</h4>
<p>Field为数据表的列信息，在Result Set中，Field会连续出现多次，次数由Result Set Header结构中的IField结构计数值决定。</p>
<p><strong> MySQL 4.0 及之前的版本</strong></p>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>n</td>
<td>数据表名称（Length Coded String）</td>
</tr>
<tr>
<td>n</td>
<td>列（字段）名称（Length Coded String）</td>
</tr>
<tr>
<td>4</td>
<td>列（字段）长度（Length Coded String）</td>
</tr>
<tr>
<td>2</td>
<td>列（字段）类型（Length Coded String）</td>
</tr>
<tr>
<td>2</td>
<td>列（字段）标志（Length Coded String）</td>
</tr>
<tr>
<td>1</td>
<td>整型值精度</td>
</tr>
<tr>
<td>n</td>
<td>默认值（Length Coded String）</td>
</tr>
</tbody>
</table>
<p><strong> MySQL 4.1 及之后的版本</strong></p>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>n</td>
<td>目录名称（Length Coded String）</td>
</tr>
<tr>
<td>n</td>
<td>数据库名称（Length Coded String）</td>
</tr>
<tr>
<td>n</td>
<td>数据表名称（Length Coded String）</td>
</tr>
<tr>
<td>n</td>
<td>数据表原始名称（Length Coded String）</td>
</tr>
<tr>
<td>n</td>
<td>列（字段）名称（Length Coded String）</td>
</tr>
<tr>
<td>4</td>
<td>列（字段）原始名称（Length Coded String）</td>
</tr>
<tr>
<td>1</td>
<td>填充值</td>
</tr>
<tr>
<td>2</td>
<td>字符编码</td>
</tr>
<tr>
<td>4</td>
<td>列（字段）长度</td>
</tr>
<tr>
<td>1</td>
<td>列（字段）类型</td>
</tr>
<tr>
<td>2</td>
<td>列（字段）标志</td>
</tr>
<tr>
<td>1</td>
<td>整型值精度</td>
</tr>
<tr>
<td>2</td>
<td>填充值（0x00）</td>
</tr>
<tr>
<td>n</td>
<td>默认值（Length Coded String）</td>
</tr>
</tbody>
</table>
<p><strong>目录名称</strong>：在4.1及之后的版本中，该字段值为“def”。</p>
<p><strong>数据库名称</strong>：数据库名称标识。</p>
<p><strong>数据表名称</strong>：数据表的别名（<code>AS</code>之后的名称）。</p>
<p><strong>数据表原始名称</strong>：数据表的原始名称（<code>AS</code>之前的名称）。</p>
<p><strong>列（字段）名称</strong>：列（字段）的别名（<code>AS</code>之后的名称）。</p>
<p><strong>列（字段）原始名称</strong>：列（字段）的原始名称（<code>AS</code>之前的名称）。</p>
<p><strong>字符编码</strong>：列（字段）的字符编码值。</p>
<p><strong>列（字段）长度</strong>：列（字段）的长度值，真实长度可能小于该值，例如<code>VARCHAR(2)</code>类型的字段实际只能存储1个字符。</p>
<p><strong>列（字段）类型</strong>：列（字段）的类型值，取值范围如下（参考源代码<code>/include/mysql_com.h</code>头文件中的<code>enum_field_type</code>枚举类型定义）：</p>
<table>
<thead>
<tr>
<th>类型值</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>FIELD_TYPE_DECIMAL</td>
</tr>
<tr>
<td>0x01</td>
<td>FIELD_TYPE_TINY</td>
</tr>
<tr>
<td>0x02</td>
<td>FIELD_TYPE_SHORT</td>
</tr>
<tr>
<td>0x03</td>
<td>FIELD_TYPE_LONG</td>
</tr>
<tr>
<td>0x04</td>
<td>FIELD_TYPE_FLOAT</td>
</tr>
<tr>
<td>0x05</td>
<td>FIELD_TYPE_DOUBLE</td>
</tr>
<tr>
<td>0x06</td>
<td>FIELD_TYPE_NULL</td>
</tr>
<tr>
<td>0x07</td>
<td>FIELD_TYPE_TIMESTAMP</td>
</tr>
<tr>
<td>0x08</td>
<td>FIELD_TYPE_LONGLONG</td>
</tr>
<tr>
<td>0x09</td>
<td>FIELD_TYPE_INT24</td>
</tr>
<tr>
<td>0x0A</td>
<td>FIELD_TYPE_DATE</td>
</tr>
<tr>
<td>0x0B</td>
<td>FIELD_TYPE_TIME</td>
</tr>
<tr>
<td>0x0C</td>
<td>FIELD_TYPE_DATETIME</td>
</tr>
<tr>
<td>0x0D</td>
<td>FIELD_TYPE_YEAR</td>
</tr>
<tr>
<td>0x0E</td>
<td>FIELD_TYPE_NEWDATE</td>
</tr>
<tr>
<td>0x0F</td>
<td>FIELD_TYPE_VARCHAR (new in MySQL 5.0)</td>
</tr>
<tr>
<td>0x10</td>
<td>FIELD_TYPE_BIT (new in MySQL 5.0)</td>
</tr>
<tr>
<td>0xF6</td>
<td>FIELD_TYPE_NEWDECIMAL (new in MYSQL 5.0)</td>
</tr>
<tr>
<td>0xF7</td>
<td>FIELD_TYPE_ENUM</td>
</tr>
<tr>
<td>0xF8</td>
<td>FIELD_TYPE_SET</td>
</tr>
<tr>
<td>0xF9</td>
<td>FIELD_TYPE_TINY_BLOB</td>
</tr>
<tr>
<td>0xFA</td>
<td>FIELD_TYPE_MEDIUM_BLOB</td>
</tr>
<tr>
<td>0xFB</td>
<td>FIELD_TYPE_LONG_BLOB</td>
</tr>
<tr>
<td>0xFC</td>
<td>FIELD_TYPE_BLOB</td>
</tr>
<tr>
<td>0xFD</td>
<td>FIELD_TYPE_VAR_STRING</td>
</tr>
<tr>
<td>0xFE</td>
<td>FIELD_TYPE_STRING</td>
</tr>
<tr>
<td>0xFF</td>
<td>FIELD_TYPE_GEOMETRY</td>
</tr>
</tbody>
</table>
<p><strong>列（字段）标志</strong>：各标志位定义如下（参考源代码<code>/include/mysql_com.h</code>头文件中的宏定义）：</p>
<table>
<thead>
<tr>
<th>标志位</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x0001</td>
<td>NOT_NULL_FLAG</td>
</tr>
<tr>
<td>0x0002</td>
<td>PRI_KEY_FLAG</td>
</tr>
<tr>
<td>0x0004</td>
<td>UNIQUE_KEY_FLAG</td>
</tr>
<tr>
<td>0x0008</td>
<td>MULTIPLE_KEY_FLAG</td>
</tr>
<tr>
<td>0x0010</td>
<td>BLOB_FLAG</td>
</tr>
<tr>
<td>0x0020</td>
<td>UNSIGNED_FLAG</td>
</tr>
<tr>
<td>0x0040</td>
<td>ZEROFILL_FLAG</td>
</tr>
<tr>
<td>0x0080</td>
<td>BINARY_FLAG</td>
</tr>
<tr>
<td>0x0100</td>
<td>ENUM_FLAG</td>
</tr>
<tr>
<td>0x0200</td>
<td>AUTO_INCREMENT_FLAG</td>
</tr>
<tr>
<td>0x0400</td>
<td>TIMESTAMP_FLAG</td>
</tr>
<tr>
<td>0x0800</td>
<td>SET_FLAG</td>
</tr>
</tbody>
</table>
<p><strong>数值精度</strong>：该字段对<code>DECIMAL</code>和<code>NUMERIC</code>类型的数值字段有效，用于标识数值的精度（小数点位置）。</p>
<p><strong>默认值</strong>：该字段用在数据表定义中，普通的查询结果中不会出现。</p>
<p><strong>附</strong>：Field结构的相关处理函数：</p>
<ul>
<li>客户端：<code>/client/client.c</code>源文件中的<code>unpack_fields</code>函数</li>
<li>服务器：<code>/sql/sql_base.cc</code>源文件中的<code>send_fields</code>函数</li>
</ul>
<h4>4.3.6 EOF 结构</h4>
<p>EOF结构用于标识Field和Row Data的结束，在预处理语句中，EOF也被用来标识参数的结束。</p>
<p><strong> MySQL 4.0 及之前的版本</strong></p>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>EOF值（0xFE）</td>
</tr>
</tbody>
</table>
<p><strong> MySQL 4.1 及之后的版本</strong></p>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>EOF值（0xFE）</td>
</tr>
<tr>
<td>2</td>
<td>告警计数</td>
</tr>
<tr>
<td>2</td>
<td>状态标志位</td>
</tr>
</tbody>
</table>
<p><strong>告警计数</strong>：服务器告警数量，在所有数据都发送给客户端后该值才有效。</p>
<p><strong>状态标志位</strong>：包含类似<code>SERVER_MORE_RESULTS_EXISTS</code>这样的标志位。</p>
<p><strong>注</strong>：由于EOF值与其它Result Set结构共用1字节，所以在收到报文后需要对EOF包的真实性进行校验，校验条件为：</p>
<ul>
<li>第1字节值为0xFE</li>
<li>包长度小于9字节</li>
</ul>
<p><strong>附</strong>：EOF结构的相关处理函数：</p>
<ul>
<li>服务器：<code>protocol.cc</code>源文件中的<code>send_eof</code>函数</li>
</ul>
<h4>4.3.7 Row Data 结构</h4>
<p>在Result Set消息中，会包含多个Row Data结构，每个Row Data结构又包含多个字段值，这些字段值组成一行数据。</p>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>n</td>
<td>字段值（Length Coded String）</td>
</tr>
<tr>
<td>…</td>
<td>（一行数据中包含多个字段值）</td>
</tr>
</tbody>
</table>
<p><strong>字段值</strong>：行数据中的字段值，字符串形式。</p>
<p><strong>附</strong>：Row Data结构的相关处理函数：</p>
<ul>
<li>客户端：<code>/client/client.c</code>源文件中的<code>read_rows</code>函数</li>
</ul>
<h4>4.3.8 Row Data 结构（二进制数据）</h4>
<p>该结构用于传输二进制的字段值，既可以是服务器返回的结果，也可以是由客户端发送的（当执行预处理语句时，客户端使用Result Set消息来发送参数及数据）。</p>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>结构头（0x00）</td>
</tr>
<tr>
<td>(列数量 + 7 + 2) / 8</td>
<td>空位图</td>
</tr>
<tr>
<td>n</td>
<td>字段值</td>
</tr>
<tr>
<td>…</td>
<td>（一行数据中包含多个字段值）</td>
</tr>
</tbody>
</table>
<p><strong>空位图</strong>：前2个比特位被保留，值分别为0和1，以保证不会和OK、Error包的首字节冲突。在MySQL 5.0及之后的版本中，这2个比特位的值都为0。</p>
<p><strong>字段值</strong>：行数据中的字段值，二进制形式。</p>
<h4>4.3.9 PREPARE_OK 响应报文（Prepared Statement）</h4>
<p>用于响应客户端发起的预处理语句报文，组成结构如下：</p>
<table>
<thead>
<tr>
<th>结构</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>[PREPARE_OK]</td>
<td>PREPARE_OK结构</td>
</tr>
<tr>
<td>如果参数数量大于0</td>
<td></td>
</tr>
<tr>
<td>[Field]</td>
<td>与Result Set消息结构相同</td>
</tr>
<tr>
<td>[EOF]</td>
<td></td>
</tr>
<tr>
<td>如果列数大于0</td>
<td></td>
</tr>
<tr>
<td>[Field]</td>
<td>与Result Set消息结构相同</td>
</tr>
<tr>
<td>[EOF]</td>
<td></td>
</tr>
</tbody>
</table>
<p>其中 PREPARD_OK 的结构如下：</p>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>OK报文，值为0x00</td>
</tr>
<tr>
<td>4</td>
<td>预处理语句ID值</td>
</tr>
<tr>
<td>2</td>
<td>列数量</td>
</tr>
<tr>
<td>2</td>
<td>参数数量</td>
</tr>
<tr>
<td>1</td>
<td>填充值（0x00）</td>
</tr>
<tr>
<td>2</td>
<td>告警计数</td>
</tr>
</tbody>
</table>
<h4>4.3.10 Parameter 响应报文（Prepared Statement）</h4>
<p>预处理语句的值与参数正确对应后，服务器会返回 Parameter 报文。</p>
<table>
<thead>
<tr>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>类型</td>
</tr>
<tr>
<td>2</td>
<td>标志</td>
</tr>
<tr>
<td>1</td>
<td>数值精度</td>
</tr>
<tr>
<td>4</td>
<td>字段长度</td>
</tr>
</tbody>
</table>
<p><strong>类型</strong>：与 Field 结构中的字段类型相同。</p>
<p><strong>标志</strong>：与 Field 结构中的字段标志相同。</p>
<p><strong>数值精度</strong>：与 Field 结构中的数值精度相同。</p>
<p><strong>字段长度</strong>：与 Field 结构中的字段长度相同。</p>
<h2>5 参考资料</h2>
<p>《<a href="http://dev.mysql.com/doc/internals/en/index.html" target="_blank">MySQL Internals Manual</a>: <a href="http://dev.mysql.com/doc/internals/en/client-server-protocol.html" target="_blank">MySQL Client/Server Protocol</a>》</p>
]]></content>
    <category scheme="http://hutaow.com/blog/tags/Protocol/" term="Protocol"/>
    <category scheme="http://hutaow.com/blog/tags/MySQL/" term="MySQL"/>
    <category scheme="http://hutaow.com/blog/tags/协议分析/" term="协议分析"/>
    <category scheme="http://hutaow.com/blog/tags/数据库/" term="数据库"/>
    <category scheme="http://hutaow.com/blog/categories/Protocol/" term="Protocol"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[通过PXE方式安装Linux系统]]></title>
    <link href="http://hutaow.com/blog/2013/10/30/install-linux-with-pxe/"/>
    <id>http://hutaow.com/blog/2013/10/30/install-linux-with-pxe/</id>
    <published>2013-10-30T15:30:57.000Z</published>
    <updated>2013-11-09T13:58:22.000Z</updated>
    <content type="html"><![CDATA[<h3>1 准备工作</h3>
<ul>
<li>Linux安装镜像（本文以CentOS为例）</li>
<li>TFTP+DHCP服务程序（Windows环境中推荐Tftpd32，<a href="http://tftpd32.jounin.net" target="_blank">点击此处进入下载页面</a>）</li>
<li>FTP服务程序（推荐FileZilla，<a href="http://filezilla-project.org" target="_blank">点击此处进入下载页面</a>）</li>
</ul>
<a id="more"></a>

<h3>2 建立PXE启动目录</h3>
<ul>
<li>创建<code>E:\Server\PXE</code>目录，将Linux光盘镜像<code>/images/pxeboot</code>文件夹中的<code>initrd.img</code>和<code>vmlinux</code>文件拷贝到该目录中</li>
<li>在<code>E:\Server\PXE</code>中创建<code>pxelinux.cfg</code>目录，将光盘镜像<code>/isolinux</code>文件夹中的<code>isolinux.cfg</code>文件拷贝到该目录中，并重命名为<code>default</code></li>
<li>将syslinux的PXE启动加载程序<code>pxelinux.0</code>拷贝到<code>E:\Server\PXE</code>目录中（可以从一个现有的Linux中拷贝一个，一般在<code>/usr/lib/syslinux</code>或<code>/usr/share/syslinux</code>目录中，如果找不到现成的Linux，可以<a href="/downloads/linux/pxelinux.0">点击这里下载</a>一个）</li>
</ul>
<p>PXE目录建立好后，结构应该是下面的样子：</p>
<pre><code>/PXE/
    <span class="string">|- pxelinux.cfg/</span>
    <span class="string">|              |- default</span>
    <span class="string">|- pxelinux.0</span>
    <span class="string">|- initrd.img</span>
    <span class="string">|- vmlinuz</span></code></pre>
<h3>3 软件配置</h3>
<h4>3.1 配置DHCP服务</h4>
<p>配置DHCP主要有以下几个关键点：</p>
<ul>
<li><strong>IP Pool Starting Address</strong>：192.168.0.100 <em>（配置DHCP分配IP的起始地址）</em></li>
<li><strong>Size of Pool</strong>：100 <em>（配置DHCP的地址池大小）</em></li>
<li><strong>Boot File</strong>：pxelinux.0 <em>（配置启动文件）</em></li>
</ul>
<p>另外还有一个选项开关“<strong>Ping address before assignation</strong>”（分配地址前进行Ping操作），最好将其关闭，因为打开它的情况下客户端可能出现无法及时加载启动文件的情况。</p>
<p>配置完成后，Tftpd32应该是类似下图的样子：</p>
<p><img src="/images/articles/201310/install_linux_with_pxe_dhcp.png" alt="Tftpd32配置DHCP选项"></p>
<h4>3.2 配置TFTP服务</h4>
<p>配置TFTP服务只需要将TFTP的目录设置对即可，其它选项用默认参数，这里目录设置为<code>E:\Server\PXE</code>。</p>
<p>配置完成后，Tftpd32应该是类似下图的样子：</p>
<p><img src="/images/articles/201310/install_linux_with_pxe_tftp.png" alt="Tftpd32配置TFTP目录"></p>
<h4>3.3 配置FTP服务</h4>
<p>配置FTP比较简单，将Linux的光盘镜像解压，并将FTP服务指向解压目录即可</p>
<h3>4 启动安装</h3>
<ul>
<li>将待安装Linux的电脑设置为PXE引导方式，并等待电脑启动</li>
<li>PXE启动成功后，屏幕上可以看到<code>Boot</code>的提示符，输入<code>linux</code>或直接按回车加载内核</li>
<li>Linux内核加载后，会显示Linux的安装初始界面，选择FTP安装方式，并将前面配置好的FTP地址输入进去</li>
<li>稍等片刻，就可以进入Linux的安装界面了</li>
</ul>
]]></content>
    <category scheme="http://hutaow.com/blog/tags/Linux/" term="Linux"/>
    <category scheme="http://hutaow.com/blog/tags/PXE/" term="PXE"/>
    <category scheme="http://hutaow.com/blog/categories/Linux/" term="Linux"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Linux中生成 Core Dump 文件的方法]]></title>
    <link href="http://hutaow.com/blog/2013/10/25/linux-core-dump/"/>
    <id>http://hutaow.com/blog/2013/10/25/linux-core-dump/</id>
    <published>2013-10-25T15:19:39.000Z</published>
    <updated>2013-11-09T13:58:22.000Z</updated>
    <content type="html"><![CDATA[<h3>1 什么是 Core Dump</h3>
<p>Core Dump 又叫核心转储。在程序运行过程中发生异常时，将其内存数据保存到文件中，这个过程叫做 Core Dump。</p>
<h3>2 Core Dump 的作用</h3>
<p>在开发过程中，难免会遇到程序运行过程中异常退出的情况，这时候想要定位哪里出了问题，仅仅依靠程序自身的信息打印（日志记录）往往是不够的，这个时候就需要 Core Dump 文件来帮忙了。</p>
<p>一个完整的 Core Dump 文件实际上相当于恢复了异常现场，利用 Core Dump 文件，可以查看到程序异常时的所有信息，变量值、栈信息、内存数据，程序异常时的运行位置（甚至记录代码行号）等等，定位所需要的一切信息都可以从 Core Dump文件获取到，能够非常有效的提高定位效率。</p>
<a id="more"></a>

<h3>3 如何生成 Core Dump</h3>
<h4>3.1 Core Dump 文件生成开关</h4>
<p>Core Dump 文件的生成是由Core文件大小限制，Linux中默认的Core文件大小设置为零，也就是不生成 Core Dump 文件，可以使用<code>ulimit -c</code>命令来查看当前的Core文件大小限制。</p>
<p>要生成 Core Dump 文件，只需要执行下面的命令设置Core文件的大小即可（其中<code>filesize</code>参数的单位为KByte）：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">ulimit</span> -c filesize
</pre></td></tr></table></figure>

<p>如果要设置Core文件大小无限制（即把程序完整的运行内存都保存下来），则执行如下命令：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">ulimit</span> -c unlimited
</pre></td></tr></table></figure>

<h4>3.2 Core Dump 文件名设置</h4>
<p>Core Dump 文件默认的名字为<code>core</code>，而且新的Core文件会把老的覆盖，这样我们只能看到最后一次的 Core Dump 信息，可以通过设置Core文件名称模板，使每次生成的 Core Dump 文件区分开来。</p>
<p>Core Dump 文件的命名规则定义在<code>/proc/sys/kernel/core_pattern</code>文件中，规则中还可以加入预设的变量来更好的区分Core文件，支持的变量列表如下：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>%%</td>
<td><code>%</code>字符</td>
</tr>
<tr>
<td>%p</td>
<td>进程ID(PID)</td>
</tr>
<tr>
<td>%u</td>
<td>用户ID(UID)</td>
</tr>
<tr>
<td>%g</td>
<td>用户组ID</td>
</tr>
<tr>
<td>%s</td>
<td>触发 Core Dump 的信号</td>
</tr>
<tr>
<td>%t</td>
<td>触发 Core Dump 的时间(单位为秒，从 1970-01-01 00:00:00 开始计算)</td>
</tr>
<tr>
<td>%h</td>
<td>主机名称(主机名可以通过<code>uname</code>命令来查看)</td>
</tr>
<tr>
<td>%e</td>
<td>程序名称(无路径信息)</td>
</tr>
<tr>
<td>%E</td>
<td>程序的路径名称(路径中的<code>/</code>会被<code>!</code>替代)</td>
</tr>
<tr>
<td>%c</td>
<td>Core文件的限制大小值(Linux 2.6.24版本后开始支持)</td>
</tr>
</tbody>
</table>
<p>注：Core Dump 文件名的最大长度为128字节（在 Linux 2.6.19 版本前，最大长度为64字节）。</p>
<p>例如：可以通过下面的命令，生成文件名为<code>core-程序名称-进程ID-时间</code>的 Core Dump 文件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>echo <span class="string">"core-<span class="variable">%e</span>-<span class="variable">%p</span>-<span class="variable">%t</span>"</span> &gt; <span class="regexp">/proc/sys</span><span class="regexp">/kernel/core</span>_pattern
</pre></td></tr></table></figure>

<p>从 Linux 2.4 版本开始，提供了一种比较原始的Core文件名设置方式，直接设置<code>/proc/sys/kernel/core_uses_pid</code>文件中的值为1，生成的Core文件名中便会自动加上<code>.PID</code>后缀，即生成的文件名为<code>core.PID</code>这种形式。执行下面的命令可以设置该值：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>echo <span class="string">"1"</span> &gt; <span class="regexp">/proc/sys</span><span class="regexp">/kernel/core</span>_uses_pid
</pre></td></tr></table></figure>

<h3>4 如何使用 Core Dump</h3>
<p>有了 Core Dump 文件后，可以使用GDB来加载分析，执行如下命令（假设可执行程序名称及路径为<code>/home/hutaow/test_dump</code>，生成的Core文件名为<code>core</code>）：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">gdb</span> /home/hutaow/test_dump -c core
</pre></td></tr></table></figure>

<p>加载完成后，即可以在GDB中查看程序异常时的各种运行信息了（查看变量值、线程信息、调用栈、反汇编等等）。</p>
]]></content>
    <category scheme="http://hutaow.com/blog/tags/Linux/" term="Linux"/>
    <category scheme="http://hutaow.com/blog/tags/CoreDump/" term="CoreDump"/>
    <category scheme="http://hutaow.com/blog/tags/GDB/" term="GDB"/>
    <category scheme="http://hutaow.com/blog/tags/开发/" term="开发"/>
    <category scheme="http://hutaow.com/blog/tags/定位/" term="定位"/>
    <category scheme="http://hutaow.com/blog/categories/Programming/" term="Programming"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Linux信号处理机制]]></title>
    <link href="http://hutaow.com/blog/2013/10/19/linux-signal/"/>
    <id>http://hutaow.com/blog/2013/10/19/linux-signal/</id>
    <published>2013-10-19T13:47:22.000Z</published>
    <updated>2013-11-09T13:58:22.000Z</updated>
    <content type="html"><![CDATA[<p>在Linux中，信号是进程间通讯的一种方式，它采用的是异步机制。当信号发送到某个进程中时，操作系统会中断该进程的正常流程，并进入相应的信号处理函数执行操作，完成后再回到中断的地方继续执行。</p>
<p>需要说明的是，信号只是用于通知进程发生了某个事件，除了信号本身的信息之外，并不具备传递用户数据的功能。</p>
<a id="more"></a>

<h3>1 信号的响应动作</h3>
<p>每个信号都有自己的响应动作，当接收到信号时，进程会根据信号的响应动作执行相应的操作，信号的响应动作有以下几种：</p>
<ul>
<li>中止进程(Term)</li>
<li>忽略信号(Ign)</li>
<li>中止进程并保存内存信息(Core)</li>
<li>停止进程(Stop)</li>
<li>继续运行进程(Cont)</li>
</ul>
<p>用户可以通过<code>signal</code>或<code>sigaction</code>函数修改信号的响应动作（也就是常说的“注册信号”，在文章的后面会举例说明）。另外，在多线程中，各线程的信号响应动作都是相同的，不能对某个线程设置独立的响应动作。</p>
<h3>2 信号类型</h3>
<p>Linux支持的信号类型可以参考下面给出的列表。</p>
<h4>2.1 在POSIX.1-1990标准中的信号列表</h4>
<table>
<thead>
<tr>
<th>信号</th>
<th>值</th>
<th>动作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGHUP</td>
<td>1</td>
<td>Term</td>
<td>终端控制进程结束(终端连接断开)</td>
</tr>
<tr>
<td>SIGINT</td>
<td>2</td>
<td>Term</td>
<td>用户发送INTR字符(Ctrl+C)触发</td>
</tr>
<tr>
<td>SIGQUIT</td>
<td>3</td>
<td>Core</td>
<td>用户发送QUIT字符(Ctrl+/)触发</td>
</tr>
<tr>
<td>SIGILL</td>
<td>4</td>
<td>Core</td>
<td>非法指令(程序错误、试图执行数据段、栈溢出等)</td>
</tr>
<tr>
<td>SIGABRT</td>
<td>6</td>
<td>Core</td>
<td>调用abort函数触发</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>8</td>
<td>Core</td>
<td>算术运行错误(浮点运算错误、除数为零等)</td>
</tr>
<tr>
<td>SIGKILL</td>
<td>9</td>
<td>Term</td>
<td>无条件结束程序(不能被捕获、阻塞或忽略)</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>11</td>
<td>Core</td>
<td>无效内存引用(试图访问不属于自己的内存空间、对只读内存空间进行写操作)</td>
</tr>
<tr>
<td>SIGPIPE</td>
<td>13</td>
<td>Term</td>
<td>消息管道损坏(FIFO/Socket通信时，管道未打开而进行写操作)</td>
</tr>
<tr>
<td>SIGALRM</td>
<td>14</td>
<td>Term</td>
<td>时钟定时信号</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>15</td>
<td>Term</td>
<td>结束程序(可以被捕获、阻塞或忽略)</td>
</tr>
<tr>
<td>SIGUSR1</td>
<td>30,10,16</td>
<td>Term</td>
<td>用户保留</td>
</tr>
<tr>
<td>SIGUSR2</td>
<td>31,12,17</td>
<td>Term</td>
<td>用户保留</td>
</tr>
<tr>
<td>SIGCHLD</td>
<td>20,17,18</td>
<td>Ign</td>
<td>子进程结束(由父进程接收)</td>
</tr>
<tr>
<td>SIGCONT</td>
<td>19,18,25</td>
<td>Cont</td>
<td>继续执行已经停止的进程(不能被阻塞)</td>
</tr>
<tr>
<td>SIGSTOP</td>
<td>17,19,23</td>
<td>Stop</td>
<td>停止进程(不能被捕获、阻塞或忽略)</td>
</tr>
<tr>
<td>SIGTSTP</td>
<td>18,20,24</td>
<td>Stop</td>
<td>停止进程(可以被捕获、阻塞或忽略)</td>
</tr>
<tr>
<td>SIGTTIN</td>
<td>21,21,26</td>
<td>Stop</td>
<td>后台程序从终端中读取数据时触发</td>
</tr>
<tr>
<td>SIGTTOU</td>
<td>22,22,27</td>
<td>Stop</td>
<td>后台程序向终端中写数据时触发</td>
</tr>
</tbody>
</table>
<p><strong>注</strong>：其中<code>SIGKILL</code>和<code>SIGSTOP</code>信号不能被捕获、阻塞或忽略。</p>
<h4>2.2 在SUSv2和POSIX.1-2001标准中的信号列表</h4>
<table>
<thead>
<tr>
<th>信号</th>
<th>值</th>
<th>动作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGTRAP</td>
<td>5</td>
<td>Core</td>
<td>Trap指令触发(如断点，在调试器中使用)</td>
</tr>
<tr>
<td>SIGBUS</td>
<td>0,7,10</td>
<td>Core</td>
<td>非法地址(内存地址对齐错误)</td>
</tr>
<tr>
<td>SIGPOLL</td>
<td></td>
<td>Term</td>
<td>Pollable event (Sys V). Synonym for SIGIO</td>
</tr>
<tr>
<td>SIGPROF</td>
<td>27,27,29</td>
<td>Term</td>
<td>性能时钟信号(包含系统调用时间和进程占用CPU的时间)</td>
</tr>
<tr>
<td>SIGSYS</td>
<td>12,31,12</td>
<td>Core</td>
<td>无效的系统调用(SVr4)</td>
</tr>
<tr>
<td>SIGURG</td>
<td>16,23,21</td>
<td>Ign</td>
<td>有紧急数据到达Socket(4.2BSD)</td>
</tr>
<tr>
<td>SIGVTALRM</td>
<td>26,26,28</td>
<td>Term</td>
<td>虚拟时钟信号(进程占用CPU的时间)(4.2BSD)</td>
</tr>
<tr>
<td>SIGXCPU</td>
<td>24,24,30</td>
<td>Core</td>
<td>超过CPU时间资源限制(4.2BSD)</td>
</tr>
<tr>
<td>SIGXFSZ</td>
<td>25,25,31</td>
<td>Core</td>
<td>超过文件大小资源限制(4.2BSD)</td>
</tr>
</tbody>
</table>
<p><strong>注</strong>：在Linux 2.2版本之前，<code>SIGSYS</code>、<code>SIGXCPU</code>、<code>SIGXFSZ</code>以及<code>SIGBUS</code>的默认响应动作为Term，Linux 2.4版本之后这三个信号的默认响应动作改为Core。</p>
<h4>2.3 其它信号</h4>
<table>
<thead>
<tr>
<th>信号</th>
<th>值</th>
<th>动作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGIOT</td>
<td>6</td>
<td>Core</td>
<td>IOT捕获信号(同SIGABRT信号)</td>
</tr>
<tr>
<td>SIGEMT</td>
<td>7,-,7</td>
<td>Term</td>
<td>实时硬件发生错误</td>
</tr>
<tr>
<td>SIGSTKFLT</td>
<td>-,16,-</td>
<td>Term</td>
<td>协同处理器栈错误(未使用)</td>
</tr>
<tr>
<td>SIGIO</td>
<td>23,29,22</td>
<td>Term</td>
<td>文件描述符准备就绪(可以开始进行输入/输出操作)(4.2BSD)</td>
</tr>
<tr>
<td>SIGCLD</td>
<td>-,-,18</td>
<td>Ign</td>
<td>子进程结束(由父进程接收)(同SIGCHLD信号)</td>
</tr>
<tr>
<td>SIGPWR</td>
<td>29,30,19</td>
<td>Term</td>
<td>电源错误(System V)</td>
</tr>
<tr>
<td>SIGINFO</td>
<td>29,-,-</td>
<td></td>
<td>电源错误(同SIGPWR信号)</td>
</tr>
<tr>
<td>SIGLOST</td>
<td>-,-,-</td>
<td>Term</td>
<td>文件锁丢失(未使用)</td>
</tr>
<tr>
<td>SIGWINCH</td>
<td>28,28,20</td>
<td>Ign</td>
<td>窗口大小改变时触发(4.3BSD, Sun)</td>
</tr>
<tr>
<td>SIGUNUSED</td>
<td>-,31,-</td>
<td>Core</td>
<td>无效的系统调用(同SIGSYS信号)</td>
</tr>
</tbody>
</table>
<p><strong>注意</strong>：列表中有的信号有三个值，这是因为部分信号的值和CPU架构有关，这些信号的值在不同架构的CPU中是不同的，三个值的排列顺序为：1，Alpha/Sparc；2，x86/ARM/Others；3，MIPS。</p>
<p>例如<code>SIGSTOP</code>这个信号，它有三种可能的值，分别是17、19、23，其中第一个值（17）是用在Alpha和Sparc架构中，第二个值（19）用在x86、ARM等其它架构中，第三个值（23）则是用在MIPS架构中的。</p>
<h3>3 信号机制</h3>
<p>文章的前面提到过，信号是异步的，这就涉及信号何时接收、何时处理的问题。</p>
<p>我们知道，函数运行在用户态，当遇到系统调用、中断或是异常的情况时，程序会进入内核态。信号涉及到了这两种状态之间的转换，过程可以先看一下下面的示意图：</p>
<p><img src="/images/articles/201310/linux_signal_flow.png" alt="信号处理机制示意图"></p>
<p>接下来围绕示意图，将信号分成接收、检测和处理三个部分，逐一讲解每一步的处理流程。</p>
<h4>3.1 信号的接收</h4>
<p>接收信号的任务是由内核代理的，当内核接收到信号后，会将其放到对应进程的信号队列中，同时向进程发送一个中断，使其陷入内核态。</p>
<p>注意，此时信号还只是在队列中，对进程来说暂时是不知道有信号到来的。</p>
<h4>3.2 信号的检测</h4>
<p>进程陷入内核态后，有两种场景会对信号进行检测：</p>
<ul>
<li>进程从内核态返回到用户态前进行信号检测</li>
<li>进程在内核态中，从睡眠状态被唤醒的时候进行信号检测</li>
</ul>
<p>当发现有新信号时，便会进入下一步，信号的处理。</p>
<h4>3.3 信号的处理</h4>
<p>信号处理函数是运行在用户态的，调用处理函数前，内核会将当前内核栈的内容备份拷贝到用户栈上，并且修改指令寄存器（eip）将其指向信号处理函数。</p>
<p>接下来进程返回到用户态中，执行相应的信号处理函数。</p>
<p>信号处理函数执行完成后，还需要返回内核态，检查是否还有其它信号未处理。如果所有信号都处理完成，就会将内核栈恢复（从用户栈的备份拷贝回来），同时恢复指令寄存器（eip）将其指向中断前的运行位置，最后回到用户态继续执行进程。</p>
<p>至此，一个完整的信号处理流程便结束了，如果同时有多个信号到达，上面的处理流程会在第2步和第3步骤间重复进行。</p>
<h3>4 信号的使用</h3>
<h4>4.1 发送信号</h4>
<p>用于发送信号的函数有<code>raise</code>、<code>kill</code>、<code>killpg</code>、<code>pthread_kill</code>、<code>tgkill</code>、<code>sigqueue</code>，这几个函数的含义和用法都大同小异，这里主要介绍一下常用的<code>raise</code>和<code>kill</code>函数。</p>
<p><strong>raise函数</strong>：向进程本身发送信号</p>
<p>函数声明如下：</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;signal.h&gt;</span>

<span class="keyword">int</span> raise(<span class="keyword">int</span> sig);
</pre></td></tr></table></figure>

<p>函数功能是向当前程序(自身)发送信号，其中参数<code>sig</code>为信号值。</p>
<p><strong>kill函数</strong>：向指定进程发送信号</p>
<p>函数声明如下：</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>#include <span class="tag">&lt;<span class="title">sys</span>/<span class="attribute">types.h</span>&gt;</span>
#include <span class="tag">&lt;<span class="title">signal.h</span>&gt;</span>

int kill(pid_t pid, int sig);
</pre></td></tr></table></figure>

<p>函数功能是向特定的进程发送信号，其中参数<code>pid</code>为进程号，<code>sig</code>为信号值。</p>
<p>在这里的参数<code>pid</code>，根据取值范围不同，含义也不同，具体说明如下：</p>
<ul>
<li>pid &gt; 0  ：向进程号为pid的进程发送信号</li>
<li>pid = 0  ：向当前进程所在的进程组发送信号</li>
<li>pid = -1 ：向所有进程(除PID=1外)发送信号(权限范围内)</li>
<li>pid &lt; -1 ：向进程组号为-pid的所有进程发送信号</li>
</ul>
<p>另外，当<code>sig</code>值为零时，实际不发送任何信号，但函数返回值依然有效，可以用于检查进程是否存在。</p>
<h4>4.2 等待信号被捕获</h4>
<p>等待信号的过程，其实就是将当前进程(线程)暂停，直到有信号发到当前进程(线程)上并被捕获，函数有<code>pause</code>和<code>sigsuspend</code>。</p>
<p><strong>pause函数</strong>：将进程(或线程)转入睡眠状态，直到接收到信号</p>
<p>函数声明如下：</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;unistd.h&gt;</span>

<span class="keyword">int</span> pause(<span class="keyword">void</span>);
</pre></td></tr></table></figure>

<p>该函数调用后，调用者(进程或线程)会进入睡眠(Sleep)状态，直到捕获到(任意)信号为止。该函数的返回值始终为-1，并且调用结束后，错误代码(errno)会被置为EINTR。</p>
<p><strong>sigsuspend函数</strong>：将进程(或线程)转入睡眠状态，直到接收到特定信号</p>
<p>函数声明如下：</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;signal.h&gt;</span>

<span class="keyword">int</span> sigsuspend(<span class="keyword">const</span> sigset_t *mask);
</pre></td></tr></table></figure>

<p>该函数调用后，会将进程的信号掩码临时修改(参数<code>mask</code>)，然后暂停进程，直到收到符合条件的信号为止，函数返回前会将调用前的信号掩码恢复。该函数的返回值始终为-1，并且调用结束后，错误代码(errno)会被置为EINTR。</p>
<h4>4.3 修改信号的响应动作</h4>
<p>用户可以自己重新定义某个信号的处理方式，即前面提到的修改信号的默认响应动作，也可以理解为对信号的注册，可以通过<code>signal</code>或<code>sigaction</code>函数进行，这里以<code>signal</code>函数举例说明。</p>
<p>首先看一下函数声明：</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>#include &lt;signal.h&gt;

typedef void <span class="comment">(*sighandler_t)(int);

sighandler_t signal(int signum, sighandler_t handler);
</pre></td></tr></table></figure>

<p>第一个参数<code>signum</code>是信号值，可以从前面的信号列表中查到，第二个参数<code>handler</code>为处理函数，通过回调方式在信号触发时调用。</p>
<p>下面为示例代码：</p>
<figure class="highlight lang-c"><figcaption><span>Example of Linux Signal </span><a href="/downloads/code/linux_signal.c">download</a></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;signal.h&gt;</span>
<span class="preprocessor">#include &lt;unistd.h&gt;</span>

<span class="comment">/* 信号处理函数 */</span>
<span class="keyword">void</span> sig_callback(<span class="keyword">int</span> signum) {
    <span class="keyword">switch</span> (signum) {
        <span class="keyword">case</span> SIGINT:
            <span class="comment">/* SIGINT: Ctrl+C 按下时触发 */</span>
            printf(<span class="string">"Get signal SIGINT. \r\n"</span>);
            <span class="keyword">break</span>;
        <span class="comment">/* 多个信号可以放到同一个函数中进行 通过信号值来区分 */</span>
        <span class="keyword">default</span>:
            <span class="comment">/* 其它信号 */</span>
            printf(<span class="string">"Unknown signal %d. \r\n"</span>, signum);
            <span class="keyword">break</span>;
    }

    <span class="keyword">return</span>;
}

<span class="comment">/* 主函数 */</span>
<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) {
    printf(<span class="string">"Register SIGINT(%u) Signal Action. \r\n"</span>, SIGINT);

    <span class="comment">/* 注册SIGINT信号的处理函数 */</span>
    <span class="keyword">signal</span>(SIGINT, sig_callback);

    printf(<span class="string">"Waitting for Signal ... \r\n"</span>);

    <span class="comment">/* 等待信号触发 */</span>
    pause();

    printf(<span class="string">"Process Continue. \r\n"</span>);

    <span class="keyword">return</span> <span class="number">0</span>;
}


</pre></td></tr></table></figure>


<p>例子中，将<code>SIGINT</code>信号（<code>Ctrl+C</code>触发）的动作接管(打印提示信息)，程序运行后，按下<code>Ctrl+C</code>，命令行输出如下：</p>
<pre><code>./linux_signal_example
Register SIGINT(<span class="number">2</span>) Signal Action. 
Waitting <span class="keyword">for</span> Signal <span class="keyword">...</span> 
^CGet signal SIGINT. 
Process Continue.</code></pre>
<p>进程收到<code>SIGINT</code>信号后，触发响应动作，将提示信息打印出来，然后从暂停的地方继续运行。这里需要注意的是，因为我们修改了<code>SIGINT</code>信号的响应动作（只打印信息，不做进程退出处理），所以我们按下<code>Ctrl+C</code>后，程序并没有直接退出，而是继续运行并将“Process Continue.”打印出来，直至程序正常结束。</p>
]]></content>
    <category scheme="http://hutaow.com/blog/tags/Linux/" term="Linux"/>
    <category scheme="http://hutaow.com/blog/tags/C/" term="C"/>
    <category scheme="http://hutaow.com/blog/tags/开发/" term="开发"/>
    <category scheme="http://hutaow.com/blog/tags/信号/" term="信号"/>
    <category scheme="http://hutaow.com/blog/categories/Linux/" term="Linux"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[函数调用栈的获取原理分析]]></title>
    <link href="http://hutaow.com/blog/2013/10/15/dump-stack/"/>
    <id>http://hutaow.com/blog/2013/10/15/dump-stack/</id>
    <published>2013-10-15T15:32:31.000Z</published>
    <updated>2013-11-09T13:58:22.000Z</updated>
    <content type="html"><![CDATA[<p>上一篇文章<a href="/blog/2013/10/11/dump-stack-with-backtrace">《在Linux程序中输出函数调用栈》</a>，讲述了在Linux中如何利用backtrace获取调用栈，本篇文章主要介绍一下获取函数调用栈的原理，并给出相应的实现方式。</p>
<a id="more"></a>

<p>要了解调用栈，首先需要了解函数的调用过程，下面用一段代码作为例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="comment">#include &lt;stdio.h&gt;</span>

<span class="keyword">int</span> add(<span class="keyword">int</span> a, <span class="keyword">int</span> b) {
    <span class="keyword">int</span> result = <span class="number">0</span>;

    result = a + b;

    <span class="keyword">return</span> result;
}

<span class="keyword">int</span> main(<span class="keyword">int</span> argc, char <span class="variable">*argv</span>[]) {
    <span class="keyword">int</span> result = <span class="number">0</span>;

    result = test(<span class="number">1</span>, <span class="number">2</span>);

    <span class="keyword">printf</span>(<span class="string">"result = <span class="variable">%d</span> \r\n"</span>, result);

    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>

<p>使用gcc编译，然后gdb反汇编main函数，看看它是如何调用add函数的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="xml">(gdb) disassemble main 
Dump of assembler code for function main:
   </span><span class="number">0x08048439</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">0</span><span class="xml">&gt;:     push   %ebp
   </span><span class="number">0x0804843a</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">1</span><span class="xml">&gt;:     mov    %esp,%ebp
   </span><span class="number">0x0804843c</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">3</span><span class="xml">&gt;:     and    </span><span class="variable">$0xfffffff0</span><span class="xml">,%esp
   </span><span class="number">0x0804843f</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">6</span><span class="xml">&gt;:     sub    </span><span class="variable">$0x20</span><span class="xml">,%esp
   </span><span class="number">0x08048442</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">9</span><span class="xml">&gt;:     movl   </span><span class="variable">$0x0</span><span class="xml">,</span><span class="number">0x1c</span><span class="xml">(%esp)  # 给result变量赋</span><span class="number">0</span><span class="xml">值
   </span><span class="number">0x0804844a</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">17</span><span class="xml">&gt;:    movl   </span><span class="variable">$0x2</span><span class="xml">,</span><span class="number">0x4</span><span class="xml">(%esp)   # 将第</span><span class="number">2</span><span class="xml">个参数压栈(该参数偏移为esp+</span><span class="number">0x04</span><span class="xml">)
   </span><span class="number">0x08048452</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">25</span><span class="xml">&gt;:    movl   </span><span class="variable">$0x1</span><span class="xml">,(%esp)      # 将第</span><span class="number">1</span><span class="xml">个参数压栈(该参数偏移为esp+</span><span class="number">0x00</span><span class="xml">)
   </span><span class="number">0x08048459</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">32</span><span class="xml">&gt;:    call   </span><span class="number">0x804841c</span><span class="xml"> <span class="tag">&lt;<span class="title">add</span>&gt;</span>  # 调用add函数
   </span><span class="number">0x0804845e</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">37</span><span class="xml">&gt;:    mov    %eax,</span><span class="number">0x1c</span><span class="xml">(%esp)  # 将add函数的返回值赋给result变量
   </span><span class="number">0x08048462</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">41</span><span class="xml">&gt;:    mov    </span><span class="number">0x1c</span><span class="xml">(%esp),%eax
   </span><span class="number">0x08048466</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">45</span><span class="xml">&gt;:    mov    %eax,</span><span class="number">0x4</span><span class="xml">(%esp)
   </span><span class="number">0x0804846a</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">49</span><span class="xml">&gt;:    movl   </span><span class="variable">$0x8048510</span><span class="xml">,(%esp)
   </span><span class="number">0x08048471</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">56</span><span class="xml">&gt;:    call   </span><span class="number">0x80482f0</span><span class="xml"> <span class="tag">&lt;<span class="title">printf@plt</span>&gt;</span>
   </span><span class="number">0x08048476</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">61</span><span class="xml">&gt;:    mov    </span><span class="variable">$0x0</span><span class="xml">,%eax
   </span><span class="number">0x0804847b</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">66</span><span class="xml">&gt;:    leave  
   </span><span class="number">0x0804847c</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">67</span><span class="xml">&gt;:    ret    
End of assembler dump.</span>
</pre></td></tr></table></figure>

<p>可以看到，参数是在add函数调用前压栈，换句话说，参数压栈由调用者进行，参数存储在调用者的栈空间中，下面再看一下进入add函数后都做了什么：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="xml">(gdb) disassemble add
Dump of assembler code for function add:
   </span><span class="number">0x0804841c</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">0</span><span class="xml">&gt;:     push   %ebp             # 将ebp压栈(保存函数调用者的栈基址)
   </span><span class="number">0x0804841d</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">1</span><span class="xml">&gt;:     mov    %esp,%ebp        # 将ebp指向栈顶esp(设置当前函数的栈基址)
   </span><span class="number">0x0804841f</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">3</span><span class="xml">&gt;:     sub    </span><span class="variable">$0x10</span><span class="xml">,%esp       # 分配栈空间(栈向低地址方向生长)
   </span><span class="number">0x08048422</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">6</span><span class="xml">&gt;:     movl   </span><span class="variable">$0x0</span><span class="xml">,-</span><span class="number">0x4</span><span class="xml">(%ebp)  # 给result变量赋</span><span class="number">0</span><span class="xml">值(该变量偏移为ebp-</span><span class="number">0x04</span><span class="xml">)
   </span><span class="number">0x08048429</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">13</span><span class="xml">&gt;:    mov    </span><span class="number">0xc</span><span class="xml">(%ebp),%eax   # 将第</span><span class="number">2</span><span class="xml">个参数的值赋给eax(准备运算)
   </span><span class="number">0x0804842c</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">16</span><span class="xml">&gt;:    mov    </span><span class="number">0x8</span><span class="xml">(%ebp),%edx   # 将第</span><span class="number">1</span><span class="xml">个参数的值赋给edx(准备运算)
   </span><span class="number">0x0804842f</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">19</span><span class="xml">&gt;:    add    %edx,%eax        # 加法运算(edx+eax)，结果保存在eax中
   </span><span class="number">0x08048431</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">21</span><span class="xml">&gt;:    mov    %eax,-</span><span class="number">0x4</span><span class="xml">(%ebp)  # 将运算结果eax赋给result变量
   </span><span class="number">0x08048434</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">24</span><span class="xml">&gt;:    mov    -</span><span class="number">0x4</span><span class="xml">(%ebp),%eax  # 将result变量的值赋给eax(eax将作为函数返回值)
   </span><span class="number">0x08048437</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">27</span><span class="xml">&gt;:    leave                   # 恢复函数调用者的栈基址(pop %ebp)
   </span><span class="number">0x08048438</span><span class="xml"> <span class="tag">&lt;<span class="title">+</span></span><span class="number">28</span><span class="xml">&gt;:    ret                     # 返回(准备执行下条指令)
End of assembler dump.</span>
</pre></td></tr></table></figure>

<p>进入add函数后，首先进行的操作是将当前的栈基址ebp压栈(此栈基址是调用者main函数的)，然后将ebp指向栈顶esp，接下来再进行函数内的处理流程。函数结束前，会将函数调用者的栈基址恢复，然后返回准备执行下一指令。这个过程中，栈上的空间会是下面的样子：</p>
<p><img src="/images/articles/201310/dia_function_stack.png" alt="函数调用过程中栈的情况"></p>
<p>可以发现，每调用一次函数，都会对调用者的栈基址(ebp)进行压栈操作，并且由于栈基址是由当时栈顶指针(esp)而来，会发现，各层函数的栈基址很巧妙的构成了一个链，即当前的栈基址指向下一层函数栈基址所在的位置，如下图所示：</p>
<p><img src="/images/articles/201310/dia_dump_stack.png" alt="调用栈中各层函数栈基址间的关系"></p>
<p>了解了函数的调用过程，想要回溯调用栈也就很简单了，首先获取当前函数的栈基址(寄存器ebp)的值，然后获取该地址所指向的栈的值，该值也就是下层函数的栈基址，找到下层函数的栈基址后，重复刚才的动作，即可以将每一层函数的栈基址都找出来，这也就是我们所需要的调用栈了。</p>
<p>下面是根据原理实现的一段获取函数调用栈的代码，供参考。</p>
<figure class="highlight lang-c"><figcaption><span>Code of Dump Stack </span><a href="/downloads/code/dumpstack.c">download</a></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>

<span class="comment">/* 打印调用栈的最大深度 */</span>
<span class="preprocessor">#define DUMP_STACK_DEPTH_MAX 16</span>

<span class="comment">/* 获取寄存器ebp的值 */</span>
<span class="keyword">void</span> get_ebp(<span class="keyword">unsigned</span> <span class="keyword">long</span> *ebp) {
    __asm__ __volatile__ (
        <span class="string">"mov %%ebp, %0"</span>
        :<span class="string">"=m"</span>(*ebp)
        ::<span class="string">"memory"</span>);
}

<span class="comment">/* 获取调用栈 */</span>
<span class="keyword">int</span> dump_stack(<span class="keyword">void</span> **<span class="built_in">stack</span>, <span class="keyword">int</span> size) {
    <span class="keyword">unsigned</span> <span class="keyword">long</span> ebp = <span class="number">0</span>;
    <span class="keyword">int</span> depth = <span class="number">0</span>;

    <span class="comment">/* 1.得到首层函数的栈基址 */</span>
    get_ebp(&amp;ebp);

    <span class="comment">/* 2.逐层回溯栈基址 */</span>
    <span class="keyword">for</span> (depth = <span class="number">0</span>; (depth &lt; size) &amp;&amp; (<span class="number">0</span> != ebp) &amp;&amp; (<span class="number">0</span> != *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)ebp) &amp;&amp; (ebp != *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)ebp); ++depth) {
        <span class="built_in">stack</span>[depth] = (<span class="keyword">void</span> *)(*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(ebp + <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>)));
        ebp = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)ebp;
    }

    <span class="keyword">return</span> depth;
}

<span class="comment">/* 测试函数 2 */</span>
<span class="keyword">void</span> test_meloner() {
    <span class="keyword">void</span> *<span class="built_in">stack</span>[DUMP_STACK_DEPTH_MAX] = {<span class="number">0</span>};
    <span class="keyword">int</span> stack_depth = <span class="number">0</span>;
    <span class="keyword">int</span> i = <span class="number">0</span>;

    <span class="comment">/* 获取调用栈 */</span>
    stack_depth = dump_stack(<span class="built_in">stack</span>, DUMP_STACK_DEPTH_MAX);

    <span class="comment">/* 打印调用栈 */</span>
    printf(<span class="string">" Stack Track: \r\n"</span>);
    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; stack_depth; ++i) {
        printf(<span class="string">" [%d] %p \r\n"</span>, i, <span class="built_in">stack</span>[i]);
    }

    <span class="keyword">return</span>;
}

<span class="comment">/* 测试函数 1 */</span>
<span class="keyword">void</span> test_hutaow() {
    test_meloner();
    <span class="keyword">return</span>;
}

<span class="comment">/* 主函数 */</span>
<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) {
    test_hutaow();
    <span class="keyword">return</span> <span class="number">0</span>;
}


</pre></td></tr></table></figure>


<p>执行<code>gcc dumpstack.c -o dumpstack</code>编译并运行，执行结果如下：</p>
<pre><code> <span class="tag">Stack</span> <span class="tag">Track</span>: 
 <span class="attr_selector">[0]</span> 0<span class="tag">x8048475</span> 
 <span class="attr_selector">[1]</span> 0<span class="tag">x8048508</span> 
 <span class="attr_selector">[2]</span> 0<span class="tag">x804855c</span> 
 <span class="attr_selector">[3]</span> 0<span class="tag">x804856a</span></code></pre>
]]></content>
    <category scheme="http://hutaow.com/blog/tags/C/" term="C"/>
    <category scheme="http://hutaow.com/blog/tags/Linux/" term="Linux"/>
    <category scheme="http://hutaow.com/blog/tags/开发/" term="开发"/>
    <category scheme="http://hutaow.com/blog/tags/调用栈/" term="调用栈"/>
    <category scheme="http://hutaow.com/blog/tags/调试/" term="调试"/>
    <category scheme="http://hutaow.com/blog/tags/定位/" term="定位"/>
    <category scheme="http://hutaow.com/blog/categories/Programming/" term="Programming"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[在Linux程序中输出函数调用栈]]></title>
    <link href="http://hutaow.com/blog/2013/10/11/dump-stack-with-backtrace/"/>
    <id>http://hutaow.com/blog/2013/10/11/dump-stack-with-backtrace/</id>
    <published>2013-10-11T14:03:39.000Z</published>
    <updated>2013-11-09T13:58:22.000Z</updated>
    <content type="html"><![CDATA[<p>程序发生异常时，将函数的调用栈打印出来，可以大大提高定位效率。</p>
<p>Linux中提供了三个函数用来获取调用栈：</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="comment">/* 获取函数调用栈 */</span>
<span class="keyword">int</span> backtrace(void <span class="variable">**</span>buffer, <span class="keyword">int</span> <span class="keyword">size</span>);

<span class="comment">/* 将调用栈中的函数地址转化为函数名称 并返回一个字符串数组 */</span>
char <span class="variable">**</span>backtrace_symbols(void <span class="variable">*const</span> <span class="variable">*buffer</span>, <span class="keyword">int</span> <span class="keyword">size</span>);

<span class="comment">/* 将调用栈中的函数地址转化为函数名称 并将其定入到文件中 */</span>
void backtrace_symbols_fd(void <span class="variable">*const</span> <span class="variable">*buffer</span>, <span class="keyword">int</span> <span class="keyword">size</span>, <span class="keyword">int</span> fd);
</pre></td></tr></table></figure>

<a id="more"></a>

<p>示例代码：</p>
<figure class="highlight lang-c"><figcaption><span>Example of backtrace usage </span><a href="/downloads/code/backtrace.c">download</a></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;execinfo.h&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>

<span class="comment">/* 打印调用栈的最大深度 */</span>
<span class="preprocessor">#define DUMP_STACK_DEPTH_MAX 16</span>

<span class="comment">/* 打印调用栈函数 */</span>
<span class="keyword">void</span> dump_trace() {
    <span class="keyword">void</span> *stack_trace[DUMP_STACK_DEPTH_MAX] = {<span class="number">0</span>};
    <span class="keyword">char</span> **stack_strings = NULL;
    <span class="keyword">int</span> stack_depth = <span class="number">0</span>;
    <span class="keyword">int</span> i = <span class="number">0</span>;

    <span class="comment">/* 获取栈中各层调用函数地址 */</span>
    stack_depth = backtrace(stack_trace, DUMP_STACK_DEPTH_MAX);
    
    <span class="comment">/* 查找符号表将函数调用地址转换为函数名称 */</span>
    stack_strings = (<span class="keyword">char</span> **)backtrace_symbols(stack_trace, stack_depth);
    if (NULL == stack_strings) {
        printf(<span class="string">" Memory is not enough while dump Stack Trace! \r\n"</span>);
        <span class="keyword">return</span>;
    }

    <span class="comment">/* 打印调用栈 */</span>
    printf(<span class="string">" Stack Trace: \r\n"</span>);
    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; stack_depth; ++i) {
        printf(<span class="string">" [%d] %s \r\n"</span>, i, stack_strings[i]);
    }

    <span class="comment">/* 获取函数名称时申请的内存需要自行释放 */</span>
    free(stack_strings);
    stack_strings = NULL;

    <span class="keyword">return</span>;
}

<span class="comment">/* 测试函数 2 */</span>
<span class="keyword">void</span> test_meloner() {
    dump_trace();
    <span class="keyword">return</span>;
}

<span class="comment">/* 测试函数 1 */</span>
<span class="keyword">void</span> test_hutaow() {
    test_meloner();
    <span class="keyword">return</span>;
}

<span class="comment">/* 主函数 */</span>
<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) {
    test_hutaow();
    <span class="keyword">return</span> <span class="number">0</span>;
}


</pre></td></tr></table></figure>


<p>编译时需要加上<code>-rdynamic</code>参数，以得到符号名称，像下面这样：</p>
<pre><code><span class="comment">gcc</span> <span class="literal">-</span><span class="comment">rdynamic</span> <span class="comment">backtrace</span>.<span class="comment">c</span> <span class="literal">-</span><span class="comment">o</span> <span class="comment">backtrace</code></pre>
<p>执行<code>./backtrace</code>运行程序，输出如下：</p>
<p><img src="/images/articles/201310/dump_stack_with_backtrace.png" alt="Dump stack with backtrace"></p>
]]></content>
    <category scheme="http://hutaow.com/blog/tags/C/" term="C"/>
    <category scheme="http://hutaow.com/blog/tags/Linux/" term="Linux"/>
    <category scheme="http://hutaow.com/blog/tags/开发/" term="开发"/>
    <category scheme="http://hutaow.com/blog/tags/调用栈/" term="调用栈"/>
    <category scheme="http://hutaow.com/blog/tags/调试/" term="调试"/>
    <category scheme="http://hutaow.com/blog/tags/定位/" term="定位"/>
    <category scheme="http://hutaow.com/blog/categories/Programming/" term="Programming"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[博客搬家完成，新域名正式上线]]></title>
    <link href="http://hutaow.com/blog/2013/10/10/starting-with-new-domain-name/"/>
    <id>http://hutaow.com/blog/2013/10/10/starting-with-new-domain-name/</id>
    <published>2013-10-10T14:23:31.000Z</published>
    <updated>2013-11-09T13:58:22.000Z</updated>
    <content type="html"><![CDATA[<p>昨天注册了<a href="http://hutaow.net" target="_blank">hutaow.net</a>这个域名，决心把博客搬过来，恢复写博客的生活。</p>
<p>算下来差不多有两年时间都没有更新过了，其中一个最主要借口是找不到合适的落脚点，时间最长地方要数ChinaUNIX了，早期的时候用着还是蛮不错的，但是随着时间的推移，ChinaUNIX的系统更新实在是跟不上节奏，想到过搬家但是由于ChinaUNIX的订阅数据实在太蹩脚，连搬都不好搬，更不用说评论等等了，博客搬家的计划也就一直搁置了。后来有试过CSDN无奈上面的广告太多，百度也试过但是它贴代码的效果实在太差，WordPress又悲催的被墙等等。</p>
<p>另一个借口就是工作太忙没时间，一回家就不太想写东西了，但是最近开始意识到挥挥衣袖什么都没有留下的感觉很不好，没有积累，没有思考，需要改变一下了。</p>
<p>博客一方面作为记录，把了解的知识积累下来，方便自己以后回忆；另一方面作为分享，将解决问题过程中吸取的经验写下来，供大家参考，这样遇到同样问题时可以更迅速的解决。</p>
<p>不多说，坚持就好。</p>
]]></content>
    <category scheme="http://hutaow.com/blog/categories/Life/" term="Life"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[TP-WR703n安装OpenWRT记录]]></title>
    <link href="http://hutaow.com/blog/2013/09/06/install-openwrt/"/>
    <id>http://hutaow.com/blog/2013/09/06/install-openwrt/</id>
    <published>2013-09-06T15:16:00.000Z</published>
    <updated>2013-11-09T13:58:22.000Z</updated>
    <content type="html"><![CDATA[<h3>1 安装OpenWRT</h3>
<h4>1.1 下载并刷新固件</h4>
<p>如果以前没刷过OpenWRT，需要升级factory固件，<a href="http://downloads.openwrt.org/snapshots/trunk/ar71xx/openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-factory.bin" title="openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-factory.bin" target="_blank">点击这里下载</a>。</p>
<p>如果之前已经安装过了OpenWRT，则直接更新sysupgrade固件即可，<a href="http://downloads.openwrt.org/snapshots/trunk/ar71xx/openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-sysupgrade.bin" title="openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-sysupgrade.bin" target="_blank">点击这里下载</a>。</p>
<p>注意升级的时候要将原配置删除，避免配置文件互相影响，固件刷新完成后，路由器会自动重启。</p>
<a id="more"></a>

<h4>1.2 登陆路由器</h4>
<p>OpenWRT主线固件的无线信号是默认关闭的，这个时候需要找跟网线将电脑和路由器连接上，然后将电脑的IP地址设置为静态的“192.168.1.100”，然后用Telnet访问“192.168.1.1”，正确的情况下，会看到如下界面：<br><img src="/images/articles/201309/install_openwrt_01_first_login.png" alt="First Login"></p>
<h4>1.3 打开无线信号</h4>
<p>编辑“/etc/config/wireless”文件，将“option disabled 1”这一行注掉，或者直接删除。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>config wifi-device radio0
    <span class="keyword">option</span> type     mac80211
    <span class="keyword">option</span> channel  <span class="number">11</span>
    <span class="keyword">option</span> hwmode   <span class="number">11</span>ng
    <span class="keyword">option</span> path     <span class="comment">'platform/ar933x_wmac'</span>
    <span class="keyword">option</span> htmode   HT20
    list ht_capab   SHORT-GI-<span class="number">20</span>
    list ht_capab   SHORT-GI-<span class="number">40</span>
    list ht_capab   RX-STBC1
    list ht_capab   DSSS_CCK-<span class="number">40</span>
    # REMOVE THIS LINE <span class="keyword">TO</span> ENABLE WIFI:
    # <span class="keyword">option</span> disabled <span class="number">1</span>

config wifi-iface
    <span class="keyword">option</span> device   radio0
    <span class="keyword">option</span> network  lan
    <span class="keyword">option</span> mode     ap
    <span class="keyword">option</span> ssid     OpenWrt
    <span class="keyword">option</span> encryption none
</pre></td></tr></table></figure>

<h4>1.4 外网接入配置</h4>
<p>编辑“/etc/config/network”文件，将原“lan”区段中的“ifname”注掉，新增“wan”段，如果是用宽带拨号上网，则配置成下面的样子（其中USERNAME和PASSWORD分别是拨号的用户名和密码）：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre>config <span class="class"><span class="keyword">interface</span> '<span class="title">loopback</span>'
	<span class="title">option</span> <span class="title">ifname</span> '<span class="title">lo</span>'
	<span class="title">option</span> <span class="title">proto</span> '<span class="title">static</span>'
	<span class="title">option</span> <span class="title">ipaddr</span> '127.0.0.1'
	<span class="title">option</span> <span class="title">netmask</span> '255.0.0.0'

<span class="title">config</span> <span class="title">globals</span> '<span class="title">globals</span>'
	<span class="title">option</span> <span class="title">ula_prefix</span> '<span class="title">fd4f</span>:26<span class="title">fb</span>:9<span class="title">d78</span>::/48'

<span class="title">config</span> <span class="title">interface</span> '<span class="title">lan</span>'
	# <span class="title">option</span> <span class="title">ifname</span> '<span class="title">eth0</span>'
	<span class="title">option</span> <span class="title">type</span> '<span class="title">bridge</span>'
	<span class="title">option</span> <span class="title">proto</span> '<span class="title">static</span>'
	<span class="title">option</span> <span class="title">ipaddr</span> '192.168.1.1'
	<span class="title">option</span> <span class="title">netmask</span> '255.255.255.0'
	<span class="title">option</span> <span class="title">ip6assign</span> '60'

<span class="title">config</span> <span class="title">interface</span> '<span class="title">wan</span>'
	<span class="title">option</span> <span class="title">ifname</span> '<span class="title">eth0</span>'
	<span class="title">option</span> <span class="title">proto</span> '<span class="title">pppoe</span>'
	<span class="title">option</span> <span class="title">username</span> '<span class="title">USERNAME</span>'
	<span class="title">option</span> <span class="title">password</span> '<span class="title">PASSWORD</span>'
</pre></td></tr></table></figure>

<p>如果不需要拨号，直接通过其它路由器连接，则将“wan”区段配置成下面的样子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>config <span class="class"><span class="keyword">interface</span> '<span class="title">wan</span>'
	<span class="title">option</span> <span class="title">ifname</span> '<span class="title">eth0</span>'
	<span class="title">option</span> <span class="title">proto</span> '<span class="title">dhcp</span>'
</pre></td></tr></table></figure>

<h4>1.5 重启路由器，完成OpenWRT的安装</h4>
<p>执行reboot命令重启路由器，将外网线连上，重启后搜索无线信号，就可以看到“OpenWRT”的信号了，连接上去，不出意外的话，这个时候电脑已经可以上网了。</p>
<h3>2 将OpenWRT扩展至U盘</h3>
<h4>2.1 安装基本软件</h4>
<p>再次用Telnet访问“192.168.1.1”，执行下面的命令，将挂载U盘相关的基本软件安装上。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="title">opkg</span> update
<span class="title">opkg</span> install block-mount kmod-fs-ext4 kmod-usb-ohci kmod-usb-storage e2fsprogs
</pre></td></tr></table></figure>

<h4>2.2 准备挂载U盘</h4>
<p>将U盘插上，执行“block info”命令，看下U盘是否已被识别，如下图，其中中sda1、sda2、sda5为U盘分区：<br><img src="/images/articles/201309/install_openwrt_02_block_info.png" alt="Block Info"></p>
<h4>2.3 拷贝系统文件</h4>
<p>执行如下命令，将路由器ROM中的系统文件全部拷贝到U盘中：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="title">mount</span> /dev/sda1 /mnt 
<span class="title">mkdir</span> /tmp/vroot 
<span class="title">mount</span> <span class="comment">--bind / /tmp/vroot </span>
<span class="title">cp</span> -a /tmp/vroot/* /mnt 
<span class="title">sync</span> 
<span class="title">umount</span> /tmp/vroot
</pre></td></tr></table></figure>

<h4>2.4 设置交换空间（可选）</h4>
<p>U盘在分区时可以预留一个交换分区，防止路由器内存不足，这里预留的交换分区是sda5，执行下面的命令：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">swapon</span> /dev/sda5
</pre></td></tr></table></figure>

<h4>2.5 保存挂载信息</h4>
<p>将当前挂载状态写入fstab文件中：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>block detect &gt; <span class="regexp">/etc/config</span><span class="regexp">/fstab
</pre></td></tr></table></figure>

<p>然后修改“/etc/config/fstab”文件，将sda1的挂载点设置为“/”，并将“option enabled”置1，配置类似下面的样子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>config global
	<span class="keyword">option</span> anon_swap <span class="comment">'0'</span>
	<span class="keyword">option</span> anon_mount <span class="comment">'0'</span>
	<span class="keyword">option</span> auto_swap <span class="comment">'1'</span>
	<span class="keyword">option</span> auto_mount <span class="comment">'1'</span>
	<span class="keyword">option</span> delay_root <span class="comment">'5'</span>
	<span class="keyword">option</span> check_fs <span class="comment">'0'</span>

config mount
	<span class="keyword">option</span> target <span class="comment">'/'</span>
	<span class="keyword">option</span> uuid <span class="comment">'413b964c-9c9c-4af4-8966-daf04ee53414'</span>
	<span class="keyword">option</span> enabled <span class="comment">'1'</span>
	<span class="keyword">option</span> fstype <span class="comment">'ext4'</span>

config mount
	<span class="keyword">option</span> target <span class="comment">'/home'</span>
	<span class="keyword">option</span> uuid <span class="comment">'e7052ed0-b883-4375-9f31-5648ea8f2948'</span>
	<span class="keyword">option</span> enabled <span class="comment">'1'</span>
	<span class="keyword">option</span> fstype <span class="comment">'ext4'</span>

config swap
	<span class="keyword">option</span> uuid <span class="comment">'58713d02-e9de-4c23-a56b-a5ea3d3dfcf0'</span>
	<span class="keyword">option</span> enabled <span class="comment">'1'</span>
</pre></td></tr></table></figure>

<p>如果U盘只有一个分区，会只看到一个sda1(“/”)，其它诸如sda2(“/home”)、sda5(“swap”)需要额外分区才能看到。</p>
<h4>2.6 重启路由器，完成OpenWRT的扩展</h4>
<p>重启路由器，再次“df -h”一下，可以看到路由器的空间已经扩展成功了。<br><img src="/images/articles/201309/install_openwrt_03_df.png" alt="DF Info"></p>
]]></content>
    <category scheme="http://hutaow.com/blog/tags/OpenWRT/" term="OpenWRT"/>
    <category scheme="http://hutaow.com/blog/tags/路由器/" term="路由器"/>
    <category scheme="http://hutaow.com/blog/categories/Network/" term="Network"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Linux中分区出现“Read-only file system”的解决办法]]></title>
    <link href="http://hutaow.com/blog/2013/06/16/slove-the-read-only-file-system-problem-in-linux/"/>
    <id>http://hutaow.com/blog/2013/06/16/slove-the-read-only-file-system-problem-in-linux/</id>
    <published>2013-06-16T14:54:00.000Z</published>
    <updated>2013-11-09T13:58:22.000Z</updated>
    <content type="html"><![CDATA[<p>最近发现手机上TF卡权限显示是可写入的，但无法向TF卡写入文件，并提示“Read-only file system”，用下面的命令重新挂载一下就可以了：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">mount</span> -o remount,rw /media/TF
</pre></td></tr></table></figure>

<p>注：其中”/media/TF“是挂载的目录。</p>
]]></content>
    <category scheme="http://hutaow.com/blog/tags/Linux/" term="Linux"/>
    <category scheme="http://hutaow.com/blog/categories/Linux/" term="Linux"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Linux中批量设置目录或文件权限的方法]]></title>
    <link href="http://hutaow.com/blog/2013/06/16/batch-settings-directory-or-file-permissions/"/>
    <id>http://hutaow.com/blog/2013/06/16/batch-settings-directory-or-file-permissions/</id>
    <published>2013-06-15T17:48:00.000Z</published>
    <updated>2013-11-09T13:58:22.000Z</updated>
    <content type="html"><![CDATA[<p>递归方式将当前目录下所有的子目录设置为755权限（不包括文件）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">find</span> ./ -<span class="typedef"><span class="keyword">type</span> d -exec chmod 755 <span class="container">{}</span> \;</span>
</pre></td></tr></table></figure>

<p>递归方式将当前目录下的所有文件设置为644权限（包括子目录下的文件，但不对目录本身设置权限）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">find</span> ./ -<span class="typedef"><span class="keyword">type</span> f -exec chmod 644 <span class="container">{}</span> \;</span>
</pre></td></tr></table></figure>

]]></content>
    <category scheme="http://hutaow.com/blog/tags/Linux/" term="Linux"/>
    <category scheme="http://hutaow.com/blog/categories/Linux/" term="Linux"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[配置 Cisco Catalyst 3560 交换机端口镜像]]></title>
    <link href="http://hutaow.com/blog/2010/05/14/config-cisco-catalyst-3560-switch-port-mirroring/"/>
    <id>http://hutaow.com/blog/2010/05/14/config-cisco-catalyst-3560-switch-port-mirroring/</id>
    <published>2010-05-14T14:13:00.000Z</published>
    <updated>2013-11-09T13:58:22.000Z</updated>
    <content type="html"><![CDATA[<p>假设要将19和27号端口的数据镜像到2号端口，按如下操作进行：</p>
<p>1) 通过串口登陆到交换机，其中参数设置为：速率9600bps，8位数据位，1位停止位，无奇偶校验，无流量控制。</p>
<p>2) 交换机上电自检然后登入后出现命令提示符：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="attribute">Switch&gt;
</pre></td></tr></table></figure>

<a id="more"></a>

<p>3) 依次进入特权模式和全局模式，输入如下命令：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">Switch</span>&gt;enable
Password:
<span class="keyword">Switch</span><span class="comment">#configure terminal</span>
Enter configuration commands, one per line.  End with CNTL/Z.
<span class="keyword">Switch</span>(config)<span class="comment">#</span>
</pre></td></tr></table></figure>

<p>4) 在新session中，将端口19和27设置为被监听端口(source)，2号端口设置为监听端口(destination)，命令如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>Switch(config)#monitor session <span class="number">1</span> source <span class="class"><span class="keyword">interface</span> <span class="title">Fa0</span>/19
<span class="title">Switch</span>(<span class="title">config</span>)#<span class="title">monitor</span> <span class="title">session</span> 1 <span class="title">source</span> <span class="title">interface</span> <span class="title">Fa0</span>/27
<span class="title">Switch</span>(<span class="title">config</span>)#<span class="title">monitor</span> <span class="title">session</span> 1 <span class="title">destination</span> <span class="title">interface</span> <span class="title">Fa0</span>/2
<span class="title">Switch</span>(<span class="title">config</span>)#<span class="title">end</span>
<span class="title">Switch</span>#
03:30:52: %<span class="title">SYS</span>-5-<span class="title">CONFIG_I</span>: <span class="title">Configured</span> <span class="title">from</span> <span class="title">console</span> <span class="title">by</span> <span class="title">console</span>
</pre></td></tr></table></figure>

<p>5) 断开连接，完成。</p>
]]></content>
    <category scheme="http://hutaow.com/blog/tags/交换机/" term="交换机"/>
    <category scheme="http://hutaow.com/blog/categories/Network/" term="Network"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[C#获取XML文件指定节点的数据]]></title>
    <link href="http://hutaow.com/blog/2010/04/27/get-xml-node-value-with-c-sharp-language/"/>
    <id>http://hutaow.com/blog/2010/04/27/get-xml-node-value-with-c-sharp-language/</id>
    <published>2010-04-27T04:43:00.000Z</published>
    <updated>2013-11-09T13:58:22.000Z</updated>
    <content type="html"><![CDATA[<p>实例说明会更清楚些，假设有如下XML文件：</p>
<figure class="highlight lang-xml"><figcaption><span>message_hutaow.xml</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="tag">&lt;<span class="title">Message version="1.0"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">Head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">Date</span>&gt;</span>20080502<span class="tag">&lt;/<span class="title">Date</span>&gt;</span>
    <span class="tag">&lt;<span class="title">Source</span>&gt;</span>
      <span class="tag">&lt;<span class="title">Address</span>&gt;</span>192.168.0.1<span class="tag">&lt;/<span class="title">Address</span>&gt;</span>
      <span class="tag">&lt;<span class="title">Name</span>&gt;</span>hutaow<span class="tag">&lt;/<span class="title">Name</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">Source</span>&gt;</span>
    <span class="tag">&lt;<span class="title">Target</span>&gt;</span>
      <span class="tag">&lt;<span class="title">Address</span>&gt;</span>192.168.0.19<span class="tag">&lt;/<span class="title">Address</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">Target</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">Head</span>&gt;</span>
<span class="tag">&lt;/<span class="title">Message</span>&gt;</span>
</pre></td></tr></table></figure>

<p>现在要读取消息源IP地址(192.168.0.1)和目的IP地址(192.168.0.19)。</p>
<a id="more"></a>

<p>根据上面XML文件的结构，查找路径为“/Message/Head/Source/Address”和“/Message/Head/Target/Address”，需要用到XPath的寻径方式，代码如下：</p>
<figure class="highlight lang-c#"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre>// 需要引用System<span class="preprocessor">.Xml</span>库
using System<span class="preprocessor">.Xml</span><span class="comment">;</span>

// 省略中间无关代码

// 加载XML文件
XmlDocument xmlDoc = new XmlDocument()<span class="comment">;</span>
xmlDoc<span class="preprocessor">.Load</span>(<span class="string">"message_hutaow.xml"</span>)<span class="comment">;</span>

// 使用XPath方式寻找源IP地址节点并输出
xmlNode = xmlDoc<span class="preprocessor">.SelectSingleNode</span>(<span class="string">"/Message/Head/Source/Address"</span>)<span class="comment">;</span>
Console<span class="preprocessor">.WriteLine</span>(<span class="string">"Source Address: {0}"</span>,xmlNode<span class="preprocessor">.InnerText</span>)<span class="comment">;</span>

// 使用XPath方式寻找目的IP地址节点并输出
xmlNode = xmlDoc<span class="preprocessor">.SelectSingleNode</span>(<span class="string">"/Message/Head/Target/Address"</span>)<span class="comment">;</span>
Console<span class="preprocessor">.WriteLine</span>(<span class="string">"Target Address: {0}"</span>,xmlNode<span class="preprocessor">.InnerText</span>)<span class="comment">;</span>
</pre></td></tr></table></figure>

<p>控制台输出<br>    Source Address: 192.168.0.1<br>    Target Address: 192.168.0.19</p>
]]></content>
    <category scheme="http://hutaow.com/blog/tags/CSharp/" term="CSharp"/>
    <category scheme="http://hutaow.com/blog/tags/XML/" term="XML"/>
    <category scheme="http://hutaow.com/blog/tags/开发/" term="开发"/>
    <category scheme="http://hutaow.com/blog/categories/Programming/" term="Programming"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Snort安装IDMEF插件]]></title>
    <link href="http://hutaow.com/blog/2010/04/21/install-idmef-plugin-for-snort/"/>
    <id>http://hutaow.com/blog/2010/04/21/install-idmef-plugin-for-snort/</id>
    <published>2010-04-21T02:48:00.000Z</published>
    <updated>2013-11-09T13:58:22.000Z</updated>
    <content type="html"><![CDATA[<p>Snort作为一款开源的入侵检测系统，可以与其它各种网络设备连接协同工作，其中IDMEF插件可以实现设备之间报警信息的共享，在安装该插件时，需要注意以下几个问题：</p>
<ol>
<li><p>IDMEF插件依赖于<a href="http://sourceforge.net/projects/libidmef" target="_blank">libidmef</a>、<a href="http://xmlsoft.org" target="_blank">libxml2</a>及<a href="http://www.ntp.org" target="_blank">libntp</a>库，所以在安装Snort之前，需要首先安装这三个库。</p>
</li>
<li><p>配置Snort时，需要加上“—enable-idmef”参数，如下所示：</p>
</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="string">.</span><span class="comment">/configure</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">enable</span>-<span class="comment">idmef</span>
<span class="comment">make</span>
<span class="comment">make</span> <span class="comment">install
</pre></td></tr></table></figure>

]]></content>
    <category scheme="http://hutaow.com/blog/tags/IDS/" term="IDS"/>
    <category scheme="http://hutaow.com/blog/tags/Snort/" term="Snort"/>
    <category scheme="http://hutaow.com/blog/tags/入侵检测/" term="入侵检测"/>
    <category scheme="http://hutaow.com/blog/categories/Security/" term="Security"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[入侵检测与响应系统的信息共享]]></title>
    <link href="http://hutaow.com/blog/2010/04/17/intrusion-dedection-and-response-system-for-information-sharing/"/>
    <id>http://hutaow.com/blog/2010/04/17/intrusion-dedection-and-response-system-for-information-sharing/</id>
    <published>2010-04-17T13:25:00.000Z</published>
    <updated>2013-11-09T13:58:22.000Z</updated>
    <content type="html"><![CDATA[<h3>引言</h3>
<p>入侵检测系统(IDS)与其它系统(如防火墙)交互过程中，需要遵循一定的规范和协议，然而生产IDS的各个厂家的报警日志及数据格式均有所区别，所以在不同设备之间交互会遇到很多麻烦。早先知道的是CheckPoint提出的OPSec协议和天融信提出的TOPSec协议，凡是遵循这两个协议的网络安全设备均可与相应的IDS进行交互，协同防护网络安全。在2007年，IETF针对这种交互情况形成了四份相关文档，分为三个部分，分别是隧道轮廓(RFC3620 - The TUNNEL Profile)、入侵检测消息交换格式和要求(RFC4765 - IDMEF, RFC4766 - IDMER)、入侵检测交换协议(RFC4767 - IDXP)。</p>
<p>值得注意的是，IETF规定IDS对其它设备交互的方式采用XML格式存储和传输，和SOAP似乎有些相似，XML跨平台跨语言结构清晰等优点使它的应用范围越来越广，几乎达到了无处不用XML的程度。</p>
<a id="more"></a>

<h3>1 入侵检测消息交互过程</h3>
<h4>1.1 建立连接</h4>
<p>使用IDXP传输数据的入侵检测实体被称为IDXP对等体。对等体只能成对出现，这些对等体通过BEEP会话中的一个或多个BEEP信道进行数据传输。对等体可能是管理器或分析器。</p>
<p>在分析器和管理器之间很可能是多对多的关系。即一个分析器可以和多个管理器通信，同样，一个管理器也可以和多个分析器通信；在不同的管理器之间也可以是多对多的关系。所以，一个管理器可以通过多个中间管理器接收大量的来自分析器的报警信息。但是，各个分析器之间禁止建立IDXP连接，避免重复报警情况的发生。</p>
<p><strong>对等体“Alice”和“Bob”建立IDXP交换的过程</strong></p>
<p>IDXP对等体之间通过打开一个BEEP信道进行通信。在打开BEEP信道之前，需要首先建立BEEP会话，然后就安全特性等问题进行协商。BEEP安全轮廓协商成功后，再经互相确认应答，然后开始IDXP交换。</p>
<pre><code><span class="comment">Alice</span>                                               <span class="comment">Bob</span>
  <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">建立连接(1)</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
&lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">问候</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
&lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">启动安全轮廓(2)</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
&lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">问候</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
&lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">启动</span> <span class="comment">IDXP(3)</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;</code></pre>
<p>交互过程:</p>
<ul>
<li>“Alice”建立一个到‘Bob’的连接, 并触发交换二者BEEP问候消息</li>
<li>两个实体协商BEEP安全轮廓</li>
<li>两个实体协商IDXP轮廓</li>
</ul>
<p><strong>对等体“Alice”和“Bob”通过代理服务器建立IDXP交换</strong></p>
<p>在一对IDXP对等体之间可以存在多个代理，这些代理可能是因为管理的需要。比如透过防火墙进行受限访问，或是将公司各部门分析器的数据转发到公司总管理器。</p>
<p>在使用代理转发数据时，会使用BEEP协调轮廓建立一个应用层的隧道。隧道轮廓(详细见“RFC3620 - The TUNNEL profile”)即在此时发挥作用。在创建应用层隧道时，必须建立一个作为协调轮廓的隧道，并且该隧道轮廓需要进行SASL认证。隧道建立完成后，BEEP安全轮廓才可以提供IDXP协商时需要的各项安全特性。</p>
<pre><code><span class="comment">Alice</span>              <span class="comment">proxy1</span>               <span class="comment">proxy2</span>               <span class="comment">Bob</span>
  <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">建立连接</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
&lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">问候</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
  <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">启动隧道</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
                      <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">建立连接(1)</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
                    &lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">问候</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
                      <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">启动隧道</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
                                           <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">建立连接</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
                                         &lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">问候</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
                                           <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">启动隧道</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
                                         &lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> &lt;<span class="comment">确认</span>&gt;<span class="comment">(2)</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>
                    &lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> &lt;<span class="comment">确认</span>&gt; <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>
&lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> &lt;<span class="comment">确认</span>&gt; <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>
&lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">问候</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
&lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">启动安全轮廓</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
&lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">问候</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;
&lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">启动</span> <span class="comment">IDXP</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;</code></pre>
<p>交互过程:</p>
<ul>
<li>收到“Alice”启动隧道的消息后，“proxy1”并没有立即返回确认消息，而是先试图和“proxy”连接以建立隧道。同样的，“proxy2”也不会立即给“proxy1”返回确认消息</li>
<li>“Bob”的确认信息首先到达“proxy2”并且与之启动隧道，然后确认消息会传递下去最终返回给“Alice”，最终“Alice”和“Bob”之间就成功建立了应用层的隧道</li>
</ul>
<h4>1.2 数据传输</h4>
<p>在一对入侵检测实体通过BEEP会话进行通信时，会使用IDXP轮廓打开一个或多个BEEP信道。如果需要，可以用IDXP轮廓建立更多的BEEP会话，以提供额外的信道。但是在多数情况下，还是应该在已有的BEEP会话中添加新的信道，尽量避免用新建BEEP会话的方式添加信道。</p>
<p>在每条信道中，对等体都是以客户端/服务器形式进行通信。客户端和服务器的角色扮演决定于建立BEEP会话的发起者和监听者。即发起者为客户端，监听者为服务器。</p>
<pre><code><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>                          <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
<span class="comment">|</span>          <span class="comment">|</span>                          <span class="comment">|</span>          <span class="comment">|</span>
<span class="comment">|</span>          <span class="comment">|********</span> <span class="comment">BEEP</span> <span class="comment">会话</span> <span class="comment">********|</span>          <span class="comment">|</span>
<span class="comment">|</span>          <span class="comment">|</span>                          <span class="comment">|</span>          <span class="comment">|</span>
<span class="comment">|</span>  <span class="comment">分析器</span>   <span class="comment">|</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">IDXP</span> <span class="comment">轮廓</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">|</span>  <span class="comment">管理器</span>   <span class="comment">|</span>
<span class="comment">|</span> <span class="comment">(客户端)</span>  <span class="comment">|</span>                          <span class="comment">|</span> <span class="comment">(服务端)</span>  <span class="comment">|</span>
<span class="comment">|</span>          <span class="comment">|</span>                          <span class="comment">|</span>          <span class="comment">|</span>
<span class="comment">|</span>          <span class="comment">|**************************|</span>          <span class="comment">|</span>
<span class="comment">|</span>          <span class="comment">|</span>                          <span class="comment">|</span>          <span class="comment">|</span>
<span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>                          <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></code></pre>
<p>在一个BEEP会话中使用多个BEEP信道的方式对IDXP对等体之间传输数据的分类和优先级的管理非常有利。例如，管理器“M1”向“M2”发送报警数据时，可以将不同类型的信息使用单独的信道进行传输。“M1”在这些信道中扮演了客户端的角色，“M2”则对接收到的报警信息根据其不同类型进行相应处理。</p>
<pre><code><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>                                            <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
<span class="comment">|</span>          <span class="comment">|</span>                                            <span class="comment">|</span>          <span class="comment">|</span>
<span class="comment">|</span>          <span class="comment">|****************</span> <span class="comment">BEEP</span> <span class="comment">会话</span> <span class="comment">******************|</span>          <span class="comment">|</span>
<span class="comment">|</span>          <span class="comment">|</span>                                            <span class="comment">|</span>          <span class="comment">|</span>
<span class="comment">|</span>          <span class="comment">|</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">IDXP</span> <span class="comment">轮廓</span>, <span class="comment">基于网络的报警信息</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">|</span>          <span class="comment">|</span>
<span class="comment">|</span>  <span class="comment">管理器</span>   <span class="comment">|</span>                                            <span class="comment">|</span>  <span class="comment">管理器</span>   <span class="comment">|</span>
<span class="comment">|</span>    <span class="comment">M1</span>    <span class="comment">|</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">IDXP</span> <span class="comment">轮廓</span>, <span class="comment">基于主机的报警信息</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">|</span>    <span class="comment">M2</span>    <span class="comment">|</span>
<span class="comment">|</span> <span class="comment">(客户端)</span>  <span class="comment">|</span>                                            <span class="comment">|</span> <span class="comment">(服务端)</span>  <span class="comment">|</span>
<span class="comment">|</span>          <span class="comment">|</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">IDXP</span> <span class="comment">轮廓</span>, <span class="comment">其它报警信息</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">|</span>          <span class="comment">|</span>
<span class="comment">|</span>          <span class="comment">|</span>                                            <span class="comment">|</span>          <span class="comment">|</span>
<span class="comment">|</span>          <span class="comment">|********************************************|</span>          <span class="comment">|</span>
<span class="comment">|</span>          <span class="comment">|</span>                                            <span class="comment">|</span>          <span class="comment">|</span>
<span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>                                            <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></code></pre>
<h4>1.3 断开连接</h4>
<p>在一些情况下(如处理过程中出现错误)，IDXP对等体可以关闭某个IDXP信道。要关闭某条信道，需要在零号信道上发送一条“关闭”的指令，并且指明所关闭的信道。如果想要关闭整个BEEP会话，只需在零号信道上发送一条要求“关闭”零信道的指令即可。</p>
<p>由于应用层隧道和BEEP安全轮廓会经常使用，所以凡是包含IDXP信道的BEEP会话将会一直存活下去。同时，为了避免IDXP信道被反复的建立，系统会一直保持这些IDXP信道的连接，即使当前已经没有数据在上面传输。建议当IDXP对等体在合适的时候，手动关闭并重建BEEP会话。</p>
<h4>1.4 可信模型</h4>
<p>在以上的模型中，BEEP安全轮廓是建立在IDXP对等体之间从而实现的端到端安全，而无需对中间代理建立信任。因此，只有在安全轮廓下经过协商后的IDXP对等体之间是相互信任的，而代理始终被看作是不可信的。</p>
<h3>2 入侵检测消息交换格式</h3>
<h4>2.1 IDMEF数据模型</h4>
<p>IDMEF数据模型的各主要部分关系如下图所示（这里省略了事件指示器和属性）。<br><img src="/images/articles/201004/intrusion_dedection_and_response_system_for_information_sharing.png" alt="数据模型"></p>
<p>IDMEF消息的最高层类是“IDMEF-Message”，其它各类型消息都是该类的子类。目前IDMEF定义了两种消息：“Alerts”和“Heartbeats”。其中这两个消息各自携带不同的子类，各子类又描述了更加详细的信息。</p>
<p>需要注意的是，数据模型并没有指明警报信息如何分类和识别。例如，端口扫描这一行为，它可能被分析器识别为一次单点对多目标的攻击，同时被另一分析器识别为多次的单点攻击。所有，只有在分析器确定了报警类型之后，数据模型才能确定如何对报警数据进行格式化。</p>
<h4>2.2 示例</h4>
<p>IDMEF数据模型最终是以XML形式实现，XML跨平台、跨语言以及强扩展性的特点保证了IDS设备之间共享信息时良好的兼容性。</p>
<p>下面用实例说明IDMEF对报警信息封装的格式。这些例子只是为说明用，不具备代表性。</p>
<figure class="highlight lang-xml"><figcaption><span>基于网络检测到的某次泪滴攻击报警信息</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="code"><pre><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
   <span class="tag">&lt;<span class="title">idmef:IDMEF-Message</span> <span class="attribute">xmlns:idmef</span>=<span class="value">"http://iana.org/idmef"</span> <span class="attribute">version</span>=<span class="value">"1.0"</span>&gt;</span>
     <span class="tag">&lt;<span class="title">idmef:Alert</span> <span class="attribute">messageid</span>=<span class="value">"abc123456789"</span>&gt;</span>
       <span class="tag">&lt;<span class="title">idmef:Analyzer</span> <span class="attribute">analyzerid</span>=<span class="value">"hq-dmz-analyzer01"</span>&gt;</span>
         <span class="tag">&lt;<span class="title">idmef:Node</span> <span class="attribute">category</span>=<span class="value">"dns"</span>&gt;</span>
           <span class="tag">&lt;<span class="title">idmef:location</span>&gt;</span>Headquarters DMZ Network<span class="tag">&lt;/<span class="title">idmef:location</span>&gt;</span>
           <span class="tag">&lt;<span class="title">idmef:name</span>&gt;</span>analyzer01.example.com<span class="tag">&lt;/<span class="title">idmef:name</span>&gt;</span>
         <span class="tag">&lt;/<span class="title">idmef:Node</span>&gt;</span>
       <span class="tag">&lt;/<span class="title">idmef:Analyzer</span>&gt;</span>
       <span class="tag">&lt;<span class="title">idmef:CreateTime</span> <span class="attribute">ntpstamp</span>=<span class="value">"0xbc723b45.0xef449129"</span>&gt;</span>
         2000-03-09T10:01:25.93464-05:00
       <span class="tag">&lt;/<span class="title">idmef:CreateTime</span>&gt;</span>
       <span class="tag">&lt;<span class="title">idmef:Source</span> <span class="attribute">ident</span>=<span class="value">"a1b2c3d4"</span>&gt;</span>
         <span class="tag">&lt;<span class="title">idmef:Node</span> <span class="attribute">ident</span>=<span class="value">"a1b2c3d4-001"</span> <span class="attribute">category</span>=<span class="value">"dns"</span>&gt;</span>
           <span class="tag">&lt;<span class="title">idmef:name</span>&gt;</span>badguy.example.net<span class="tag">&lt;/<span class="title">idmef:name</span>&gt;</span>
           <span class="tag">&lt;<span class="title">idmef:Address</span> <span class="attribute">ident</span>=<span class="value">"a1b2c3d4-002"</span> <span class="attribute">category</span>=<span class="value">"ipv4-net-mask"</span>&gt;</span>
             <span class="tag">&lt;<span class="title">idmef:address</span>&gt;</span>192.0.2.50<span class="tag">&lt;/<span class="title">idmef:address</span>&gt;</span>
             <span class="tag">&lt;<span class="title">idmef:netmask</span>&gt;</span>255.255.255.255<span class="tag">&lt;/<span class="title">idmef:netmask</span>&gt;</span>
           <span class="tag">&lt;/<span class="title">idmef:Address</span>&gt;</span>
         <span class="tag">&lt;/<span class="title">idmef:Node</span>&gt;</span>
       <span class="tag">&lt;/<span class="title">idmef:Source</span>&gt;</span>
       <span class="tag">&lt;<span class="title">idmef:Target</span> <span class="attribute">ident</span>=<span class="value">"d1c2b3a4"</span>&gt;</span>
         <span class="tag">&lt;<span class="title">idmef:Node</span> <span class="attribute">ident</span>=<span class="value">"d1c2b3a4-001"</span> <span class="attribute">category</span>=<span class="value">"dns"</span>&gt;</span>
           <span class="tag">&lt;<span class="title">idmef:Address</span> <span class="attribute">category</span>=<span class="value">"ipv4-addr-hex"</span>&gt;</span>
             <span class="tag">&lt;<span class="title">idmef:address</span>&gt;</span>0xde796f70<span class="tag">&lt;/<span class="title">idmef:address</span>&gt;</span>
           <span class="tag">&lt;/<span class="title">idmef:Address</span>&gt;</span>
         <span class="tag">&lt;/<span class="title">idmef:Node</span>&gt;</span>
       <span class="tag">&lt;/<span class="title">idmef:Target</span>&gt;</span>
       <span class="tag">&lt;<span class="title">idmef:Classification</span> <span class="attribute">text</span>=<span class="value">"Teardrop detected"</span>&gt;</span>
         <span class="tag">&lt;<span class="title">idmef:Reference</span> <span class="attribute">origin</span>=<span class="value">"bugtraqid"</span>&gt;</span>
           <span class="tag">&lt;<span class="title">idmef:name</span>&gt;</span>124<span class="tag">&lt;/<span class="title">idmef:name</span>&gt;</span>
           <span class="tag">&lt;<span class="title">idmef:url</span>&gt;</span>http://www.securityfocus.com/bid/124<span class="tag">&lt;/<span class="title">idmef:url</span>&gt;</span>
         <span class="tag">&lt;/<span class="title">idmef:Reference</span>&gt;</span>
       <span class="tag">&lt;/<span class="title">idmef:Classification</span>&gt;</span>
     <span class="tag">&lt;/<span class="title">idmef:Alert</span>&gt;</span>
   <span class="tag">&lt;/<span class="title">idmef:IDMEF-Message</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight lang-xml"><figcaption><span>基于网络检测到的某个端口扫描行为（注意<portlist>中记录了被扫描的端口列表）</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
   <span class="tag">&lt;<span class="title">idmef:IDMEF-Message version="1.0"</span> <span class="attribute">xmlns:idmef</span>=<span class="value">"http://iana.org/idmef"</span>&gt;</span>
     <span class="tag">&lt;<span class="title">idmef:Alert</span> <span class="attribute">messageid</span>=<span class="value">"abc123456789"</span>&gt;</span>
       <span class="tag">&lt;<span class="title">idmef:Analyzer</span> <span class="attribute">analyzerid</span>=<span class="value">"hq-dmz-analyzer62"</span>&gt;</span>
         <span class="tag">&lt;<span class="title">idmef:Node</span> <span class="attribute">category</span>=<span class="value">"dns"</span>&gt;</span>
           <span class="tag">&lt;<span class="title">idmef:location</span>&gt;</span>Headquarters Web Server<span class="tag">&lt;/<span class="title">idmef:location</span>&gt;</span>
           <span class="tag">&lt;<span class="title">idmef:name</span>&gt;</span>analyzer62.example.com<span class="tag">&lt;/<span class="title">idmef:name</span>&gt;</span>
         <span class="tag">&lt;/<span class="title">idmef:Node</span>&gt;</span>
       <span class="tag">&lt;/<span class="title">idmef:Analyzer</span>&gt;</span>
       <span class="tag">&lt;<span class="title">idmef:CreateTime</span> <span class="attribute">ntpstamp</span>=<span class="value">"0xbc72b2b4.0x00000000"</span>&gt;</span>
         2000-03-09T15:31:00-08:00
       <span class="tag">&lt;/<span class="title">idmef:CreateTime</span>&gt;</span>
       <span class="tag">&lt;<span class="title">idmef:Source</span> <span class="attribute">ident</span>=<span class="value">"abc01"</span>&gt;</span>
         <span class="tag">&lt;<span class="title">idmef:Node</span> <span class="attribute">ident</span>=<span class="value">"abc01-01"</span>&gt;</span>
           <span class="tag">&lt;<span class="title">idmef:Address</span> <span class="attribute">ident</span>=<span class="value">"abc01-02"</span> <span class="attribute">category</span>=<span class="value">"ipv4-addr"</span>&gt;</span>
             <span class="tag">&lt;<span class="title">idmef:address</span>&gt;</span>192.0.2.200<span class="tag">&lt;/<span class="title">idmef:address</span>&gt;</span>
           <span class="tag">&lt;/<span class="title">idmef:Address</span>&gt;</span>
         <span class="tag">&lt;/<span class="title">idmef:Node</span>&gt;</span>
       <span class="tag">&lt;/<span class="title">idmef:Source</span>&gt;</span>
       <span class="tag">&lt;<span class="title">idmef:Target</span> <span class="attribute">ident</span>=<span class="value">"def01"</span>&gt;</span>
         <span class="tag">&lt;<span class="title">idmef:Node</span> <span class="attribute">ident</span>=<span class="value">"def01-01"</span> <span class="attribute">category</span>=<span class="value">"dns"</span>&gt;</span>
           <span class="tag">&lt;<span class="title">idmef:name</span>&gt;</span>www.example.com<span class="tag">&lt;/<span class="title">idmef:name</span>&gt;</span>
           <span class="tag">&lt;<span class="title">idmef:Address</span> <span class="attribute">ident</span>=<span class="value">"def01-02"</span> <span class="attribute">category</span>=<span class="value">"ipv4-addr"</span>&gt;</span>
             <span class="tag">&lt;<span class="title">idmef:address</span>&gt;</span>192.0.2.50<span class="tag">&lt;/<span class="title">idmef:address</span>&gt;</span>
           <span class="tag">&lt;/<span class="title">idmef:Address</span>&gt;</span>
         <span class="tag">&lt;/<span class="title">idmef:Node</span>&gt;</span>
         <span class="tag">&lt;<span class="title">idmef:Service</span> <span class="attribute">ident</span>=<span class="value">"def01-03"</span>&gt;</span>
           <span class="tag">&lt;<span class="title">idmef:portlist</span>&gt;</span>5-25,37,42,43,53,69-119,123-514
           <span class="tag">&lt;/<span class="title">idmef:portlist</span>&gt;</span>
         <span class="tag">&lt;/<span class="title">idmef:Service</span>&gt;</span>
       <span class="tag">&lt;/<span class="title">idmef:Target</span>&gt;</span>
       <span class="tag">&lt;<span class="title">idmef:Classification</span> <span class="attribute">text</span>=<span class="value">"simple portscan"</span>&gt;</span>
         <span class="tag">&lt;<span class="title">idmef:Reference</span> <span class="attribute">origin</span>=<span class="value">"vendor-specific"</span>&gt;</span>
           <span class="tag">&lt;<span class="title">idmef:name</span>&gt;</span>portscan<span class="tag">&lt;/<span class="title">idmef:name</span>&gt;</span>
           <span class="tag">&lt;<span class="title">idmef:url</span>&gt;</span>http://www.vendor.com/portscan<span class="tag">&lt;/<span class="title">idmef:url</span>&gt;</span>
         <span class="tag">&lt;/<span class="title">idmef:Reference</span>&gt;</span>
       <span class="tag">&lt;/<span class="title">idmef:Classification</span>&gt;</span>
     <span class="tag">&lt;/<span class="title">idmef:Alert</span>&gt;</span>
   <span class="tag">&lt;/<span class="title">idmef:IDMEF-Message</span>&gt;</span>
</pre></td></tr></table></figure>

<h3>3 参考资料</h3>
<pre><code><span class="comment">1</span>. <span class="comment">RFC4765</span> <span class="literal">-</span> <span class="comment">The</span> <span class="comment">Intrusion</span> <span class="comment">Detection</span> <span class="comment">Message</span> <span class="comment">Exchange</span> <span class="comment">Format</span> <span class="comment">(IDMEF)</span>
<span class="comment">2</span>. <span class="comment">RFC4767</span> <span class="literal">-</span> <span class="comment">The</span> <span class="comment">Intrusion</span> <span class="comment">Detection</span> <span class="comment">Exchange</span> <span class="comment">Protocol</span> <span class="comment">(IDXP)</code></pre>
]]></content>
    <category scheme="http://hutaow.com/blog/tags/IDS/" term="IDS"/>
    <category scheme="http://hutaow.com/blog/tags/入侵检测/" term="入侵检测"/>
    <category scheme="http://hutaow.com/blog/categories/Security/" term="Security"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[字符串中单词逆序的实现]]></title>
    <link href="http://hutaow.com/blog/2010/04/13/reverse-order-of-words-in-a-string/"/>
    <id>http://hutaow.com/blog/2010/04/13/reverse-order-of-words-in-a-string/</id>
    <published>2010-04-13T11:35:00.000Z</published>
    <updated>2013-11-09T13:58:22.000Z</updated>
    <content type="html"><![CDATA[<p>在Java中可以用压栈/弹栈的方式：</p>
<a id="more"></a>

<figure class="highlight lang-java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">import</span> java.util.Stack;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTest</span> {</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String argv[]) {
        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;String&gt;();
        <span class="keyword">for</span>(String s : <span class="string">"I have a round peach"</span>.split(<span class="string">" "</span>)) {
            <span class="comment">// 按字符串原顺序压栈</span>
            stack.push(s);
        }

        <span class="keyword">while</span>(!stack.empty()) {
            <span class="comment">// 弹栈并输出</span>
            System.out.print(stack.pop() + <span class="string">" "</span>);
        }
    }
}
</pre></td></tr></table></figure>

<p>运行后系统将输出 “peach round a have I ”。</p>
]]></content>
    <category scheme="http://hutaow.com/blog/tags/Java/" term="Java"/>
    <category scheme="http://hutaow.com/blog/tags/开发/" term="开发"/>
    <category scheme="http://hutaow.com/blog/categories/Programming/" term="Programming"/>
  </entry>
</feed>
