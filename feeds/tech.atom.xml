<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>胡桃夹子</title><link href="http://hutaow.com/" rel="alternate"></link><link href="http://hutaow.com/feeds/tech.atom.xml" rel="self"></link><id>http://hutaow.com/</id><updated>2014-08-28T01:08:03+08:00</updated><entry><title>Linux中查看进程占用内存的情况</title><link href="http://hutaow.com/blog/2014/08/28/display-process-memory-in-linux" rel="alternate"></link><updated>2014-08-28T01:08:03+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2014-08-28:blog/2014/08/28/display-process-memory-in-linux</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;Linux中查看某个进程占用内存的情况，执行如下命令即可，将其中的[pid]替换成相应进程的PID号：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shell
cat /proc/[pid]/status&lt;/code&gt;&lt;/p&gt;
&lt;h4 id="_1"&gt;说明&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;/proc/[pid]/status&lt;/code&gt;中所保存的信息除了内存信息，还包括进程IDs、信号等信息，此处暂时只介绍内存相关的信息。&lt;/p&gt;
&lt;p&gt;字段        |说明
------------|------------
VmPeak      |进程所使用的虚拟内存的峰值
VmSize      |进程当前使用的虚拟内存的大小
VmLck       |已经锁住的物理内存的大小（锁住的物理内存不能交换到硬盘）
VmHWM       |进程所使用的物理内存的峰值
VmRSS       |进程当前使用的物理内存的大小
VmData      |进程占用的数据段大小
VmStk       |进程占用的栈大小
VmExe       |进程占用的代码段大小（不包括库）
VmLib       |进程所加载的动态库所占用的内存大小（可能与其它进程共享）
VmPTE       |进程占用的页表大小（交换表项数量）
VmSwap      |进程所使用的交换区的大小&lt;/p&gt;
&lt;h4 id="_2"&gt;举例&lt;/h4&gt;
&lt;p&gt;显示进程&lt;code&gt;cron&lt;/code&gt;的内存信息，通过&lt;code&gt;pidof cron&lt;/code&gt;获取进程ID，或者通过&lt;code&gt;ps -aux | grep cron&lt;/code&gt;查找进程ID。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shell
$ cat /proc/1161/status
Name:   cron
State:  S (sleeping)
Tgid:   1161
Ngid:   0
Pid:    1161
PPid:   1
TracerPid:  0
Uid:    0   0   0   0
Gid:    0   0   0   0
FDSize: 64
Groups: 0 
VmPeak:    23792 kB
VmSize:    23656 kB
VmLck:         0 kB
VmPin:         0 kB
VmHWM:      1040 kB
VmRSS:      1004 kB
VmData:      260 kB
VmStk:       136 kB
VmExe:        40 kB
VmLib:      2668 kB
VmPTE:        72 kB
VmSwap:        0 kB
Threads:    1
SigQ:   0/15442
SigPnd: 0000000000000000
ShdPnd: 0000000000000000
SigBlk: 0000000000000000
SigIgn: 0000000000000000
SigCgt: 0000000000010001
CapInh: 0000000000000000
CapPrm: 0000001fffffffff
CapEff: 0000001fffffffff
CapBnd: 0000001fffffffff
Seccomp:    0
Cpus_allowed:   3
Cpus_allowed_list:  0-1
Mems_allowed:   00000000,00000001
Mems_allowed_list:  0
voluntary_ctxt_switches:    151
nonvoluntary_ctxt_switches: 0&lt;/code&gt;&lt;/p&gt;</summary><category term="Linux"></category><category term="内存"></category></entry><entry><title>德赛西威音乐e栈的破解程序</title><link href="http://hutaow.com/blog/2014/08/02/svautomusic-cracker" rel="alternate"></link><updated>2014-08-02T00:07:19+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2014-08-02:blog/2014/08/02/svautomusic-cracker</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;技术细节请参考上一篇文章&lt;a href="/blog/2014/08/01/cracking-svautomusic/"&gt;《一种伪造服务器骗过某导航的音乐服务，从而延长有效期的方法》&lt;/a&gt;。根据原理用python+qt写了个现成的破解程序，界面简陋了些，下载链接及使用说明如下。&lt;/p&gt;
&lt;h4 id="_1"&gt;下载链接&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://dl.vmall.com/c073qryv48"&gt;华为网盘&lt;/a&gt;，&lt;a href="http://pan.baidu.com/s/1sjPRMvN"&gt;百度网盘&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;

&lt;h4 id="_2"&gt;使用说明&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;TF卡或U盘先在车机上初始化，然后插入电脑，打开音乐e栈PC端。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用管理员身份运行程序。&lt;/p&gt;
&lt;p&gt;&lt;img alt="管理员身份运行程序" src="/images/articles/201408/svautomusic_cracker_runas_administrator.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击“Start Crack!”按钮。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Start Crack" src="/images/articles/201408/svautomusic_cracker_start_crack.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在音乐e栈客户端上，打开充值界面，卡号密码随便填。&lt;/p&gt;
&lt;p&gt;&lt;img alt="充值界面" src="/images/articles/201408/svautomusic_cracker_charge.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击确定，不出意外的话，即会提示充值成功，并且服务有效期也延长了99天。&lt;/p&gt;
&lt;p&gt;&lt;img alt="充值成功" src="/images/articles/201408/svautomusic_cracker_success.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以随意下载电台或专辑了，并且可以同步到车上随时听了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="破解结果" src="/images/articles/201408/svautomusic_cracker_result.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为音乐e栈每次启动都会联网认证一次，所以这个破解程序每次打开客户端都需要执行一下上面的动作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="_3"&gt;更新记录&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;2014-08-01: 初始化。&lt;/li&gt;
&lt;li&gt;2014-08-24: 有效期从99天延长到999天，另外补充设置响应消息长度值，防止客户端由于处理字符串不当导致出错。&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Security"></category><category term="Cracker"></category><category term="音乐e栈"></category><category term="德赛西威"></category></entry><entry><title>一种伪造服务器骗过某导航的音乐服务，从而延长有效期的方法</title><link href="http://hutaow.com/blog/2014/08/01/cracking-svautomusic" rel="alternate"></link><updated>2014-08-01T23:50:27+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2014-08-01:blog/2014/08/01/cracking-svautomusic</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;某导航提供的音乐服务（音乐e栈），和虾米合作的，需要付费使用，前段时间本来想上网搜个破解版，结果没搜到，索性自已分析了一下它的交互方式，找出了个通过充值认证来延长服务有效期的方法。方法本身不复杂，主要是因为它的认证机制略显简陋，本文主要从技术角度来说明过程，仅供参考学习。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;h4 id="1"&gt;1 原始界面&lt;/h4&gt;
&lt;p&gt;&lt;img alt="音乐e栈服务过期" src="/images/articles/201408/cracking_svautomusic_service_expired.png" /&gt;&lt;/p&gt;
&lt;p&gt;如上图，插入经过车机初始化过的TF卡后，启动音乐e栈客户端，显示当前服务有效期为0天，并提示需要充值续费。如果点击下载专辑的按钮，提示不允许下载。&lt;/p&gt;
&lt;h4 id="2"&gt;2 寻找入手点&lt;/h4&gt;
&lt;p&gt;既然提示让续费，那就看看续费过程是什么样子。&lt;/p&gt;
&lt;p&gt;先随便输个卡号密码试试：&lt;/p&gt;
&lt;p&gt;&lt;img alt="充值卡无效" src="/images/articles/201408/cracking_svautomusic_paid_invalid.png" /&gt;&lt;/p&gt;
&lt;p&gt;竟然用CS架构来做充值认证，实在是土的掉渣，就从这里入手了。&lt;/p&gt;
&lt;h4 id="3"&gt;3 交互过程&lt;/h4&gt;
&lt;p&gt;把刚才进行充值时的报文用Wireshark抓下来，看看它是如何交互的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1) 报文&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="充值失败的报文" src="/images/articles/201408/cracking_svautomusic_pcap_paid_failed.png" /&gt;&lt;/p&gt;
&lt;p&gt;可以看到，充值认证的流量走的是TCP协议8080端口，对端连接的服务器地址是&lt;code&gt;42.156.140.44&lt;/code&gt;，这个暂时放一边，先来看看请求和响应报文分别填了什么内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2) 请求消息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="请求消息内容" src="/images/articles/201408/cracking_svautomusic_pcap_paid_request.png" /&gt;&lt;/p&gt;
&lt;p&gt;上图中可以看到，充值请求消息虽然走的是8080端口，但实际内容并非HTTP协议。&lt;/p&gt;
&lt;p&gt;TCP负载的开头44个字节是一段二进制数据，估计是发送充值消息的结构体头，这里我们不关心；接下来就一段xml格式的内容，其中xml内容直接是用明文传输，并且单词基本都在四级词汇范围内，可以清楚的看到它发送了车载设备的ID号、服务剩余天数，以及刚才输入的充值的卡号、密码等信息。&lt;/p&gt;
&lt;p&gt;因为这个是请求消息，不需要对它关注太多，下面来看看服务的响应消息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3) 响应消息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="响应消息内容" src="/images/articles/201408/cracking_svautomusic_pcap_paid_response.png" /&gt;&lt;/p&gt;
&lt;p&gt;可以看出，响应消息和请求消息的格式基本一样，follow一把看的更清楚些：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Follow Stream" src="/images/articles/201408/cracking_svautomusic_pcap_follow_stream.png" /&gt;&lt;/p&gt;
&lt;p&gt;注意响应消息xml中的&lt;code&gt;result&lt;/code&gt;和&lt;code&gt;remain_days&lt;/code&gt;字段，可以看到&lt;code&gt;result&lt;/code&gt;字段的值为&lt;code&gt;102&lt;/code&gt;，该值为充值的返回值；另外一个&lt;code&gt;remain_days&lt;/code&gt;值为&lt;code&gt;0&lt;/code&gt;，它便是服务器认证后的有效时间。&lt;/p&gt;
&lt;h4 id="4"&gt;4 思路&lt;/h4&gt;
&lt;p&gt;从上面的报文分析，充值的交互其实是简单的一请求加一响应消息，客户端将车载设备的ID及充值卡号、密码发送给服务器，然后服务器校验认证充值卡是否有效，然后返回充值结果，并且将充值后的有效期也带给客户端。&lt;/p&gt;
&lt;p&gt;可以想到，通过伪造一个认证服务器，当充值的时候，让客户端去连接伪造的服务器，然后服务器返回充值成功的消息，即有可能骗过客户端认为充值成功。&lt;/p&gt;
&lt;p&gt;伪造过程中所需要的服务器成功消息，可以尝试通过修改上面抓包内容来构造。&lt;/p&gt;
&lt;h4 id="5"&gt;5 主机重定向&lt;/h4&gt;
&lt;p&gt;前面3.2节中提到到过，客户端所连接的服务器地址是&lt;code&gt;42.156.140.44&lt;/code&gt;，相信不会有人把IP直接写死在代码里的，起码是个域名，那一定会发DNS请求，DNS解析结果会缓存在主机上，执行一下下面的命令，来看看当前Windows主机上的DNS缓存列表：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ipconfig /displaydns&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从列表里搜索IP地址，找到如下信息：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;s2.xiami.com
    ----------------------------------------
    记录名称. . . . . . . : s2.xiami.com
    记录类型. . . . . . . : 1
    生存时间. . . . . . . : 50
    数据长度. . . . . . . : 4
    部分. . . . . . . . . : 答案
    A (主机)记录  . . . . : 42.156.140.44&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;看来域名就是&lt;code&gt;s2.xiami.com&lt;/code&gt;了，修改Windows的hosts文件（&lt;code&gt;%windir%\system32\drivers\etc\hosts&lt;/code&gt;）中添加下面一条关联项，将&lt;code&gt;s2.xiami.com&lt;/code&gt;指向伪造的服务器（这里直接使用本机环回地址）：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;127.0.0.1 s2.xiami.com&lt;/code&gt;&lt;/p&gt;
&lt;h4 id="6"&gt;6 伪造服务器&lt;/h4&gt;
&lt;p&gt;伪造服务器越简单越好，直接用Python写个TCP的服务器，只要有客户端连接发消息（假设只有目标程序会连接，也不用管发的是什么消息），就直接返回伪造好的内容。&lt;/p&gt;
&lt;p&gt;代码如下所示，服务器响应的数据先从真实服务器的TCP负载拷贝过来：&lt;/p&gt;
&lt;p&gt;&lt;img alt="伪造服务器代码" src="/images/articles/201408/cracking_svautomusic_code.png" /&gt;&lt;/p&gt;
&lt;h4 id="7"&gt;7 响应消息&lt;/h4&gt;
&lt;p&gt;服务器正常工作了，下面开始修改响应消息，想办法骗过客户端认为充值成功。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1) 修改响应码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先从响应码（&lt;code&gt;result&lt;/code&gt;）开始，原始值是&lt;code&gt;102&lt;/code&gt;，先减1试试&lt;code&gt;101&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img alt="伪造服务器响应101" src="/images/articles/201408/cracking_svautomusic_code_result_101.png" /&gt;&lt;/p&gt;
&lt;p&gt;进行充值操作，看看客户端收到后是什么情况：&lt;/p&gt;
&lt;p&gt;&lt;img alt="充值卡已被使用" src="/images/articles/201408/cracking_svautomusic_result_101.png" /&gt;&lt;/p&gt;
&lt;p&gt;如上图，提示信息变成了“该卡已被使用过”，看来方向是对的，再改成&lt;code&gt;100&lt;/code&gt;看看：&lt;/p&gt;
&lt;p&gt;&lt;img alt="伪造服务器响应100" src="/images/articles/201408/cracking_svautomusic_code_result_100.png" /&gt;&lt;/p&gt;
&lt;p&gt;执行充值操作：&lt;/p&gt;
&lt;p&gt;&lt;img alt="客户端充值成功" src="/images/articles/201408/cracking_svautomusic_result_100.png" /&gt;&lt;/p&gt;
&lt;p&gt;如上图，客户端提示“账户充值成功！”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2) 修改有效时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然提示充值成功，但是有效期还是显示0天，下面把&lt;code&gt;remain_days&lt;/code&gt;改成&lt;code&gt;99&lt;/code&gt;试下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="伪造服务器响应100并且有效期99天" src="/images/articles/201408/cracking_svautomusic_code_result_100_remain_99.png" /&gt;&lt;/p&gt;
&lt;p&gt;再试下充值操作：&lt;/p&gt;
&lt;p&gt;&lt;img alt="客户端充值成功并且有效期延长99天" src="/images/articles/201408/cracking_svautomusic_result_100_remain_99.png" /&gt;&lt;/p&gt;
&lt;p&gt;可以看到，充值成功，并且有效期也变成了99天。&lt;/p&gt;
&lt;h4 id="8"&gt;8 检验结果&lt;/h4&gt;
&lt;p&gt;随便选择一张专辑下载，可以发现已经可以随意下载了：&lt;/p&gt;
&lt;p&gt;&lt;img alt="成功下载专辑" src="/images/articles/201408/cracking_svautomusic_downloading.png" /&gt;&lt;/p&gt;
&lt;p&gt;下载完成后同步到车载设备上，可以发现车载设备上显示的服务有效期也被延长了99天：&lt;/p&gt;
&lt;p&gt;&lt;img alt="车载服务有效期" src="/images/articles/201408/cracking_svautomusic_car.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;另外补充一句，充值显示成功后，还需要把hosts恢复回去，因为后面的专辑下载等操作还需要连接真实的服务器。&lt;/p&gt;
&lt;h4 id="9"&gt;9 后记&lt;/h4&gt;
&lt;p&gt;后来发现其实都不用等到充值那一步再伪造服务器，其实在软件启动的时候就向服务器发送过认证请求，直接在那一步处理的话使用会更方便些，不过反正是能任意续期了，就先这样吧。&lt;/p&gt;
&lt;p&gt;这个问题有几次联系过厂家说明情况，但都没有答复，从上次发布版本的时间来看，估计已经一年多没有维护了，这里把方法公开出来，仅供学习参考，有兴趣的可以自己试下。&lt;/p&gt;</summary><category term="Security"></category><category term="Python"></category><category term="音乐e栈"></category><category term="德赛西威"></category><category term="虾米音乐"></category></entry><entry><title>限制用户登陆Linux的时间</title><link href="http://hutaow.com/blog/2014/06/13/restrict-user-login-linux-time" rel="alternate"></link><updated>2014-06-13T22:50:12+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2014-06-13:blog/2014/06/13/restrict-user-login-linux-time</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;只允许某用户8:00-12:00登陆，用简单粗暴的方式实现。&lt;/p&gt;
&lt;p&gt;设置个定时任务（执行&lt;code&gt;crontab -e&lt;/code&gt;编辑任务列表）：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0 8 * * * passwd -u username
0 12 * * * passwd -l username&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;username&lt;/code&gt;替换成想限制的用户名；命令&lt;code&gt;passwd -u&lt;/code&gt;是锁定用户，&lt;code&gt;passwd -l&lt;/code&gt;解锁。&lt;/p&gt;
&lt;p&gt;附：设置cron定时任务列表的格式：&lt;code&gt;分 时 日 月 星期 命令&lt;/code&gt;，如果时间字段是&lt;code&gt;*&lt;/code&gt;则表示所有，还可以加上&lt;code&gt;/n&lt;/code&gt;表示每隔n个单位时间执行一次；最后跟需要执行的命令。&lt;/p&gt;</summary><category term="Linux"></category><category term="cron"></category></entry><entry><title>删除Git的提交记录</title><link href="http://hutaow.com/blog/2014/06/02/undo-commits-permanently-in-git" rel="alternate"></link><updated>2014-06-02T15:38:56+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2014-06-02:blog/2014/06/02/undo-commits-permanently-in-git</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;不小心提交了错误的代码到库上，想要删除最近一次提交的所有信息（包括代码和日志）。&lt;/p&gt;
&lt;p&gt;删除最后一次的提交记录：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bash
git reset --hard HEAD^&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;删除最后3次的提交记录：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bash
git reset --hard HEAD~3&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;已经提交到远端库上了？那就还需要将本地库强行同步到远端库上（注意执行这个命令前先检查一下有没有别人的提交记录，不然会覆盖他人的修改）：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;base
git push --force&lt;/code&gt;&lt;/p&gt;</summary><category term="Git"></category></entry><entry><title>基于libpcap的开发实例</title><link href="http://hutaow.com/blog/2014/05/29/libpcap-based-development" rel="alternate"></link><updated>2014-05-29T23:25:19+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2014-05-29:blog/2014/05/29/libpcap-based-development</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;libpcap是Unix/Linux平台中用于网络数据包捕获的函数库（Windows版本为winpcap）。本文通过实例来说明其使用方法。&lt;/p&gt;
&lt;h3 id="1-libpcap"&gt;1 安装libpcap库&lt;/h3&gt;
&lt;p&gt;从&lt;a href="http://www.tcpdump.org"&gt;TCPDUMP&lt;/a&gt;官网下载最新的libpcap源代码，解压到本地后，编译并安装即可，注意安装时需要使用root权限。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bash
./configure
make
make install&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="2"&gt;2 实例代码&lt;/h3&gt;
&lt;p&gt;代码完成的功能是抓取指定网卡的数据包，并将数据交给回调函数处理（这里回调函数只是打了个桩，没有做实质性的处理）。&lt;/p&gt;
&lt;p&gt;首先定义一个基本类型的头文件（basetype.h），将数据类型封装一下：&lt;/p&gt;
&lt;p&gt;``` c&lt;/p&gt;
&lt;h1 id="ifndef-basetype_h"&gt;ifndef &lt;em&gt;BASETYPE_H&lt;/em&gt;&lt;/h1&gt;
&lt;h1 id="define-basetype_h"&gt;define &lt;em&gt;BASETYPE_H&lt;/em&gt;&lt;/h1&gt;
&lt;h1 id="define-ok-0"&gt;define OK (0)&lt;/h1&gt;
&lt;h1 id="define-error-1"&gt;define ERROR (1)&lt;/h1&gt;
&lt;h1 id="define-yes-1"&gt;define YES (1)&lt;/h1&gt;
&lt;h1 id="define-no-0"&gt;define NO (0)&lt;/h1&gt;
&lt;p&gt;typedef void VOID;&lt;/p&gt;
&lt;p&gt;typedef char CHAR;
typedef char INT8;
typedef short INT16;
typedef int INT32;
typedef long long INT64;
typedef long LONG;&lt;/p&gt;
&lt;p&gt;typedef unsigned char UCHAR;
typedef unsigned char UINT8;
typedef unsigned short UINT16;
typedef unsigned int UINT32;
typedef unsigned long long UINT64;
typedef unsigned long ULONG;&lt;/p&gt;
&lt;h1 id="define-debug_infofmt-printfinfo-fmtrn-va_args"&gt;define DEBUG_INFO(fmt, ...) printf("[Info] "fmt"\r\n", ##&lt;strong&gt;VA_ARGS&lt;/strong&gt;)&lt;/h1&gt;
&lt;h1 id="define-debug_eventfmt-printfevent-fmtrn-va_args"&gt;define DEBUG_EVENT(fmt, ...) printf("[Event] "fmt"\r\n", ##&lt;strong&gt;VA_ARGS&lt;/strong&gt;)&lt;/h1&gt;
&lt;h1 id="define-debug_errorfmt-printferror-fmtrn-va_args"&gt;define DEBUG_ERROR(fmt, ...) printf("[Error] "fmt"\r\n", ##&lt;strong&gt;VA_ARGS&lt;/strong&gt;)&lt;/h1&gt;
&lt;h1 id="endif-_basetype_h__"&gt;endif /&lt;em&gt; _BASETYPE_H__ &lt;/em&gt;/&lt;/h1&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;p&gt;接下来是源文件（traffic.c），libpcap的接口调用过程都在这里，具体说明可以参考代码注释：&lt;/p&gt;
&lt;p&gt;``` c&lt;/p&gt;
&lt;h1 id="include"&gt;include &lt;stdio.h&gt;&lt;/h1&gt;
&lt;h1 id="include_1"&gt;include &lt;string.h&gt;&lt;/h1&gt;
&lt;h1 id="include_2"&gt;include &lt;stdlib.h&gt;&lt;/h1&gt;
&lt;h1 id="include_3"&gt;include &lt;pcap.h&gt;&lt;/h1&gt;
&lt;h1 id="include-basetypeh"&gt;include "basetype.h"&lt;/h1&gt;
&lt;p&gt;/&lt;em&gt; 网卡名称最大长度 &lt;/em&gt;/&lt;/p&gt;
&lt;h1 id="define-device_name_len-1024"&gt;define DEVICE_NAME_LEN (1024)&lt;/h1&gt;
&lt;p&gt;/&lt;em&gt; 过滤条件最大长度 &lt;/em&gt;/&lt;/p&gt;
&lt;h1 id="define-filter_len-10-1024"&gt;define FILTER_LEN (10 * 1024)&lt;/h1&gt;
&lt;p&gt;/&lt;em&gt; 当前选择抓包的网卡索引及名称 &lt;/em&gt;/
UINT32 g_uiDeviceIndex = -1;
CHAR g_acDeviceName[DEVICE_NAME_LEN + 1] = {0};&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; 条件过滤器 &lt;/em&gt;/
CHAR g_acFilter[FILTER_LEN + 1] = {0};&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; 报文处理回调函数 &lt;/em&gt;/
VOID traffic_callback(UINT8 &lt;em&gt;pucCntx, const struct pcap_pkthdr &lt;/em&gt;pstPktHdr, const UINT8 *pucPacket);&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; 主函数 &lt;/em&gt;/
int main(int argc, char &lt;em&gt;argv[])
{
    CHAR &lt;/em&gt;pcDev = NULL;
    CHAR acErrBuff[PCAP_ERRBUF_SIZE] = {0};
    INT32 iLoop = 0;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UINT32 uiShowUsageOnly = NO;
INT32 iRet = 0;

pcap_t *pstHandle = NULL;
pcap_if_t *pstAllDevices = NULL;
pcap_if_t *pstDevice = NULL;

struct bpf_program stFilter = {0};
bpf_u_int32 uiIP = 0;
bpf_u_int32 uiNetmask = 0;

/* 0.命令行参数处理 */
if (1 &amp;gt;= argc)
{
    uiShowUsageOnly = YES;
}
else if (2 == argc)
{
    g_uiDeviceIndex = atoi(argv[1]);
}
else /* 3 &amp;lt;= argc */
{
    g_uiDeviceIndex = atoi(argv[1]);
    strncpy(g_acFilter, argv[2], FILTER_LEN);
    DEBUG_EVENT("Set filter: %s", g_acFilter);
}

/* 1.查找所有的网卡接口 */
iRet = pcap_findalldevs(&amp;amp;pstAllDevices, acErrBuff);
if (OK != iRet)
{
    DEBUG_ERROR("Could not find any device! (%s)", acErrBuff);
    return ERROR;
}

/* 2.打印网卡接口列表 */
iLoop = 0;
pstDevice = pstAllDevices;
DEBUG_INFO("Device list:");
while (NULL != pstDevice)
{
    if (g_uiDeviceIndex == iLoop)
    {
        DEBUG_INFO(" -&amp;gt; (%d) %s (%s)", iLoop, pstDevice-&amp;gt;name, pstDevice-&amp;gt;description);
        strncpy(g_acDeviceName, pstDevice-&amp;gt;name, DEVICE_NAME_LEN);
    }
    else
    {
        DEBUG_INFO("    (%d) %s (%s)", iLoop, pstDevice-&amp;gt;name, pstDevice-&amp;gt;description);
    }
    pstDevice = pstDevice-&amp;gt;next;
    ++iLoop;
}

pcap_freealldevs(pstAllDevices);
pstAllDevices = NULL;

if (YES == uiShowUsageOnly)
{
    DEBUG_INFO("Usage:");
    DEBUG_INFO("    traffic &amp;lt;Device Index&amp;gt; [Filter] ");
    return OK;
}

if (0 == strlen(g_acDeviceName))
{
    DEBUG_ERROR("Could not found the selected device(%u)!", g_uiDeviceIndex);
    return OK;
}

DEBUG_EVENT("Select device: (%u) %s", g_uiDeviceIndex, g_acDeviceName);

/* 3.查询网卡信息(IP/Mask) */
iRet = pcap_lookupnet(g_acDeviceName, &amp;amp;uiIP, &amp;amp;uiNetmask, acErrBuff);
if (OK != iRet)
{
    DEBUG_ERROR("Could not get the device infomation! (%s)", acErrBuff);
    uiIP = 0;
    uiNetmask = 0xFFFFFFFF;

    /* 查询网卡信息失败不影响业务功能 继续处理 */
}

/* 4.打开指定的网卡 */
/*   参数1:网卡名称 参数2:最大数据长度 参数3:超时时间(ms) 参数4:错误信息 */
pstHandle = pcap_open_live(g_acDeviceName, 65535, 1, 500, acErrBuff);
if (NULL == pstHandle)
{
    DEBUG_ERROR("Could not open device %s! (%s)", g_acDeviceName, acErrBuff);
    return ERROR;
}

/* 5.设置过滤条件 */
/*   参数1:网卡句柄 参数2:过滤器 参数3:过滤条件字符串 参数4:是否优化 参数5:网络掩码 */
iRet = pcap_compile(pstHandle, &amp;amp;stFilter, g_acFilter, 0, uiNetmask);
if (OK != iRet)
{
    DEBUG_ERROR("Could not parse the filter \"%s\"! (%s)", g_acFilter, pcap_geterr(pstHandle));
    return ERROR;
}
iRet = pcap_setfilter(pstHandle, &amp;amp;stFilter);
if (OK != iRet)
{
    DEBUG_ERROR("Could not set the filter \"%s\"! (%s)", g_acFilter, pcap_geterr(pstHandle));
    return ERROR;
}

/* 6.抓包处理（阻塞） */
/*   参数1:网卡句柄 参数2:报文个数 参数3:回调函数 参数4:上下文信息 */
pcap_loop(pstHandle, -1, traffic_callback, NULL);

/* 7.关闭网卡 */
pcap_close(pstHandle);
pstHandle = NULL;

return OK;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; 报文处理回调函数 &lt;/em&gt;/
VOID traffic_callback(UINT8 &lt;em&gt;pucCntx, const struct pcap_pkthdr &lt;/em&gt;pstPktHdr, const UINT8 *pucPacket)
{
    DEBUG_EVENT("Receives a packet (%u bytes).", pstPktHdr-&amp;gt;len);&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
```&lt;/p&gt;
&lt;p&gt;另外补充一句，源文件中的&lt;code&gt;traffic_callback&lt;/code&gt;为捕获报文后的回调处理函数，对报文的处理操作均可以在这里进行，&lt;code&gt;pstPktHdr&lt;/code&gt;为报文头信息，&lt;code&gt;pucPacket&lt;/code&gt;为报文数据指针。&lt;/p&gt;
&lt;h3 id="3"&gt;3 编译&lt;/h3&gt;
&lt;p&gt;执行gcc编译，注意需要加上&lt;code&gt;-lpcap&lt;/code&gt;选项，因为需要用到libpcap的库函数：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bash
gcc -o traffic traffic.c -lpcap&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;或者可以直接写个Makefile方便后续编译：&lt;/p&gt;
&lt;p&gt;``` makefile
CC=gcc
LIBS=-lpcap
OPTS=-ggdb3 -rdynamic&lt;/p&gt;
&lt;p&gt;traffic:
    $(CC) -o traffic *.c $(LIBS) $(OPTS)&lt;/p&gt;
&lt;p&gt;all: traffic&lt;/p&gt;
&lt;p&gt;clean:
    rm traffic
```&lt;/p&gt;
&lt;h3 id="4"&gt;4 运行&lt;/h3&gt;
&lt;p&gt;直接执行&lt;code&gt;./traffic&lt;/code&gt;显示可用的网卡列表，这里我们选择6号（无线网卡）进行抓包，运行效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Traffic Running with Filter" src="/images/articles/201405/traffic_running_with_filter.png" /&gt;&lt;/p&gt;
&lt;p&gt;另外，第二个参数"port 53"（该端口为DNS协议），是在设置报文捕获的过滤条件（通过代码中的&lt;code&gt;pcap_compile&lt;/code&gt;和&lt;code&gt;pcap_setfilter&lt;/code&gt;结合来实现）。&lt;/p&gt;
&lt;p&gt;注意这里的操作需要root用户权限，因为需要将网卡设置为混杂模式。&lt;/p&gt;
&lt;h3 id="5"&gt;5 结尾&lt;/h3&gt;
&lt;p&gt;本文中的示例代码可以&lt;a href="/downloads/code/libpcap-based-development-example.zip"&gt;点击此处链接&lt;/a&gt;获取下载。&lt;/p&gt;</summary><category term="Linux"></category><category term="C"></category><category term="libpcap"></category></entry><entry><title>在多个文件中批量查找/替换字符串</title><link href="http://hutaow.com/blog/2014/05/26/batch-replace-string-in-files" rel="alternate"></link><updated>2014-05-26T23:36:27+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2014-05-26:blog/2014/05/26/batch-replace-string-in-files</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;在目录中查找包含指定字符串的文件（如下所示，在path目录中查找包含string字符串的文件）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bash
grep string -rl /path&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在目录中查找并替换指定的字符串（如下所示，将path目录中将所有文件中的oldstring字符串替换成newstring）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bash
sed -i "s/oldstring/newstring/g" `grep oldstring -rl /path`&lt;/code&gt;&lt;/p&gt;</summary><category term="Linux"></category><category term="sed"></category><category term="grep"></category></entry><entry><title>轻量级的 Linux 终端软件 RXVT</title><link href="http://hutaow.com/blog/2014/01/03/my-rxvt-config" rel="alternate"></link><updated>2014-01-03T14:28:23+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2014-01-03:blog/2014/01/03/my-rxvt-config</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;最近发现了个轻量级的Linux终端 —— &lt;a href="http://rxvt.sourceforge.net"&gt;RXVT&lt;/a&gt;，功能比xterm丰富，又不像其它终端（比如GNOME Terminal）那么臃肿。RXVT主要依靠配置文件来设置各项参数，下面是我的配置文件内容。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;p&gt;``` bash
!!$HOME/.Xdefaults
Rxvt.preeditType: root&lt;/p&gt;
&lt;p&gt;!!窗口大小及标题
Rxvt.geometry: 80x25
Rxvt.title: hutaow-rxvt&lt;/p&gt;
&lt;p&gt;!!输入法设置
Rxvt.inputMethod: fcitx&lt;/p&gt;
&lt;p&gt;!!透明度设置
!Rxvt.transparent: true
!Rxvt.shading: 110
!Rxvt.tintColor: grey
!Rxvt.inheritPixmap: false&lt;/p&gt;
&lt;p&gt;!!扩展设置
Rxvt.perl-ext-common: default, matcher, fullscreen&lt;/p&gt;
&lt;p&gt;!!URL操作
Rxvt.urlLauncher: /usr/bin/chromium
Rxvt.matcher.button: 1&lt;/p&gt;
&lt;p&gt;!!标签设置
!Rxvt.per-ext-common: ..., tabbed, ...
!Rxvt.tabbed.tabbar-fg: 2
!Rxvt.tabbed.tabbar-bg: 0
!Rxvt.tabbed.tab-fg: 3
!Rxvt.tabbed.tab-bg: 0
!Rxvt.tabbed.new-button: false
!Rxvt.tabbed.autohide: true
!RXvt.tabbed.reopen-on-close: no
!Rxvt.keysym.Control-t: perl:tabbedex:new_tab
!Rxvt.keysym.Control-Tab: perl:tabbedex:next_tab
!Rxvt.keysym.Control-Shift-Tab: perl:tabbedex:prev_tab
!Rxvt.keysym.Control-Shift-Left: perl:tabbex:move_tab_left
!Rxvt.keysym.Control-Shift-Right: perl:tabbex:move_tab_right
!Rxvt.keysym.Control-Shift-R: perl:tabbex:rename_tab&lt;/p&gt;
&lt;p&gt;!!全屏模式
!Rxvt.perl-ext-common: ..., fullscreen, ...
Rxvt.keysym.F11: perl:fullscreen:switch&lt;/p&gt;
&lt;p&gt;!!滚动条设置
Rxvt.scrollBar: true
Rxvt.scrollBar_right: true
Rxvt.scrollBar_floating: false
Rxvt.scrollstyle: plain&lt;/p&gt;
&lt;p&gt;!!滚屏设置
Rxvt.mouseWheelScrollPage: false
Rxvt.scrollTtyOutput: false
Rxvt.scrollWithBuffer: true
Rxvt.scrollTtyKeypress: true&lt;/p&gt;
&lt;p&gt;!!光标闪烁
Rxvt.cursorBlink: true&lt;/p&gt;
&lt;p&gt;!!缓存行数
Rxvt.saveLines: 5000&lt;/p&gt;
&lt;p&gt;!!边框设置
Rxvt.borderLess: false&lt;/p&gt;
&lt;p&gt;!!字体设置
Rxvt.dpi: 96
Rxvt.*font: xft:Terminus,xft:WenQuanYi Bitmap Song&lt;/p&gt;
&lt;p&gt;!!颜色设置
Rxvt.depth: 32
Rxvt.background: #2C2C2C
Rxvt.foreground: 7
Rxvt.colorBD: 7
Rxvt.colorUL: 7&lt;/p&gt;
&lt;p&gt;!!基本颜色
!Black
Rxvt.color0: #3F3F3F
Rxvt.color8: #709080
!red
Rxvt.color1: #705050
Rxvt.color9: #DCA3A3
!Green
Rxvt.color2: #60B48A
Rxvt.color10: #72D5A3
!Yellow
Rxvt.color3: #DFAF8F
Rxvt.color11: #F0DFAF
!Blue
Rxvt.color4: #9AB8D7
Rxvt.color12: #94BFF3
!Magenta
Rxvt.color5: #DC8CC3
Rxvt.color13: #EC93D3
!Cyan
Rxvt.color6: #8CD0D3
Rxvt.color14: #93E0E3
!White
Rxvt.color7: #DCDCDC
Rxvt.color15: #FFFFFF
```&lt;/p&gt;
&lt;p&gt;源文件下载：&lt;a href="/downloads/code/hutaow.Xdefaults"&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;配置后的终端运行效果如下图：
&lt;img alt="Interface of RXVT" src="/images/articles/201401/rxvt.png" /&gt;&lt;/p&gt;</summary><category term="Linux"></category><category term="RXVT"></category><category term="配置文件"></category></entry><entry><title>使用 OProfile 进行性能分析</title><link href="http://hutaow.com/blog/2013/12/29/performance-analysis-with-oprofile" rel="alternate"></link><updated>2013-12-29T19:09:33+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2013-12-29:blog/2013/12/29/performance-analysis-with-oprofile</id><summary type="html">&lt;hr /&gt;
&lt;h3 id="1"&gt;1 介绍&lt;/h3&gt;
&lt;p&gt;OProfile是Linux上的性能监测工具，通过CPU硬件提供的性能计数器对事件（如CPU Cycle、Cache Miss等）进行采样，可以帮助开发者从代码层面分析程序的性能消耗情况，很方便的找出影响程序性能的问题点。&lt;/p&gt;
&lt;p&gt;硬件上，OProfile支持多种架构的CPU，包括Alpha、MIPS、ARM、x86/x86-64、Sparc64、PowerPC等；软件上，OProfile支持Linux 2.2、2.4、2.6多种版本的内核，并且所占用的系统开销较小，一般在1%-8%范围内，具体数值依赖于采样频率。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;h3 id="2"&gt;2 环境准备&lt;/h3&gt;
&lt;h4 id="21-linux"&gt;2.1 编译Linux内核&lt;/h4&gt;
&lt;p&gt;OProfile需要Linux内核的支持，到Linux内核源代码目录中（一般为&lt;code&gt;/usr/src/linux-xxx&lt;/code&gt;）执行下面的命令：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bash
make menuconfig&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在配置菜单中找到OProfile的选项并将其打开，然后保存退出。&lt;/p&gt;
&lt;p&gt;如果不想用&lt;code&gt;make menuconfig&lt;/code&gt;的方式配置，可以直接修改&lt;code&gt;.config&lt;/code&gt;文件，把下面两个选项打开即可：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CONFIG_PROFILING=y
CONFIG_OPROFILE=y&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;配置完成后，依次执行下面的命令编译内核：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bash
make dep
make clean
make bzImage&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;编译完成后，会生成内核文件&lt;code&gt;bzImage&lt;/code&gt;，将其拷贝到&lt;code&gt;/boot&lt;/code&gt;目录中（最好重命名一下，和其它内核文件区别开，比如&lt;code&gt;vmlinuz-linux-with-oprofile&lt;/code&gt;）。最后将启动菜单中的内核引导文件换成新的内核，完成后重新启动Linux。&lt;/p&gt;
&lt;h4 id="22-oprofile"&gt;2.2 安装OProfile&lt;/h4&gt;
&lt;p&gt;如果所使用的Linux发行版中已经自带了软件管理器，则直接在相应的管理器中搜索并安装&lt;code&gt;oprofile&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;如果没有软件管理器，或是在管理器中没有搜到OProfile，可以直接访问&lt;a href="http://oprofile.sourceforge.net"&gt;OProfile官网&lt;/a&gt;下载一个，下载解压后执行标准的三步曲完成安装：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bash
./configure
make
make install&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="3"&gt;3 性能监测&lt;/h3&gt;
&lt;h4 id="31"&gt;3.1 设置监测参数&lt;/h4&gt;
&lt;p&gt;这里只列出了最常用的设置，详细参数可以通过&lt;code&gt;opcontrol --help&lt;/code&gt;查看。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1) 设置监测事件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bash
opcontrol --event=eventspec&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;eventspec&lt;/code&gt;即为需要监测的事件，参数格式为&lt;code&gt;name:count:unitmask:kernel:user&lt;/code&gt;，各字段含义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;name - 事件名称，如&lt;code&gt;CPU_CLK_UNHALTED&lt;/code&gt;，支持的事件列表可以通过&lt;code&gt;opcontrol --list-events&lt;/code&gt;命令列出&lt;/li&gt;
&lt;li&gt;count - 触发一次采样的事件计数值，如100000&lt;/li&gt;
&lt;li&gt;unitmask - 硬件单元掩码，如0x0F&lt;/li&gt;
&lt;li&gt;kernel - 是否对内核进行监测，取值0或1&lt;/li&gt;
&lt;li&gt;user - 是否对用户空间进行监测，取值0或1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2) 设置内核文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当要对内核进行监测时，需要指定内核的文件路径，使用下面的命令（其中&lt;code&gt;file&lt;/code&gt;为内核文件完整路径）：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bash
opcontrol --vmlinux=file&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果不需要对内核进行性能监测，则此处直接使用&lt;code&gt;--no-vmlinux&lt;/code&gt;参数：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bash
opcontrol --no-vmlinux&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3) 设置监测数据分离方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bash
opcontrol --separate=type[,types]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;code&gt;type&lt;/code&gt;的参数选项如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;none - 不分离监测数据&lt;/li&gt;
&lt;li&gt;library - 为每个应用程序分离出动态库的监测数据&lt;/li&gt;
&lt;li&gt;kernel - 在library的基础上分离内核的监测数据&lt;/li&gt;
&lt;li&gt;thread - 分离出每个线程的监测数据&lt;/li&gt;
&lt;li&gt;cpu - 分离出每个CPU的监测数据&lt;/li&gt;
&lt;li&gt;all - 分离以上全部监测数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt; 4) 设置待监测的二进制文件名称&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以设置多个（逗号分隔），如果不设置则默认为全部：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bash
opcontrol --image=name[,names]&lt;/code&gt;&lt;/p&gt;
&lt;h4 id="32"&gt;3.2 开始监测&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;bash
opcontrol --init
opcontrol --start&lt;/code&gt;&lt;/p&gt;
&lt;h4 id="33"&gt;3.3 执行待监测的业务功能&lt;/h4&gt;
&lt;p&gt;监测器已开始运行，现在可以执行相应程序的业务功能了。&lt;/p&gt;
&lt;h4 id="34"&gt;3.4 保存监测数据&lt;/h4&gt;
&lt;p&gt;程序业务执行完成后，使用下面的命令将监测数据转储下来：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bash
opcontrol --dump&lt;/code&gt;&lt;/p&gt;
&lt;h4 id="35"&gt;3.5 停止监测&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;bash
opcontrol --stop
opcontrol --shutdown
opcontrol --deinit&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="4"&gt;4 性能数据分析&lt;/h3&gt;
&lt;p&gt;监测数据转储后，即可以通过&lt;code&gt;opreport&lt;/code&gt;和&lt;code&gt;opannotate&lt;/code&gt;命令查看性能消耗情况了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1) 显示各模块整体的性能消耗情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bash
opreport&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2) 显示各函数的性能消耗情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bash
opreport -l&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3) 显示代码级别的性能消息情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bash
opannotate -s&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：该功能需要在用户程序编译的时候加上调试选项（gcc编译器需要加上&lt;code&gt;-g&lt;/code&gt;选项）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4) 显示反汇编代码的性能消耗情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bash
opannotate -a&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="5"&gt;5 实例&lt;/h3&gt;
&lt;p&gt;下面举一个利用OProfile对程序性能进行优化的例子。&lt;/p&gt;
&lt;h4 id="51"&gt;5.1 优化前性能监测&lt;/h4&gt;
&lt;p&gt;首先看一下下面这段代码，其中&lt;code&gt;reverser&lt;/code&gt;函数的功能是将输入的数据以字节为单位做逆序处理。&lt;/p&gt;
&lt;p&gt;``` c&lt;/p&gt;
&lt;h1 id="include"&gt;include &lt;stdio.h&gt;&lt;/h1&gt;
&lt;h1 id="include_1"&gt;include &lt;string.h&gt;&lt;/h1&gt;
&lt;h1 id="define-ok-0"&gt;define OK          (0)&lt;/h1&gt;
&lt;h1 id="define-err-1"&gt;define ERR         (1)&lt;/h1&gt;
&lt;h1 id="define-buf_size-0x100"&gt;define BUF_SIZE    (0x100)&lt;/h1&gt;
&lt;p&gt;/&lt;em&gt; 交换两个变量的值 &lt;/em&gt;/&lt;/p&gt;
&lt;h1 id="define-swapa-b"&gt;define SWAP(a, b)  \&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;do { \
    char x; \
    x = (a); \
    (a) = (b); \
    (b) = x; \
} while (0)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;/&lt;em&gt; 将数据逆序处理 &lt;/em&gt;/
int reverser(char *data, unsigned int len)
{
    int i;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (NULL == data)
{
    return ERR;
}

for (i = 0; i &amp;lt; len / 2; ++i)
{
    SWAP(*(data + i), *(data + len - i - 1));
}

return OK;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; 主函数 &lt;/em&gt;/
int main(int argc, char *argv[])
{
    char str[BUF_SIZE] = {0};
    int ret = OK;
    int i = 0;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;strcpy(str, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");

printf("original string : %s \r\n", str);

for (i = 0; i &amp;lt; 0x800001; ++i)
{
    ret = reverser(str, strlen(str));
}

printf("reversely string : %s \r\n", str);

return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
```&lt;/p&gt;
&lt;p&gt;源文件下载：&lt;a href="/downloads/code/reverser.c"&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后对该代码进行编译并生成可执行文件，注意编译的时候加上&lt;code&gt;-g&lt;/code&gt;选项，这样会生成带调试信息的程序，后面显示监测报告的时候会用到：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bash
gcc reverser.c -g -o reverser&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;接下来对OProfile的参数进行设置：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bash
opcontrol --event=CPU_CLK_UNHALTED:100000:0:0:1
opcontrol --no-vmlinux
opcontrol --image=reverser&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;启动OProfile监测守护进程，同时将之前的监测数据清空：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bash
opcontrol --init
opcontrol --start
opcontrol --reset&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;运行待监测程序：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Run the Reverser" src="/images/articles/201401/run_reverser.png" /&gt;&lt;/p&gt;
&lt;p&gt;转储OProfile监测数据：
&lt;code&gt;bash
opcontrol --dump&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;停止OProfile监测守护进程：
&lt;code&gt;bash
opcontrol --stop
opcontrol --shutdown
opcontrol --deinit&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;执行&lt;code&gt;opreport&lt;/code&gt;命令，查看监测统计数据：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Result of OPReport for Reverser" src="/images/articles/201401/opreport_reverser.png" /&gt;&lt;/p&gt;
&lt;p&gt;执行&lt;code&gt;opannotate -s&lt;/code&gt;命令，查看详细的监测统计数据（代码级）：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Result of OPAnnotate for Reverser" src="/images/articles/201401/opannotate_reverser.png" /&gt;&lt;/p&gt;
&lt;h4 id="52"&gt;5.2 性能优化&lt;/h4&gt;
&lt;p&gt;从上面的报告中可以看到，&lt;code&gt;reverser&lt;/code&gt;函数共触发了近6万5千次采样，其中&lt;code&gt;for (i = 0; i &amp;lt; len / 2; ++i)&lt;/code&gt;这一行占用了1万6千多次，消耗了约25%的性能，而实际可以发现&lt;code&gt;len / 2&lt;/code&gt;这个操作不需要每次循环都要计算一次，完全可以把它提取到循环外部，于是这段代码可以改成这个样子：&lt;/p&gt;
&lt;p&gt;``` c
int reverser(char *data, unsigned int len)
{
    int i;
    int cnt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (NULL == data)
{
    return ERR;
}

/* 优化: 将循环总数放到循环体外 这样只进行一次计算即可 */
cnt = len / 2;
for (i = 0; i &amp;lt; cnt; ++i)
{
    SWAP(*(data + i), *(data + len - i - 1));
}

return OK;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
```&lt;/p&gt;
&lt;p&gt;源文件下载：&lt;a href="/downloads/code/reverser_opt.c"&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;h4 id="53"&gt;5.3 优化后性能监测&lt;/h4&gt;
&lt;p&gt;代码优化后重复上面的监测动作，检查优化后的性能监测数据。&lt;/p&gt;
&lt;p&gt;执行&lt;code&gt;opreport&lt;/code&gt;命令：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Result of OPReport for Reverser (Optimize)" src="/images/articles/201401/opreport_reverser_optimize.png" /&gt;&lt;/p&gt;
&lt;p&gt;执行&lt;code&gt;opannotate -s&lt;/code&gt;命令：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Result of OPAnnotate for Reverser (Optimize)" src="/images/articles/201401/opannotate_reverser_optimize.png" /&gt;&lt;/p&gt;
&lt;h4 id="54"&gt;5.4 性能优化对比&lt;/h4&gt;
&lt;p&gt;从优化前后的报告中可以对比出，&lt;code&gt;reverser&lt;/code&gt;函数从6万5千次采样降低到了4万8千次左右，总体性能提升了约25%，其中for循环条件的优化直接贡献了15%左右的性能提升，另外循环条件的改变也影响了编译器对代码编译时的流程优化，这也间接带来了10%左右的性能提升。&lt;/p&gt;
&lt;h3 id="6"&gt;6 后记&lt;/h3&gt;
&lt;p&gt;本文讲述了OProfile的基本用法，以最常见的CPU Cycle作为例子演示了性能优化的过程。事实上，OProfile还可以用到的统计计数事件还有很多（具体依赖CPU硬件的支持），像Cache Miss、TLB Miss等等，这些在性能优化中都会涉及到，这需要开发者在实际环境中不断的操作和体会，从而逐渐学习并掌握性能优化中的各种技巧。&lt;/p&gt;</summary><category term="OProfile"></category><category term="性能优化"></category></entry><entry><title>将 Python 脚本转换为可执行程序</title><link href="http://hutaow.com/blog/2013/12/24/convert-python-script-to-executable-program" rel="alternate"></link><updated>2013-12-24T00:00:01+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2013-12-24:blog/2013/12/24/convert-python-script-to-executable-program</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;本文所使用的工具是cx_Freeze，相对py2exe和PyInstaller来说，cx_Freeze的兼容性更好，支持最新的Python 3.X，支持PyQT，并且可以跨平台支持Windows和Linux系统。&lt;/p&gt;
&lt;p&gt;cx_Freeze的官方主页为&lt;a href="http://cx-freeze.sourceforge.net"&gt;http://cx-freeze.sourceforge.net&lt;/a&gt;，下面以Windows系统为例介绍一下它的使用方法。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;h3 id="1"&gt;1 配置转换脚本&lt;/h3&gt;
&lt;p&gt;新建一个Python脚本文件，如&lt;code&gt;setup.py&lt;/code&gt;，内容如下：&lt;/p&gt;
&lt;p&gt;``` python
import sys
from cx_Freeze import setup, Executable&lt;/p&gt;
&lt;p&gt;base = None
if sys.platform == "win32":
    base = "Win32GUI"&lt;/p&gt;
&lt;p&gt;setup(  name = "MyApp",
        version = "0.1",
        description = "My PyQT application!",
        executables = [Executable("pyqt_example.py", base=base)])
```&lt;/p&gt;
&lt;p&gt;源文件下载：&lt;a href="/downloads/code/setup.py"&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;pyqt_example.py&lt;/code&gt;为将要转换的脚本文件，其它字段为描述信息，根据实际情况修改即可。&lt;/p&gt;
&lt;h3 id="2"&gt;2 执行转换脚本&lt;/h3&gt;
&lt;p&gt;在脚本所在的目录执行下面的命令，其中&lt;code&gt;build&lt;/code&gt;为转换后的程序存放目录：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;python setup.py build&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;执行后即会在&lt;code&gt;build&lt;/code&gt;目录中生成对应的可执行程序了，并且程序运行过程中依赖的库文件也自动拷贝好了。&lt;/p&gt;</summary><category term="Python"></category></entry><entry><title>使用 PyQT 作为 Python 的图形界面</title><link href="http://hutaow.com/blog/2013/12/16/using-pyqt-as-graphical-interface-for-python" rel="alternate"></link><updated>2013-12-16T23:02:24+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2013-12-16:blog/2013/12/16/using-pyqt-as-graphical-interface-for-python</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;以前Python写出来的脚本都是靠命令行执行，输入要是复杂点就得靠加参数，甚至加配置文件来搞定，自己用下还行，给别人用的时候总是不太方便，就一直想找个好用的图形界面库。&lt;/p&gt;
&lt;p&gt;有试过Python内置的Tkinter，部署倒是挺简单，不需要额外安装库，但是开发效率还是不够高，而且需要手写不少界面相关的重复代码，用起来不太方便。&lt;/p&gt;
&lt;p&gt;最近开始尝试第三方的界面库，几经权衡，最终在PyGTK、wxPython、PyQT中选择了PyQT，试了一下，确实很不错，下面就介绍一下PyQT的使用方法。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;h3 id="1"&gt;1 介绍&lt;/h3&gt;
&lt;p&gt;PyQT以QT为基础，跨平台（可以运行在Windows、Linux/Unix、MacOS等操作系统上），同时PyQT的界面可以直接用QT Designer做出来，可以很容易移植到其它语言上（C++、C#、Java、Perl等）。&lt;/p&gt;
&lt;h3 id="2"&gt;2 例子&lt;/h3&gt;
&lt;p&gt;为了更好了了解PyQT，先写一段简单的示例代码，例子中通过点击按钮，来改变文本框所显示的内容，具体代码含义直接通过注释说明了。&lt;/p&gt;
&lt;p&gt;``` python&lt;/p&gt;
&lt;h1 id="-coding-utf-8-"&gt;-&lt;em&gt;- coding: utf-8 -&lt;/em&gt;-&lt;/h1&gt;
&lt;p&gt;import sys
from PyQt4 import QtCore, QtGui&lt;/p&gt;
&lt;h1 id="_1"&gt;自定义的窗口类&lt;/h1&gt;
&lt;p&gt;class TestWindow(QtGui.QWidget):
    # 窗口初始化
    def &lt;strong&gt;init&lt;/strong&gt;(self, parent = None):
        super(TestWindow, self).&lt;strong&gt;init&lt;/strong&gt;(parent)
        self.setWindowTitle(u'胡桃夹子')&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    # 创建按钮
    self.pushButton = QtGui.QPushButton(u'测试按钮')

    # 创建文本框
    self.textEdit = QtGui.QTextEdit()

    # 创建垂直布局
    layout = QtGui.QVBoxLayout()

    # 将控件添加到布局中
    layout.addWidget(self.textEdit)
    layout.addWidget(self.pushButton)

    # 设置窗口布局
    self.setLayout(layout)

    # 设置按钮单击动作
    self.pushButton.clicked.connect(self.sayHello)

# 按钮动作处理
def sayHello(self):
    self.textEdit.setText('Hello World!')
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="_2"&gt;程序主入口&lt;/h1&gt;
&lt;p&gt;if &lt;strong&gt;name&lt;/strong&gt;=='&lt;strong&gt;main&lt;/strong&gt;':
    app = QtGui.QApplication(sys.argv)
    mainWindow = TestWindow()
    mainWindow.show()
    sys.exit(app.exec_())
```&lt;/p&gt;
&lt;p&gt;源文件下载：&lt;a href="/downloads/code/pyqt_example.py"&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;运行效果如下图，点击按钮后，文本框中会显示&lt;code&gt;Hello World!&lt;/code&gt;字符串：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Example of PyQT" src="/images/articles/201312/pyqt_example.png" /&gt;&lt;/p&gt;
&lt;h3 id="3"&gt;3 设计界面&lt;/h3&gt;
&lt;p&gt;了解了PyQT之后，设计界面的工作就可以交给QT设计器来完成，不再需要手写界面代码，最大限度的提高界面开发速度。下面通过QT设计器的方式再完成一次上面例子中的功能。&lt;/p&gt;
&lt;p&gt;在QT设计器中，新建一个&lt;code&gt;Dialog&lt;/code&gt;类型的窗体，然后向窗体中分别加入&lt;code&gt;Vertical Layout&lt;/code&gt;、&lt;code&gt;Push Button&lt;/code&gt;和&lt;code&gt;Text Edit&lt;/code&gt;三个控件，并界面摆成下图的样子：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Example of QT Designer for PyQT" src="/images/articles/201312/qt_designer.png" /&gt;&lt;/p&gt;
&lt;p&gt;还可以通过设置各控件的属性来修改界面显示的文字、效果等，此处不过多叙述，下面将设计好的界面保存为&lt;code&gt;qt_designer_example.ui&lt;/code&gt;文件，文件内容如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xml
&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
&amp;lt;ui version="4.0"&amp;gt;
 &amp;lt;class&amp;gt;Dialog&amp;lt;/class&amp;gt;
 &amp;lt;widget class="QDialog" name="Dialog"&amp;gt;
  &amp;lt;property name="windowModality"&amp;gt;
   &amp;lt;enum&amp;gt;Qt::NonModal&amp;lt;/enum&amp;gt;
  &amp;lt;/property&amp;gt;
  &amp;lt;property name="geometry"&amp;gt;
   &amp;lt;rect&amp;gt;
    &amp;lt;x&amp;gt;0&amp;lt;/x&amp;gt;
    &amp;lt;y&amp;gt;0&amp;lt;/y&amp;gt;
    &amp;lt;width&amp;gt;280&amp;lt;/width&amp;gt;
    &amp;lt;height&amp;gt;240&amp;lt;/height&amp;gt;
   &amp;lt;/rect&amp;gt;
  &amp;lt;/property&amp;gt;
  &amp;lt;property name="windowTitle"&amp;gt;
   &amp;lt;string&amp;gt;Dialog&amp;lt;/string&amp;gt;
  &amp;lt;/property&amp;gt;
  &amp;lt;widget class="QWidget" name="verticalLayoutWidget"&amp;gt;
   &amp;lt;property name="geometry"&amp;gt;
    &amp;lt;rect&amp;gt;
     &amp;lt;x&amp;gt;10&amp;lt;/x&amp;gt;
     &amp;lt;y&amp;gt;10&amp;lt;/y&amp;gt;
     &amp;lt;width&amp;gt;258&amp;lt;/width&amp;gt;
     &amp;lt;height&amp;gt;221&amp;lt;/height&amp;gt;
    &amp;lt;/rect&amp;gt;
   &amp;lt;/property&amp;gt;
   &amp;lt;layout class="QVBoxLayout" name="verticalLayout"&amp;gt;
    &amp;lt;item&amp;gt;
     &amp;lt;widget class="QTextEdit" name="textEdit"/&amp;gt;
    &amp;lt;/item&amp;gt;
    &amp;lt;item&amp;gt;
     &amp;lt;widget class="QPushButton" name="pushButton"&amp;gt;
      &amp;lt;property name="text"&amp;gt;
       &amp;lt;string&amp;gt;PushButton&amp;lt;/string&amp;gt;
      &amp;lt;/property&amp;gt;
     &amp;lt;/widget&amp;gt;
    &amp;lt;/item&amp;gt;
   &amp;lt;/layout&amp;gt;
  &amp;lt;/widget&amp;gt;
 &amp;lt;/widget&amp;gt;
 &amp;lt;resources/&amp;gt;
 &amp;lt;connections/&amp;gt;
&amp;lt;/ui&amp;gt;&lt;/code&gt;
源文件下载：&lt;a href="/downloads/code/qt_designer_example.ui"&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以看出，QT设计器所保存的界面是XML文件格式的，事实上，QT设计器所生成的界面可以很自由的移植到不同语言中，甚至不需要太多额外的适配工作，非常方便。&lt;/p&gt;
&lt;h3 id="4"&gt;4 生成代码&lt;/h3&gt;
&lt;p&gt;有了QT界面，下一步就需要用&lt;code&gt;pyuic&lt;/code&gt;这个工具来将QT界面转换为Python代码（基于PyQT库），转换命令如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pyuic4 -x -o qt_designer_example.py qt_designer_example.ui&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;-o qt_designer_example.py&lt;/code&gt;用来标识输出文件名；这里需要特别说明的是&lt;code&gt;-x&lt;/code&gt;参数，该参数表示是否生成额外的测试代码来显示窗口，建议加上该参数，这样的话可以方便直接调试运行。&lt;/p&gt;
&lt;p&gt;下面是通过&lt;code&gt;pyuic&lt;/code&gt;工具生成的Python代码：&lt;/p&gt;
&lt;p&gt;``` python&lt;/p&gt;
&lt;h1 id="-coding-utf-8-_1"&gt;-&lt;em&gt;- coding: utf-8 -&lt;/em&gt;-&lt;/h1&gt;
&lt;h1 id="form-implementation-generated-from-reading-ui-file-qt_designer_exampleui"&gt;Form implementation generated from reading ui file 'qt_designer_example.ui'&lt;/h1&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;h1 id="created-wed-dec-18-225255-2013"&gt;Created: Wed Dec 18 22:52:55 2013&lt;/h1&gt;
&lt;h1 id="by-pyqt4-ui-code-generator-4103"&gt;by: PyQt4 UI code generator 4.10.3&lt;/h1&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;h1 id="warning-all-changes-made-in-this-file-will-be-lost"&gt;WARNING! All changes made in this file will be lost!&lt;/h1&gt;
&lt;p&gt;from PyQt4 import QtCore, QtGui&lt;/p&gt;
&lt;p&gt;try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s&lt;/p&gt;
&lt;p&gt;try:
    _encoding = QtGui.QApplication.UnicodeUTF8
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig)&lt;/p&gt;
&lt;p&gt;class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName(_fromUtf8("Dialog"))
        Dialog.setWindowModality(QtCore.Qt.NonModal)
        Dialog.resize(279, 262)
        self.verticalLayoutWidget = QtGui.QWidget(Dialog)
        self.verticalLayoutWidget.setGeometry(QtCore.QRect(10, 20, 258, 221))
        self.verticalLayoutWidget.setObjectName(_fromUtf8("verticalLayoutWidget"))
        self.verticalLayout = QtGui.QVBoxLayout(self.verticalLayoutWidget)
        self.verticalLayout.setMargin(0)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.textEdit = QtGui.QTextEdit(self.verticalLayoutWidget)
        self.textEdit.setObjectName(_fromUtf8("textEdit"))
        self.verticalLayout.addWidget(self.textEdit)
        self.pushButton = QtGui.QPushButton(self.verticalLayoutWidget)
        self.pushButton.setObjectName(_fromUtf8("pushButton"))
        self.verticalLayout.addWidget(self.pushButton)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    self.retranslateUi(Dialog)
    QtCore.QMetaObject.connectSlotsByName(Dialog)

def retranslateUi(self, Dialog):
    Dialog.setWindowTitle(_translate("Dialog", "Dialog", None))
    self.pushButton.setText(_translate("Dialog", "PushButton", None))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;if &lt;strong&gt;name&lt;/strong&gt; == "&lt;strong&gt;main&lt;/strong&gt;":
    import sys
    app = QtGui.QApplication(sys.argv)
    Dialog = QtGui.QDialog()
    ui = Ui_Dialog()
    ui.setupUi(Dialog)
    Dialog.show()
    sys.exit(app.exec_())
```&lt;/p&gt;
&lt;p&gt;源文件下载：&lt;a href="/downloads/code/qt_designer_example.py"&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="5"&gt;5 处理事件&lt;/h3&gt;
&lt;p&gt;QT采用的是&lt;code&gt;Signal&lt;/code&gt;（信号）和&lt;code&gt;Slot&lt;/code&gt;（槽）的机制来处理事件，Signal负责发送消息来触发事件动作，Slot负责接收消息并进行相应的事件处理（在PyQT中，Signal和Slot可以是任何类型）。&lt;/p&gt;
&lt;p&gt;有两种方式可以连接Signal和Slot：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法一：传统QT的连接方式&lt;/strong&gt;
&lt;code&gt;python
self.connect(self.sender, SIGNAL("sndSignal(int)"), self.receiver, SLOT("rcvSlot(int)"))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法二：适用于Python的连接方式&lt;/strong&gt;
&lt;code&gt;python
self.sndSignal.connect(self.receiver.rcvSlot)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;本例中我们在&lt;code&gt;Ui_Dialog&lt;/code&gt;类的&lt;code&gt;setupUi&lt;/code&gt;函数中增加Signal/Slot的连接，然后再增加一个&lt;code&gt;sayHello&lt;/code&gt;的事件（Slot）处理函数，先来看下方法一的连接方式：&lt;/p&gt;
&lt;p&gt;``` python
class Ui_Dialog(object):
    def setupUi(self, Dialog):
        ... ...
        QtCore.QObject.connect(self.pushButton, QtCore.SIGNAL("clicked()"), self.sayHello)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def sayHello(self):
    self.textEdit.setText('Hello World!')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;p&gt;下面是方法二的连接方式：
``` python
class Ui_Dialog(object):
    def setupUi(self, Dialog):
        ... ...
        self.pushButton.clicked.connect(self.sayHello)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def sayHello(self):
    self.textEdit.setText('Hello World!')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;p&gt;可以看出方法二的连接方式使用更简单，也更符合Python的编程风格。&lt;/p&gt;
&lt;h3 id="6"&gt;6 后记&lt;/h3&gt;
&lt;p&gt;完成上述步骤后，就可以运行Python脚本了，运行后界面功能和开头中的例子基本相同，只不过这个是用QT设计器辅助完成的，相比手写界面代码来说，效率高了不少。&lt;/p&gt;</summary><category term="Script"></category><category term="Python"></category><category term="QT"></category><category term="PyQT"></category><category term="脚本"></category></entry><entry><title>类型转换导致字符串大小计算错误的问题</title><link href="http://hutaow.com/blog/2013/12/05/string-size-calculation" rel="alternate"></link><updated>2013-12-05T01:17:30+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2013-12-05:blog/2013/12/05/string-size-calculation</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;今天在定位问题时，发现有一个字符串关键字在搜索时死活不命中，但实际那个关键字在数据中是存在的，跟踪发现是一个不起眼的细节导致的。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;p&gt;用一段简短的代码来说明一下问题出在哪里：&lt;/p&gt;
&lt;p&gt;``` c&lt;/p&gt;
&lt;h1 id="include"&gt;include &lt;stdio.h&gt;&lt;/h1&gt;
&lt;h1 id="define-m_string_1-test"&gt;define M_STRING_1 "test"&lt;/h1&gt;
&lt;h1 id="define-m_string_2-char-test"&gt;define M_STRING_2 (char *)"test"&lt;/h1&gt;
&lt;p&gt;int main(int argc, char &lt;em&gt;argv[])
{
    char &lt;/em&gt;pcStr = M_STRING_1;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;printf("Size of string macro 1      : %u bytes \r\n", sizeof(M_STRING_1));
printf("Size of string pointer 1    : %u bytes \r\n", sizeof(pcStr));
printf("Size of string macro 2      : %u bytes \r\n", sizeof(M_STRING_2));

return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
```&lt;/p&gt;
&lt;p&gt;程序运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Size of string macro 1      : 5 bytes 
Size of string pointer 1    : 8 bytes 
Size of string macro 2      : 8 bytes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第一行&lt;/strong&gt;：宏定义字符串长度为4字节，&lt;code&gt;sizeof(M_STRING_1)&lt;/code&gt;加上&lt;code&gt;0x00&lt;/code&gt;结束符，大小是5字节没问题。
&lt;strong&gt;第二行&lt;/strong&gt;：&lt;code&gt;sizeof(pcStr)&lt;/code&gt;是在计算指针的长度，计算出的值和CPU寄存器的宽度有关，我的机器是64位，所以得到的大小是8字节，这个也是在预料之中。
&lt;strong&gt;第三行&lt;/strong&gt;：问题就发生在这里，本来以为会和第一行计算结果一样是5字节，实际结果却是预料之外的8字节（指针长度）！&lt;/p&gt;
&lt;p&gt;分析发现，&lt;code&gt;M_STRING_2&lt;/code&gt;宏定义中的字符串多了一个&lt;code&gt;(char *)&lt;/code&gt;的强制转换，正是这个转换导致&lt;code&gt;sizeof&lt;/code&gt;的入参从字符串常量变成了指针，从而计算出的大小为指针的长度而非字符串的大小。&lt;/p&gt;
&lt;p&gt;开头提到的关键字不匹配问题，也正是由于关键字长度超出实际值，导致访问越界，而越界部分的值是不可预知的，最终造成了无法命中的问题。&lt;/p&gt;</summary><category term="C"></category></entry><entry><title>配置 VIM 开发环境</title><link href="http://hutaow.com/blog/2013/11/22/vim-development-environment" rel="alternate"></link><updated>2013-11-22T22:43:22+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2013-11-22:blog/2013/11/22/vim-development-environment</id><summary type="html">&lt;hr /&gt;
&lt;h3 id="1"&gt;1 插件列表&lt;/h3&gt;
&lt;h4 id="11-ctags"&gt;1.1 CTags&lt;/h4&gt;
&lt;p&gt;CTags用来给源代码生成索引文件，以便于文本编辑器快速定位符号位置（变量、函数、类等）。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href="http://ctags.sourceforge.net"&gt;http://ctags.sourceforge.net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用方式：在代码的根目录执行如下命令即可生成tag文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ctags -R --c++-kinds=+p --fields=+iaS --extra=+q .&lt;/code&gt;&lt;/p&gt;
&lt;!-- more --&gt;

&lt;p&gt;这个命令有点长，可以在&lt;code&gt;.vimrc&lt;/code&gt;的文件中加个键盘映射，像下面的样子，这样只需要按下&lt;code&gt;CTRL+F12&lt;/code&gt;即可生成tag文件了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map &amp;lt;C-F12&amp;gt; :!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q .&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;另外，如果需要指明源代码的语言，则需要加上&lt;code&gt;--languages=c&lt;/code&gt;（使用C语言）的参数。&lt;/p&gt;
&lt;h4 id="12-taglist"&gt;1.2 TagList&lt;/h4&gt;
&lt;p&gt;TagList是一款基于CTags的VIM插件，用来显示代码的结构概况。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href="http://www.vim.org/scripts/script.php?script_id=273"&gt;http://www.vim.org/scripts/script.php?script_id=273&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;配置方式：在&lt;code&gt;~/.vimrc&lt;/code&gt;文件中，增加如下配置：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;let Tlist_Auto_Open = 1
let Tlist_Show_One_File = 1
let Tlist_Exit_OnlyWindow = 1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中第一行配置为当发现开启的文件为源代码时，则自动打开TagList，建议打开这个选项，不然每次都都手动执行&lt;code&gt;TlistToggle&lt;/code&gt;来开关TagList窗口。&lt;/p&gt;
&lt;h4 id="13-cscope"&gt;1.3 CScope&lt;/h4&gt;
&lt;p&gt;CScope是一个C语言的浏览工具，可以快速找到函数、变量的定义位置及调用信息。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href="http://cscope.sourceforge.net"&gt;http://cscope.sourceforge.net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用方式：在代码的根目录执行下面的命令，即可生成CScope的索引文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cscope -Rbkq&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;code&gt;-R&lt;/code&gt;表示递归建立索引，&lt;code&gt;-b&lt;/code&gt;表示不启动CScope的用户界面，&lt;code&gt;-k&lt;/code&gt;表示生成索引文件时不搜索&lt;code&gt;/usr/include&lt;/code&gt;目录，&lt;code&gt;-q&lt;/code&gt;表示生成&lt;code&gt;cscope.in.out&lt;/code&gt;和&lt;code&gt;cscope.po.out&lt;/code&gt;文件，以加快索引速度。&lt;/p&gt;
&lt;h4 id="14-omnicppcomplete"&gt;1.4 OmniCppComplete&lt;/h4&gt;
&lt;p&gt;OmniCppComplete是VIM中对结构体的成员变量、类的属性或方法提供实时提示及补全功能的插件，依赖CTags工具生成的索引文件。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href="http://www.vim.org/scripts/script.php?script_id=1520"&gt;http://www.vim.org/scripts/script.php?script_id=1520&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;配置方式：无需配置，插件安装后即自动生效，在写代码时，输入一个结构体变量的名称后，当继续输入&lt;code&gt;.&lt;/code&gt;或&lt;code&gt;-&amp;gt;&lt;/code&gt;字符后，会自动弹出该结构体中的所有变量列表，可以上下选择，然后按回车自动补全。&lt;/p&gt;
&lt;h4 id="15-supertab"&gt;1.5 SuperTab&lt;/h4&gt;
&lt;p&gt;SuperTab可以简化补全代码的方式，直接按&lt;code&gt;TAB&lt;/code&gt;键即可（之前需要按&lt;code&gt;CTRL+X&lt;/code&gt;和&lt;code&gt;CTRL+O&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href="http://www.vim.org/scripts/script.php?script_id=1643"&gt;http://www.vim.org/scripts/script.php?script_id=1643&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;配置方式：SuperTab插件是Vimball的安装格式，不需要手动拷贝插件，直接用VIM打开，然后执行&lt;code&gt;:so %&lt;/code&gt;即可完成安装。安装后需要在&lt;code&gt;~/.vimrc&lt;/code&gt;文件中增加如下配置：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;let g:SuperTabRetainCompletionType=2
let g:SuperTabDefaultCompletionType="&amp;lt;C-X&amp;gt;&amp;lt;C-O&amp;gt;"&lt;/code&gt;&lt;/p&gt;
&lt;h4 id="16-minibufexplorer"&gt;1.6 MiniBufExplorer&lt;/h4&gt;
&lt;p&gt;当需要同时编辑多个文件的时候，MiniBufExplorer可以在VIM顶部以标签形式显示当前打开的文件列表，并可以在各文件间快速切换。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href="http://www.vim.org/scripts/script.php?script_id=159"&gt;http://www.vim.org/scripts/script.php?script_id=159&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;配置方式：在&lt;code&gt;~/.vimrc&lt;/code&gt;文件中增加如下配置：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;let g:miniBufExplMapWindowNavVim = 1 
let g:miniBufExplMapWindowNavArrows = 1 
let g:miniBufExplMapCTabSwitchBufs = 1 
let g:miniBufExplModSelTarget = 1&lt;/code&gt;&lt;/p&gt;
&lt;h4 id="17-command-t"&gt;1.7 Command-T&lt;/h4&gt;
&lt;p&gt;Command-T用于在VIM快速定位文件，通过&lt;code&gt;:CommandT&lt;/code&gt;呼出Command-T窗口，然后直接输入文件名，在输入的过程中文件列表会逐渐缩小范围，并可以通过&lt;code&gt;CTRL+k&lt;/code&gt;和&lt;code&gt;CTRL+j&lt;/code&gt;上下选择文件，选定后按回车即可打开文件。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href="http://www.vim.org/scripts/script.php?script_id=3025"&gt;http://www.vim.org/scripts/script.php?script_id=3025&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装方式：Command-T插件为Vimball安装格式，首先用VIM打开安装文件，执行&lt;code&gt;:so %&lt;/code&gt;安装插件，然后执行下面的命令：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cd ~/.vim/ruby/command-t
ruby extconf.rb
make&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注：安装需要Ruby开发环境。&lt;/p&gt;
&lt;h4 id="18-ctrlp"&gt;1.8 CtrlP&lt;/h4&gt;
&lt;p&gt;CtrlP是另一个快速定位文件的插件，通过&lt;code&gt;:CtrlP&lt;/code&gt;呼出查找窗口，用法和Command-T一样，而且支持正则，另外不需要Ruby运行环境，安装起来更方便。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href="http://www.vim.org/scripts/script.php?script_id=3736"&gt;http://www.vim.org/scripts/script.php?script_id=3736&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;配置方式：在&lt;code&gt;~/.vimrc&lt;/code&gt;中增加如下配置选项：&lt;/p&gt;
&lt;p&gt;```
let g:ctrlp_working_path_mode = 'ra'&lt;/p&gt;
&lt;p&gt;"" MacOSX/Linux
set wildignore+=&lt;em&gt;/tmp/&lt;/em&gt;,&lt;em&gt;.so,&lt;/em&gt;.swp,*.zip&lt;/p&gt;
&lt;p&gt;"" Windows
set wildignore+=&lt;em&gt;\tmp\&lt;/em&gt;,&lt;em&gt;.swp,&lt;/em&gt;.zip,*.exe&lt;/p&gt;
&lt;p&gt;let g:ctrlp_custom_ignore = {
  \ 'dir':  '\v[\/].(git|hg|svn)$',
  \ 'file': '\v.(exe|so|dll)$',
  \ 'link': 'some_bad_symbolic_links',
  \ }&lt;/p&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;h4 id="19-avim"&gt;1.9 A.VIM&lt;/h4&gt;
&lt;p&gt;A.VIM是用于&lt;code&gt;.c&lt;/code&gt;和&lt;code&gt;.h&lt;/code&gt;文件间的快速切换的插件。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href="http://www.vim.org/scripts/script.php?script_id=31"&gt;http://www.vim.org/scripts/script.php?script_id=31&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;配置方式：无需配置，插件安装后执行&lt;code&gt;:A&lt;/code&gt;即可完成&lt;code&gt;.c&lt;/code&gt;和&lt;code&gt;.h&lt;/code&gt;文件间的切换。&lt;/p&gt;
&lt;h3 id="2"&gt;2 运行效果&lt;/h3&gt;
&lt;p&gt;&lt;img alt="VIM开发环境配置效果" src="/images/articles/201311/vim_development_environment.png" /&gt;&lt;/p&gt;
&lt;p&gt;注：图中的效果除了上面的插件配置，还包括了其它对VIM的基本配置，见&lt;a href="/blog/2007/08/19/my-vi-config"&gt;《我的VI配置文件》&lt;/a&gt;。&lt;/p&gt;</summary><category term="Linux"></category><category term="VI"></category><category term="CTags"></category><category term="TagList"></category><category term="CScope"></category></entry><entry><title>在 ArchLinux 中使用 Fcitx 输入法</title><link href="http://hutaow.com/blog/2013/11/18/configure-the-fcitx-in-archlinux" rel="alternate"></link><updated>2013-11-18T22:37:16+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2013-11-18:blog/2013/11/18/configure-the-fcitx-in-archlinux</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;Fcitx是Linux中以轻量箸称的输入法框架，短小精悍且兼容性非常好。简单记录一下Fcitx在ArchLinux中的安装配置方式。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;h3 id="_1"&gt;安装输入法&lt;/h3&gt;
&lt;p&gt;执行下面的命令安装FCITX：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pacman -S fcitx-im&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="_2"&gt;配置环境变量&lt;/h3&gt;
&lt;p&gt;将下面的环境变量设置加入到显示管理器的配置文件中（KDM、GDM、LightDM的配置文件为&lt;code&gt;~/.xprofile&lt;/code&gt;，startx、Slim的配置文件为&lt;code&gt;~/.xinitrc&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;export GTK_IM_MODULE=fcitx
export QT_IM_MODULE=fcitx
export XMODIFIERS="@im=fcitx"&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;配置后重新登录生效，使用&lt;code&gt;CTRL+空格&lt;/code&gt;激活输入法，如果发现fcitx没有运行，则直接在命令行里执行&lt;code&gt;fcitx&lt;/code&gt;即可。&lt;/p&gt;</summary><category term="Linux"></category><category term="ArchLinux"></category><category term="Fcitx"></category></entry><entry><title>MySQL协议分析</title><link href="http://hutaow.com/blog/2013/11/06/mysql-protocol-analysis" rel="alternate"></link><updated>2013-11-06T00:34:54+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2013-11-06:blog/2013/11/06/mysql-protocol-analysis</id><summary type="html">&lt;hr /&gt;
&lt;h2 id="_1"&gt;目录&lt;/h2&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#1"&gt;1 交互过程&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#11"&gt;1.1 握手认证阶段&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#12"&gt;1.2 命令执行阶段&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#2"&gt;2 基本类型&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#21"&gt;2.1 整型值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#22-nullnull-terminated-string"&gt;2.2 字符串（以NULL结尾）（Null-Terminated String）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#23-length-coded-binary"&gt;2.3 二进制数据（长度编码）（Length Coded Binary）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#24-length-coded-string"&gt;2.4 字符串（长度编码）（Length Coded String）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#3"&gt;3 报文结构&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#31"&gt;3.1 消息头&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#311"&gt;3.1.1 报文长度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#312"&gt;3.1.2 序号&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#32"&gt;3.2 消息体&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#4"&gt;4 报文类型&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#41"&gt;4.1 登陆认证交互报文&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#411-"&gt;4.1.1 握手初始化报文（服务器 -&amp;gt; 客户端）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#412-"&gt;4.1.2 登陆认证报文（客户端 -&amp;gt; 服务器）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#42-"&gt;4.2 客户端命令请求报文（客户端 -&amp;gt; 服务器）&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#421-com_quit"&gt;4.2.1 COM_QUIT 消息报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#422-com_init_db"&gt;4.2.2 COM_INIT_DB 消息报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#423-com_query"&gt;4.2.3 COM_QUERY 消息报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#424-com_field_list"&gt;4.2.4 COM_FIELD_LIST 消息报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#425-com_create_db"&gt;4.2.5 COM_CREATE_DB 消息报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#426-com_drop_db"&gt;4.2.6 COM_DROP_DB 消息报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#427-com_refresh"&gt;4.2.7 COM_REFRESH 消息报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#428-com_shutdown"&gt;4.2.8 COM_SHUTDOWN 消息报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#429-com_statistics"&gt;4.2.9 COM_STATISTICS 消息报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#4210-com_process_info"&gt;4.2.10 COM_PROCESS_INFO 消息报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#4211-com_process_kill"&gt;4.2.11 COM_PROCESS_KILL 消息报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#4212-com_debug"&gt;4.2.12 COM_DEBUG 消息报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#4213-com_ping"&gt;4.2.13 COM_PING 消息报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#4214-com_change_user"&gt;4.2.14 COM_CHANGE_USER 消息报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#4215-com_binlog_dump"&gt;4.2.15 COM_BINLOG_DUMP 消息报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#4216-com_table_dump"&gt;4.2.16 COM_TABLE_DUMP 消息报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#4217-com_register_slave"&gt;4.2.17 COM_REGISTER_SLAVE 消息报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#4218-com_prepare"&gt;4.2.18 COM_PREPARE 消息报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#4219-com_execute"&gt;4.2.19 COM_EXECUTE 消息报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#4220-com_long_data"&gt;4.2.20 COM_LONG_DATA 消息报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#4221-com_close_stmt"&gt;4.2.21 COM_CLOSE_STMT 消息报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#4222-com_reset_stmt"&gt;4.2.22 COM_RESET_STMT 消息报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#4223-com_set_option"&gt;4.2.23 COM_SET_OPTION 消息报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#4224-com_fetch_stmt"&gt;4.2.24 COM_FETCH_STMT 消息报文&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#43-"&gt;4.3 服务器响应报文（服务器 -&amp;gt; 客户端）&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#431-ok"&gt;4.3.1 OK 响应报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#432-error"&gt;4.3.2 Error 响应报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#433-result-set"&gt;4.3.3 Result Set 消息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#434-result-set-header"&gt;4.3.4 Result Set Header 结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#435-field"&gt;4.3.5 Field 结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#436-eof"&gt;4.3.6 EOF 结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#437-row-data"&gt;4.3.7 Row Data 结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#438-row-data"&gt;4.3.8 Row Data 结构（二进制数据）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#439-prepare_ok-prepared-statement"&gt;4.3.9 PREPARE_OK 响应报文（Prepared Statement）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#4310-parameter-prepared-statement"&gt;4.3.10 Parameter 响应报文（Prepared Statement）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#5"&gt;5 参考资料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="1"&gt;1 交互过程&lt;/h2&gt;
&lt;p&gt;MySQL客户端与服务器的交互主要分为两个阶段：握手认证阶段和命令执行阶段。&lt;/p&gt;
&lt;h3 id="11"&gt;1.1 握手认证阶段&lt;/h3&gt;
&lt;p&gt;握手认证阶段为客户端与服务器建立连接后进行，交互过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器 -&amp;gt; 客户端：握手初始化消息&lt;/li&gt;
&lt;li&gt;客户端 -&amp;gt; 服务器：登陆认证消息&lt;/li&gt;
&lt;li&gt;服务器 -&amp;gt; 客户端：认证结果消息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="12"&gt;1.2 命令执行阶段&lt;/h3&gt;
&lt;p&gt;客户端认证成功后，会进入命令执行阶段，交互过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端 -&amp;gt; 服务器：执行命令消息&lt;/li&gt;
&lt;li&gt;服务器 -&amp;gt; 客户端：命令执行结果&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;

&lt;p&gt;&lt;strong&gt;MySQL客户端与服务器的完整交互过程如下&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img alt="MySQL客户端与服务器交互示意图" src="/images/articles/201311/mysql_protocol_message.png" /&gt;&lt;/p&gt;
&lt;h2 id="2"&gt;2 基本类型&lt;/h2&gt;
&lt;h3 id="21"&gt;2.1 整型值&lt;/h3&gt;
&lt;p&gt;MySQL报文中整型值分别有1、2、3、4、8字节长度，使用小字节序传输。&lt;/p&gt;
&lt;h3 id="22-nullnull-terminated-string"&gt;2.2 字符串（以NULL结尾）（Null-Terminated String）&lt;/h3&gt;
&lt;p&gt;字符串长度不固定，当遇到'NULL'（0x00）字符时结束。&lt;/p&gt;
&lt;h3 id="23-length-coded-binary"&gt;2.3 二进制数据（长度编码）（Length Coded Binary）&lt;/h3&gt;
&lt;p&gt;数据长度不固定，长度值由数据前的1-9个字节决定，其中长度值所占的字节数不定，字节数由第1个字节决定，如下表：&lt;/p&gt;
&lt;p&gt;第一个字节值    |后续字节数     |长度值说明
----------------|---------------|---------------
0-250           |0              |第一个字节值即为数据的真实长度
251             |0              |空数据，数据的真实长度为零
252             |2              |后续额外2个字节标识了数据的真实长度
253             |3              |后续额外3个字节标识了数据的真实长度
254             |8              |后续额外8个字节标识了数据的真实长度&lt;/p&gt;
&lt;h3 id="24-length-coded-string"&gt;2.4 字符串（长度编码）（Length Coded String）&lt;/h3&gt;
&lt;p&gt;字符串长度不固定，无'NULL'（0x00）结束符，编码方式与上面的 Length Coded Binary 相同。&lt;/p&gt;
&lt;h2 id="3"&gt;3 报文结构&lt;/h2&gt;
&lt;p&gt;报文分为消息头和消息体两部分，其中消息头占用固定的4个字节，消息体长度由消息头中的长度字段决定，报文结构如下：&lt;/p&gt;
&lt;!--
    ┏━━━━━━━━━━━━━━━━━━━━━━━━┯━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
    ┃                        │        ┃                                             ┃
    ┃         3 Bytes        │ 1 Byte ┃                   n Bytes                   ┃
    ┃                        │        ┃                                             ┃
    ┗━━━━━━━━━━━━━━━━━━━━━━━━┷━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
    |&lt;-       消息长度     -&gt;|&lt;-序号-&gt;|&lt;-                 报文数据                -&gt;|
    |                                 |                                             |
    |&lt;-             消息头          -&gt;|&lt;-                  消息体                 -&gt;|
--&gt;

&lt;p&gt;&lt;img alt="MySQL报文结构" src="/images/articles/201311/mysql_protocol_struct.png" /&gt;&lt;/p&gt;
&lt;h3 id="31"&gt;3.1 消息头&lt;/h3&gt;
&lt;h4 id="311"&gt;3.1.1 报文长度&lt;/h4&gt;
&lt;p&gt;用于标记当前请求消息的实际数据长度值，以字节为单位，占用3个字节，最大值为 0xFFFFFF，即接近 16 MB 大小（比16MB少1个字节）。&lt;/p&gt;
&lt;h4 id="312"&gt;3.1.2 序号&lt;/h4&gt;
&lt;p&gt;在一次完整的请求/响应交互过程中，用于保证消息顺序的正确，每次客户端发起请求时，序号值都会从0开始计算。&lt;/p&gt;
&lt;h3 id="32"&gt;3.2 消息体&lt;/h3&gt;
&lt;p&gt;消息体用于存放请求的内容及响应的数据，长度由消息头中的长度值决定。&lt;/p&gt;
&lt;h2 id="4"&gt;4 报文类型&lt;/h2&gt;
&lt;h3 id="41"&gt;4.1 登陆认证交互报文&lt;/h3&gt;
&lt;h4 id="411-"&gt;4.1.1 握手初始化报文（服务器 -&amp;gt; 客户端）&lt;/h4&gt;
&lt;!--
    0                                   16                                  32
    ┏━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
    ┃     1 Byte      │          n Bytes (Null-Termimated String)           ┃
    ┃   协议版本号    │                服务器版本信息                       ┃
    ┣━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ┃                                4 Bytes                                ┃
    ┃                              服务器线程ID                             ┃
    ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ┃                                                                       ┃
    ┃                                8 Bytes                                ┃
    ┃                              挑战随机数                               ┃
    ┃                                                                       ┃
    ┣━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━┫
    ┃     1 Byte      │              2 Bytes              │     1 Byte      ┃
    ┃   填充值(0x00)  │           服务器权能标志          │    字符编码     ┃
    ┣━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━┫
    ┃              2 Bytes              ┃              2 Bytes              ┃
    ┃            服务器状态             ┃        服务器权能标志(高16位)     ┃
    ┣━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ┃     1 Byte      │                                                     ┃
    ┃ 挑战长度(未使用)│                                                     ┃
    ┣━━━━━━━━━━━━━━━━━┷┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┫
    ┃                               10 Bytes                                ┃
    ┃                             填充值(0x00)                              ┃
    ┣┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┯━━━━━━━━━━━━━━━━━┫
    ┃                                                     │                 ┃
    ┃                                                     │                 ┃
    ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┷┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┫
    ┃                                                                       ┃
    ┃                                                                       ┃
    ┣┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┫
    ┃                               n Bytes                                 ┃
    ┃                    挑战随机数(第二部分，至少12字节)                   ┃
    ┣┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┯━━━━━━━━━━━━━━━━━┫
    ┃                                                     │     1 Byte      ┃
    ┃                                                     │ 挑战数结束(0x00)┃
    ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━┛
--&gt;

&lt;p&gt;&lt;img alt="MySQL握手初始化报文" src="/images/articles/201311/mysql_protocol_handshake.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务协议版本号&lt;/strong&gt;：该值由 PROTOCOL_VERSION 宏定义决定（参考MySQL源代码&lt;code&gt;/include/mysql_version.h&lt;/code&gt;头文件定义）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务版本信息&lt;/strong&gt;：该值为字符串，由 MYSQL_SERVER_VERSION 宏定义决定（参考MySQL源代码&lt;code&gt;/include/mysql_version.h&lt;/code&gt;头文件定义）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务器线程ID&lt;/strong&gt;：服务器为当前连接所创建的线程ID。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;挑战随机数&lt;/strong&gt;：MySQL数据库用户认证采用的是挑战/应答的方式，服务器生成该挑战数并发送给客户端，由客户端进行处理并返回相应结果，然后服务器检查是否与预期的结果相同，从而完成用户认证的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务器权能标志&lt;/strong&gt;：用于与客户端协商通讯方式，各标志位含义如下（参考MySQL源代码&lt;code&gt;/include/mysql_com.h&lt;/code&gt;中的宏定义）：&lt;/p&gt;
&lt;p&gt;标志位名称                  |标志位     |说明 
----------------------------|-----------|-------------------
CLIENT_LONG_PASSWORD        |0x0001     |new more secure passwords
CLIENT_FOUND_ROWS           |0x0002     |Found instead of affected rows
CLIENT_LONG_FLAG            |0x0004     |Get all column flags
CLIENT_CONNECT_WITH_DB      |0x0008     |One can specify db on connect
CLIENT_NO_SCHEMA            |0x0010     |Do not allow database.table.column
CLIENT_COMPRESS             |0x0020     |Can use compression protocol
CLIENT_ODBC                 |0x0040     |Odbc client
CLIENT_LOCAL_FILES          |0x0080     |Can use LOAD DATA LOCAL
CLIENT_IGNORE_SPACE         |0x0100     |Ignore spaces before '('
CLIENT_PROTOCOL_41          |0x0200     |New 4.1 protocol
CLIENT_INTERACTIVE          |0x0400     |This is an interactive client
CLIENT_SSL                  |0x0800     |Switch to SSL after handshake
CLIENT_IGNORE_SIGPIPE       |0x1000     |IGNORE sigpipes
CLIENT_TRANSACTIONS         |0x2000     |Client knows about transactions
CLIENT_RESERVED             |0x4000     |Old flag for 4.1 protocol 
CLIENT_SECURE_CONNECTION    |0x8000     |New 4.1 authentication
CLIENT_MULTI_STATEMENTS     |0x0001 0000|Enable/disable multi-stmt support
CLIENT_MULTI_RESULTS        |0x0002 0000|Enable/disable multi-results&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符编码&lt;/strong&gt;：标识服务器所使用的字符集。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务器状态&lt;/strong&gt;：状态值定义如下（参考MySQL源代码&lt;code&gt;/include/mysql_com.h&lt;/code&gt;中的宏定义）：&lt;/p&gt;
&lt;p&gt;状态名称                            |状态值
------------------------------------|-----------
SERVER_STATUS_IN_TRANS              |0x0001
SERVER_STATUS_AUTOCOMMIT            |0x0002
SERVER_STATUS_CURSOR_EXISTS         |0x0040
SERVER_STATUS_LAST_ROW_SENT         |0x0080
SERVER_STATUS_DB_DROPPED            |0x0100
SERVER_STATUS_NO_BACKSLASH_ESCAPES  |0x0200
SERVER_STATUS_METADATA_CHANGED      |0x0400&lt;/p&gt;
&lt;h4 id="412-"&gt;4.1.2 登陆认证报文（客户端 -&amp;gt; 服务器）&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt; MySQL 4.0 及之前的版本&lt;/strong&gt;&lt;/p&gt;
&lt;!--
    0                                   16                                  32
    ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
    ┃              2 Bytes              ┃              3 Bytes              ┋
    ┃           客户端权能标志          ┃           最大消息长度            ┋
    ┣━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ┋                 │                                                     ┃
    ┋                 │                                                     ┃
    ┣━━━━━━━━━━━━━━━━━┷┉┉┉┉┉┉┉┉┉┉┉┉ n Bytes ┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┫
    ┃                     用户名(Null-Terminated String)                    ┃
    ┃                                                                       ┃
    ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ┃                                                                       ┃
    ┃                                                                       ┃
    ┣┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉ 8 Bytes ┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┫
    ┃                   挑战认证数据(Length Coded Binary)                   ┃
    ┃                                                                       ┃
    ┣━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
    ┃      1 Byte     ┃
    ┃  数据结束(0x00) ┃
    ┗━━━━━━━━━━━━━━━━━┛
--&gt;

&lt;p&gt;&lt;img alt="MySQL登陆认证报文(4.0及之前的版本)" src="/images/articles/201311/mysql_protocol_auth_40.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; MySQL 4.1 及之后的版本&lt;/strong&gt;&lt;/p&gt;
&lt;!--
    0                                   16                                  32
    ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
    ┃              2 Bytes              ┃              2 Bytes              ┃
    ┃           客户端权能标志          ┃        客户端权能标志（扩展）     ┃
    ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ┃                                4 Bytes                                ┃
    ┃                             最大消息长度                              ┃
    ┣━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ┃     1 Byte      │                                                     ┃
    ┃    字符编码     │                                                     ┃
    ┣━━━━━━━━━━━━━━━━━┷┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┫
    ┃                                                                       ┃
    ┃                                                                       ┃
    ┣┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┫
    ┃                                                                       ┃
    ┃                                                                       ┃
    ┣┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉ 23 Bytes ┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┫
    ┃                            填充值(0x00)                               ┃
    ┃                                                                       ┃
    ┣┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┫
    ┃                                                                       ┃
    ┃                                                                       ┃
    ┣┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┫
    ┃                                                                       ┃
    ┃                                                                       ┃
    ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ┃                               n Bytes                                 ┃
    ┃                     用户名(Null-Terminated String)                    ┃
    ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ┃                               n Bytes                                 ┃
    ┃                   挑战认证数据(Length Coded Binary)                   ┃
    ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ┃                               n Bytes                                 ┃
    ┃                 数据库名称(Null-Terminated String)(可选)              ┃
    ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
--&gt;

&lt;p&gt;&lt;img alt="MySQL登陆认证报文(4.1及之后的版本)" src="/images/articles/201311/mysql_protocol_auth_41.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;客户端权能标志&lt;/strong&gt;：用于与客户端协商通讯方式，标志位含义与握手初始化报文中的相同。客户端收到服务器发来的初始化报文后，会对服务器发送的权能标志进行修改，保留自身所支持的功能，然后将权能标返回给服务器，从而保证服务器与客户端通讯的兼容性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最大消息长度&lt;/strong&gt;：客户端发送请求报文时所支持的最大消息长度值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符编码&lt;/strong&gt;：标识通讯过程中使用的字符编码，与服务器在认证初始化报文中发送的相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户名&lt;/strong&gt;：客户端登陆用户的用户名称。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;挑战认证数据&lt;/strong&gt;：客户端用户密码使用服务器发送的挑战随机数进行加密后，生成挑战认证数据，然后返回给服务器，用于对用户身份的认证。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据库名称&lt;/strong&gt;：当客户端的权能标志位 CLIENT_CONNECT_WITH_DB 被置位时，该字段必须出现。&lt;/p&gt;
&lt;h3 id="42-"&gt;4.2 客户端命令请求报文（客户端 -&amp;gt; 服务器）&lt;/h3&gt;
&lt;!--
    ┏━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
    ┃                │                                                              ┃
    ┃     1 Byte     │                         n Bytes                              ┃
    ┃                │                                                              ┃
    ┗━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
    |&lt;-    命令    -&gt;|&lt;-                        参数                              -&gt;|
    |                                                                               |
    |&lt;-                                消息体                                     -&gt;|
--&gt;

&lt;p&gt;&lt;img alt="MySQL客户端命令请求报文" src="/images/articles/201311/mysql_protocol_command.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令&lt;/strong&gt;：用于标识当前请求消息的类型，例如切换数据库（0x02）、查询命令（0x03）等。命令值的取值范围及说明如下表（参考MySQL源代码&lt;code&gt;/include/mysql_com.h&lt;/code&gt;头文件中的定义）：&lt;/p&gt;
&lt;p&gt;类型值  |命令                       |功能                       |关联函数
--------|---------------------------|---------------------------|-----------
0x00    |COM_SLEEP                  |（内部线程状态）           |（无）
0x01    |COM_QUIT                   |关闭连接                   |mysql_close
0x02    |COM_INIT_DB                |切换数据库                 |mysql_select_db 
0x03    |COM_QUERY                  |SQL查询请求                |mysql_real_query
0x04    |COM_FIELD_LIST             |获取数据表字段信息         |mysql_list_fields
0x05    |COM_CREATE_DB              |创建数据库                 |mysql_create_db
0x06    |COM_DROP_DB                |删除数据库                 |mysql_drop_db
0x07    |COM_REFRESH                |清除缓存                   |mysql_refresh
0x08    |COM_SHUTDOWN               |停止服务器                 |mysql_shutdown
0x09    |COM_STATISTICS             |获取服务器统计信息         |mysql_stat
0x0A    |COM_PROCESS_INFO           |获取当前连接的列表         |mysql_list_processes
0x0B    |COM_CONNECT                |（内部线程状态）           |（无）
0x0C    |COM_PROCESS_KILL           |中断某个连接               |mysql_kill
0x0D    |COM_DEBUG                  |保存服务器调试信息         |mysql_dump_debug_info
0x0E    |COM_PING                   |测试连通性                 |mysql_ping
0x0F    |COM_TIME                   |（内部线程状态）           |（无）
0x10    |COM_DELAYED_INSERT         |（内部线程状态）           |（无）
0x11    |COM_CHANGE_USER            |重新登陆（不断连接）       |mysql_change_user
0x12    |COM_BINLOG_DUMP            |获取二进制日志信息         |（无）
0x13    |COM_TABLE_DUMP             |获取数据表结构信息         |（无）
0x14    |COM_CONNECT_OUT            |（内部线程状态）           |（无）
0x15    |COM_REGISTER_SLAVE         |从服务器向主服务器进行注册 |（无）
0x16    |COM_STMT_PREPARE           |预处理SQL语句              |mysql_stmt_prepare
0x17    |COM_STMT_EXECUTE           |执行预处理语句             |mysql_stmt_execute
0x18    |COM_STMT_SEND_LONG_DATA    |发送BLOB类型的数据         |mysql_stmt_send_long_data
0x19    |COM_STMT_CLOSE             |销毁预处理语句             |mysql_stmt_close
0x1A    |COM_STMT_RESET             |清除预处理语句参数缓存     |mysql_stmt_reset
0x1B    |COM_SET_OPTION             |设置语句选项               |mysql_set_server_option
0x1C    |COM_STMT_FETCH             |获取预处理语句的执行结果   |mysql_stmt_fetch&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;：内容是用户在MySQL客户端输入的命令（不包括每行命令结尾的";"分号）。另外这个字段的字符串不是以NULL字符结尾，而是通过消息头中的长度值计算而来。&lt;/p&gt;
&lt;p&gt;例如：当我们在MySQL客户端中执行&lt;code&gt;use hutaow;&lt;/code&gt;命令时（切换到&lt;code&gt;hutaow&lt;/code&gt;数据库），发送的请求报文数据会是下面的样子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0x02 0x68 0x75 0x74 0x61 0x6f 0x77
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;0x02&lt;/code&gt;为请求类型值&lt;code&gt;COM_INIT_DB&lt;/code&gt;，后面的&lt;code&gt;0x68 0x75 0x74 0x61 0x6f 0x77&lt;/code&gt;为ASCII字符&lt;code&gt;hutaow&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id="421-com_quit"&gt;4.2.1 COM_QUIT 消息报文&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：关闭当前连接（客户端退出），无参数。&lt;/p&gt;
&lt;h4 id="422-com_init_db"&gt;4.2.2 COM_INIT_DB 消息报文&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：切换数据库，对应的SQL语句为&lt;code&gt;USE &amp;lt;database&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;字节    |说明
--------|--------
n       |数据库名称（字符串到达消息尾部时结束，无结束符）&lt;/p&gt;
&lt;h4 id="423-com_query"&gt;4.2.3 COM_QUERY 消息报文&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：最常见的请求消息类型，当用户执行SQL语句时发送该消息。&lt;/p&gt;
&lt;p&gt;字节    |说明
--------|--------
n       |SQL语句（字符串到达消息尾部时结束，无结束符）&lt;/p&gt;
&lt;h4 id="424-com_field_list"&gt;4.2.4 COM_FIELD_LIST 消息报文&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：查询某表的字段（列）信息，等同于SQL语句&lt;code&gt;SHOW [FULL] FIELDS FROM ...&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;字节    |说明
--------|--------
n       |表格名称（Null-Terminated String）
n       |字段（列）名称或通配符（可选）&lt;/p&gt;
&lt;h4 id="425-com_create_db"&gt;4.2.5 COM_CREATE_DB 消息报文&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：创建数据库，该消息已过时，而被SQL语句&lt;code&gt;CREATE DATABASE&lt;/code&gt;代替。&lt;/p&gt;
&lt;p&gt;字节    |说明
--------|--------
n       |数据库名称（字符串到达消息尾部时结束，无结束符）&lt;/p&gt;
&lt;h4 id="426-com_drop_db"&gt;4.2.6 COM_DROP_DB 消息报文&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：删除数据库，该消息已过时，而被SQL语句&lt;code&gt;DROP DATABASE&lt;/code&gt;代替。&lt;/p&gt;
&lt;p&gt;字节    |说明
--------|--------
n       |数据库名称（字符串到达消息尾部时结束，无结束符）&lt;/p&gt;
&lt;h4 id="427-com_refresh"&gt;4.2.7 COM_REFRESH 消息报文&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：清除缓存，等同于SQL语句&lt;code&gt;FLUSH&lt;/code&gt;，或是执行&lt;code&gt;mysqladmin flush-foo&lt;/code&gt;命令时发送该消息。&lt;/p&gt;
&lt;p&gt;字节    |说明
--------|--------
1       |清除缓存选项（位图方式存储，各标志位含义如下）
        |0x01: REFRESH_GRANT
        |0x02: REFRESH_LOG
        |0x04: REFRESH_TABLES
        |0x08: REFRESH_HOSTS
        |0x10: REFRESH_STATUS
        |0x20: REFRESH_THREADS
        |0x40: REFRESH_SLAVE
        |0x80: REFRESH_MASTER&lt;/p&gt;
&lt;h4 id="428-com_shutdown"&gt;4.2.8 COM_SHUTDOWN 消息报文&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：停止MySQL服务。执行&lt;code&gt;mysqladmin shutdown&lt;/code&gt;命令时发送该消息。&lt;/p&gt;
&lt;p&gt;字节    |说明
--------|--------
1       |停止服务选项
        |0x00: SHUTDOWN_DEFAULT
        |0x01: SHUTDOWN_WAIT_CONNECTIONS
        |0x02: SHUTDOWN_WAIT_TRANSACTIONS
        |0x08: SHUTDOWN_WAIT_UPDATES
        |0x10: SHUTDOWN_WAIT_ALL_BUFFERS
        |0x11: SHUTDOWN_WAIT_CRITICAL_BUFFERS
        |0xFE: KILL_QUERY
        |0xFF: KILL_CONNECTION&lt;/p&gt;
&lt;h4 id="429-com_statistics"&gt;4.2.9 COM_STATISTICS 消息报文&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：查看MySQL服务的统计信息（例如运行时间、每秒查询次数等）。执行&lt;code&gt;mysqladmin status&lt;/code&gt;命令时发送该消息，无参数。&lt;/p&gt;
&lt;h4 id="4210-com_process_info"&gt;4.2.10 COM_PROCESS_INFO 消息报文&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：获取当前活动的线程（连接）列表。等同于SQL语句&lt;code&gt;SHOW PROCESSLIST&lt;/code&gt;，或是执行&lt;code&gt;mysqladmin processlist&lt;/code&gt;命令时发送该消息，无参数。&lt;/p&gt;
&lt;h4 id="4211-com_process_kill"&gt;4.2.11 COM_PROCESS_KILL 消息报文&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：要求服务器中断某个连接。等同于SQL语句&lt;code&gt;KILL &amp;lt;id&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;字节    |说明
--------|--------
4       |连接ID号（小字节序）&lt;/p&gt;
&lt;h4 id="4212-com_debug"&gt;4.2.12 COM_DEBUG 消息报文&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：要求服务器将调试信息保存下来，保存的信息多少依赖于编译选项设置（debug=no|yes|full）。执行&lt;code&gt;mysqladmin debug&lt;/code&gt;命令时发送该消息，无参数。&lt;/p&gt;
&lt;h4 id="4213-com_ping"&gt;4.2.13 COM_PING 消息报文&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：该消息用来测试连通性，同时会将服务器的无效连接（超时）计数器清零。执行&lt;code&gt;mysqladmin ping&lt;/code&gt;命令时发送该消息，无参数。&lt;/p&gt;
&lt;h4 id="4214-com_change_user"&gt;4.2.14 COM_CHANGE_USER 消息报文&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：在不断连接的情况下重新登陆，该操作会销毁MySQL服务器端的会话上下文（包括临时表、会话变量等）。有些连接池用这种方法实现清除会话上下文。&lt;/p&gt;
&lt;p&gt;字节    |说明
--------|--------
n       |用户名（字符串以NULL结尾）
n       |密码（挑战数）
        |MySQL 3.23 版本：Null-Terminated String（长度9字节）
        |MySQL 4.1 版本：Length Coded String（长度1+21字节）
n       |数据库名称（Null-Terminated String）
2       |字符编码&lt;/p&gt;
&lt;h4 id="4215-com_binlog_dump"&gt;4.2.15 COM_BINLOG_DUMP 消息报文&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：该消息是备份连接时由从服务器向主服务器发送的最后一个请求，主服务器收到后，会响应一系列的报文，每个报文都包含一个二进制日志事件。如果主服务器出现故障时，会发送一个EOF报文。&lt;/p&gt;
&lt;p&gt;字节    |说明
--------|--------
4       |二进制日志数据的起始位置（小字节序）
4       |二进制日志数据标志位（目前未使用，永远为0x00）
4       |从服务器的服务器ID值（小字节序）
n       |二进制日志的文件名称（可选，默认值为主服务器上第一个有效的文件名）&lt;/p&gt;
&lt;h4 id="4216-com_table_dump"&gt;4.2.16 COM_TABLE_DUMP 消息报文&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：将数据表从主服务器复制到从服务器中，执行SQL语句&lt;code&gt;LOAD TABLE ... FROM MASTER&lt;/code&gt;时发送该消息。目前该消息已过时，不再使用。&lt;/p&gt;
&lt;p&gt;字节    |说明
--------|--------
n       |数据库名称（Length Coded String）
n       |数据表名称（Length Coded String）&lt;/p&gt;
&lt;h4 id="4217-com_register_slave"&gt;4.2.17 COM_REGISTER_SLAVE 消息报文&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：在从服务器&lt;code&gt;report_host&lt;/code&gt;变量设置的情况下，当备份连接时向主服务器发送的注册消息。&lt;/p&gt;
&lt;p&gt;字节    |说明
--------|--------
4       |从服务器ID值（小字节序）
n       |主服务器IP地址（Length Coded String）
n       |主服务器用户名（Length Coded String）
n       |主服务器密码（Length Coded String）
2       |主服务器端口号
4       |安全备份级别（由MySQL服务器&lt;code&gt;rpl_recovery_rank&lt;/code&gt;变量设置，暂时未使用）
4       |主服务器ID值（值恒为0x00）&lt;/p&gt;
&lt;h4 id="4218-com_prepare"&gt;4.2.18 COM_PREPARE 消息报文&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：预处理SQL语句，使用带有"?"占位符的SQL语句时发送该消息。&lt;/p&gt;
&lt;p&gt;字节    |说明
--------|--------
n       |带有"?"占位符的SQL语句（字符串到达消息尾部时结束，无结束符）&lt;/p&gt;
&lt;h4 id="4219-com_execute"&gt;4.2.19 COM_EXECUTE 消息报文&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：执行预处理语句。&lt;/p&gt;
&lt;p&gt;字节    |说明
--------|--------
4       |预处理语句的ID值
1       |标志位
        |0x00: CURSOR_TYPE_NO_CURSOR
        |0x01: CURSOR_TYPE_READ_ONLY
        |0x02: CURSOR_TYPE_FOR_UPDATE
        |0x04: CURSOR_TYPE_SCROLLABLE
4       |保留（值恒为0x01）
如果参数数量大于0|
n       |空位图（Null-Bitmap，长度 = (参数数量 + 7) / 8 字节）
1       |参数分隔标志
如果参数分隔标志值为1|
n       |每个参数的类型值（长度 = 参数数量 * 2 字节）
n       |每个参数的值&lt;/p&gt;
&lt;h4 id="4220-com_long_data"&gt;4.2.20 COM_LONG_DATA 消息报文&lt;/h4&gt;
&lt;p&gt;该消息报文有两种形式，一种用于发送二进制数据，另一种用于发送文本数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：用于发送二进制（BLOB）类型的数据（调用&lt;code&gt;mysql_stmt_send_long_data&lt;/code&gt;函数）。&lt;/p&gt;
&lt;p&gt;字节    |说明
--------|--------
4       |预处理语句的ID值（小字节序）
2       |参数序号（小字节序）
n       |数据负载（数据到达消息尾部时结束，无结束符）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：用于发送超长字符串类型的数据（调用&lt;code&gt;mysql_send_long_data&lt;/code&gt;函数）&lt;/p&gt;
&lt;p&gt;字节    |说明
--------|--------
4       |预处理语句的ID值（小字节序）
2       |参数序号（小字节序）
2       |数据类型（未使用）
n       |数据负载（数据到达消息尾部时结束，无结束符）&lt;/p&gt;
&lt;h4 id="4221-com_close_stmt"&gt;4.2.21 COM_CLOSE_STMT 消息报文&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：销毁预处理语句。&lt;/p&gt;
&lt;p&gt;字节    |说明
--------|--------
4       |预处理语句的ID值（小字节序）&lt;/p&gt;
&lt;h4 id="4222-com_reset_stmt"&gt;4.2.22 COM_RESET_STMT 消息报文&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：将预处理语句的参数缓存清空。多数情况和&lt;code&gt;COM_LONG_DATA&lt;/code&gt;一起使用。&lt;/p&gt;
&lt;p&gt;字节    |说明
--------|--------
4       |预处理语句的ID值（小字节序）&lt;/p&gt;
&lt;h4 id="4223-com_set_option"&gt;4.2.23 COM_SET_OPTION 消息报文&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：设置语句选项，选项值为&lt;code&gt;/include/mysql_com.h&lt;/code&gt;头文件中定义的&lt;code&gt;enum_mysql_set_option&lt;/code&gt;枚举类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MYSQL_OPTION_MULTI_STATEMENTS_ON&lt;/li&gt;
&lt;li&gt;MYSQL_OPTION_MULTI_STATEMENTS_OFF&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;字节    |说明
--------|--------
2       |选项值（小字节序）&lt;/p&gt;
&lt;h4 id="4224-com_fetch_stmt"&gt;4.2.24 COM_FETCH_STMT 消息报文&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：获取预处理语句的执行结果（一次可以获取多行数据）。&lt;/p&gt;
&lt;p&gt;字节    |说明
--------|--------
4       |预处理语句的ID值（小字节序）
4       |数据的行数（小字节序）&lt;/p&gt;
&lt;h3 id="43-"&gt;4.3 服务器响应报文（服务器 -&amp;gt; 客户端）&lt;/h3&gt;
&lt;p&gt;当客户端发起认证请求或命令请求后，服务器会返回相应的执行结果给客户端。客户端在收到响应报文后，需要首先检查第1个字节的值，来区分响应报文的类型。&lt;/p&gt;
&lt;p&gt;响应报文类型    |第1个字节取值范围
----------------|-----------------------
OK 响应报文     |0x00
Error 响应报文  |0xFF
Result Set 报文 |0x01 - 0xFA
Field 报文      |0x01 - 0xFA
Row Data 报文   |0x01 - 0xFA
EOF 报文        |0xFE&lt;/p&gt;
&lt;p&gt;注：响应报文的第1个字节在不同类型中含义不同，比如在OK报文中，该字节并没有实际意义，值恒为0x00；而在Result Set报文中，该字节又是长度编码的二进制数据结构（Length Coded Binary）中的第1字节。&lt;/p&gt;
&lt;h4 id="431-ok"&gt;4.3.1 OK 响应报文&lt;/h4&gt;
&lt;p&gt;客户端的命令执行正确时，服务器会返回OK响应报文。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; MySQL 4.0 及之前的版本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字节    |说明
--------|--------
1       |OK报文，值恒为0x00
1-9     |受影响行数（Length Coded Binary）
1-9     |索引ID值（Length Coded Binary）
2       |服务器状态
n       |服务器消息（字符串到达消息尾部时结束，无结束符）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; MySQL 4.1 及之后的版本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字节    |说明
--------|--------
1       |OK报文，值恒为0x00
1-9     |受影响行数（Length Coded Binary）
1-9     |索引ID值（Length Coded Binary）
2       |服务器状态
2       |告警计数
n       |服务器消息（字符串到达消息尾部时结束，无结束符，可选）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;受影响行数&lt;/strong&gt;：当执行&lt;code&gt;INSERT&lt;/code&gt;/&lt;code&gt;UPDATE&lt;/code&gt;/&lt;code&gt;DELETE&lt;/code&gt;语句时所影响的数据行数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;索引ID值&lt;/strong&gt;：该值为&lt;code&gt;AUTO_INCREMENT&lt;/code&gt;索引字段生成，如果没有索引字段，则为0x00。注意：当&lt;code&gt;INSERT&lt;/code&gt;插入语句为多行数据时，该索引ID值为第一个插入的数据行索引值，而非最后一个。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务器状态&lt;/strong&gt;：客户端可以通过该值检查命令是否在事务处理中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;告警计数&lt;/strong&gt;：告警发生的次数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务器消息&lt;/strong&gt;：服务器返回给客户端的消息，一般为简单的描述性字符串，可选字段。&lt;/p&gt;
&lt;h4 id="432-error"&gt;4.3.2 Error 响应报文&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt; MySQL 4.0 及之前的版本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字节    |说明
--------|--------
1       |Error报文，值恒为0xFF
2       |错误编号（小字节序）
n       |服务器消息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; MySQL 4.1 及之后的版本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字节    |说明
--------|--------
1       |Error报文，值恒为0xFF
2       |错误编号（小字节序）
1       |服务器状态标志，恒为'#'字符
5       |服务器状态（5个字符）
n       |服务器消息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;错误编号&lt;/strong&gt;：错误编号值定义在源代码&lt;code&gt;/include/mysqld_error.h&lt;/code&gt;头文件中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务器状态&lt;/strong&gt;：服务器将错误编号通过&lt;code&gt;mysql_errno_to_sqlstate&lt;/code&gt;函数转换为状态值，状态值由5字节的ASCII字符组成，定义在源代码&lt;code&gt;/include/sql_state.h&lt;/code&gt;头文件中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务器消息&lt;/strong&gt;：错误消息字符串到达消息尾时结束，长度可以由消息头中的长度值计算得出。消息长度为0-512字节。&lt;/p&gt;
&lt;h4 id="433-result-set"&gt;4.3.3 Result Set 消息&lt;/h4&gt;
&lt;p&gt;当客户端发送查询请求后，在没有错误的情况下，服务器会返回结果集（Result Set）给客户端。&lt;/p&gt;
&lt;p&gt;Result Set 消息分为五部分，结构如下：&lt;/p&gt;
&lt;p&gt;结构                |说明
--------------------|--------
[Result Set Header] |列数量
[Field]             |列信息（多个）
[EOF]               |列结束
[Row Data]          |行数据（多个）
[EOF]               |数据结束&lt;/p&gt;
&lt;h4 id="434-result-set-header"&gt;4.3.4 Result Set Header 结构&lt;/h4&gt;
&lt;p&gt;字节    |说明
--------|--------
1-9     |Field结构计数（Length Coded Binary）
1-9     |额外信息（Length Coded Binary）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Field结构计数&lt;/strong&gt;：用于标识Field结构的数量，取值范围0x00-0xFA。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;额外信息&lt;/strong&gt;：可选字段，一般情况下不应该出现。只有像&lt;code&gt;SHOW COLUMNS&lt;/code&gt;这种语句的执行结果才会用到额外信息（标识表格的列数量）。&lt;/p&gt;
&lt;h4 id="435-field"&gt;4.3.5 Field 结构&lt;/h4&gt;
&lt;p&gt;Field为数据表的列信息，在Result Set中，Field会连续出现多次，次数由Result Set Header结构中的IField结构计数值决定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; MySQL 4.0 及之前的版本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字节    |说明
--------|--------
n       |数据表名称（Length Coded String）
n       |列（字段）名称（Length Coded String）
4       |列（字段）长度（Length Coded String）
2       |列（字段）类型（Length Coded String）
2       |列（字段）标志（Length Coded String）
1       |整型值精度
n       |默认值（Length Coded String）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; MySQL 4.1 及之后的版本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字节    |说明
--------|--------
n       |目录名称（Length Coded String）
n       |数据库名称（Length Coded String）
n       |数据表名称（Length Coded String）
n       |数据表原始名称（Length Coded String）
n       |列（字段）名称（Length Coded String）
4       |列（字段）原始名称（Length Coded String）
1       |填充值
2       |字符编码
4       |列（字段）长度
1       |列（字段）类型
2       |列（字段）标志
1       |整型值精度
2       |填充值（0x00）
n       |默认值（Length Coded String）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目录名称&lt;/strong&gt;：在4.1及之后的版本中，该字段值为"def"。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据库名称&lt;/strong&gt;：数据库名称标识。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据表名称&lt;/strong&gt;：数据表的别名（&lt;code&gt;AS&lt;/code&gt;之后的名称）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据表原始名称&lt;/strong&gt;：数据表的原始名称（&lt;code&gt;AS&lt;/code&gt;之前的名称）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;列（字段）名称&lt;/strong&gt;：列（字段）的别名（&lt;code&gt;AS&lt;/code&gt;之后的名称）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;列（字段）原始名称&lt;/strong&gt;：列（字段）的原始名称（&lt;code&gt;AS&lt;/code&gt;之前的名称）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符编码&lt;/strong&gt;：列（字段）的字符编码值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;列（字段）长度&lt;/strong&gt;：列（字段）的长度值，真实长度可能小于该值，例如&lt;code&gt;VARCHAR(2)&lt;/code&gt;类型的字段实际只能存储1个字符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;列（字段）类型&lt;/strong&gt;：列（字段）的类型值，取值范围如下（参考源代码&lt;code&gt;/include/mysql_com.h&lt;/code&gt;头文件中的&lt;code&gt;enum_field_type&lt;/code&gt;枚举类型定义）：&lt;/p&gt;
&lt;p&gt;类型值  |名称
--------|--------
0x00    |FIELD_TYPE_DECIMAL
0x01    |FIELD_TYPE_TINY
0x02    |FIELD_TYPE_SHORT
0x03    |FIELD_TYPE_LONG
0x04    |FIELD_TYPE_FLOAT
0x05    |FIELD_TYPE_DOUBLE
0x06    |FIELD_TYPE_NULL
0x07    |FIELD_TYPE_TIMESTAMP
0x08    |FIELD_TYPE_LONGLONG
0x09    |FIELD_TYPE_INT24
0x0A    |FIELD_TYPE_DATE
0x0B    |FIELD_TYPE_TIME
0x0C    |FIELD_TYPE_DATETIME
0x0D    |FIELD_TYPE_YEAR
0x0E    |FIELD_TYPE_NEWDATE
0x0F    |FIELD_TYPE_VARCHAR (new in MySQL 5.0)
0x10    |FIELD_TYPE_BIT (new in MySQL 5.0)
0xF6    |FIELD_TYPE_NEWDECIMAL (new in MYSQL 5.0)
0xF7    |FIELD_TYPE_ENUM
0xF8    |FIELD_TYPE_SET
0xF9    |FIELD_TYPE_TINY_BLOB
0xFA    |FIELD_TYPE_MEDIUM_BLOB
0xFB    |FIELD_TYPE_LONG_BLOB
0xFC    |FIELD_TYPE_BLOB
0xFD    |FIELD_TYPE_VAR_STRING
0xFE    |FIELD_TYPE_STRING
0xFF    |FIELD_TYPE_GEOMETRY&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;列（字段）标志&lt;/strong&gt;：各标志位定义如下（参考源代码&lt;code&gt;/include/mysql_com.h&lt;/code&gt;头文件中的宏定义）：&lt;/p&gt;
&lt;p&gt;标志位  |名称
--------|--------
0x0001  |NOT_NULL_FLAG
0x0002  |PRI_KEY_FLAG
0x0004  |UNIQUE_KEY_FLAG
0x0008  |MULTIPLE_KEY_FLAG
0x0010  |BLOB_FLAG
0x0020  |UNSIGNED_FLAG
0x0040  |ZEROFILL_FLAG
0x0080  |BINARY_FLAG
0x0100  |ENUM_FLAG
0x0200  |AUTO_INCREMENT_FLAG
0x0400  |TIMESTAMP_FLAG
0x0800  |SET_FLAG&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数值精度&lt;/strong&gt;：该字段对&lt;code&gt;DECIMAL&lt;/code&gt;和&lt;code&gt;NUMERIC&lt;/code&gt;类型的数值字段有效，用于标识数值的精度（小数点位置）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;默认值&lt;/strong&gt;：该字段用在数据表定义中，普通的查询结果中不会出现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;附&lt;/strong&gt;：Field结构的相关处理函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端：&lt;code&gt;/client/client.c&lt;/code&gt;源文件中的&lt;code&gt;unpack_fields&lt;/code&gt;函数&lt;/li&gt;
&lt;li&gt;服务器：&lt;code&gt;/sql/sql_base.cc&lt;/code&gt;源文件中的&lt;code&gt;send_fields&lt;/code&gt;函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="436-eof"&gt;4.3.6 EOF 结构&lt;/h4&gt;
&lt;p&gt;EOF结构用于标识Field和Row Data的结束，在预处理语句中，EOF也被用来标识参数的结束。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; MySQL 4.0 及之前的版本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字节    |说明
--------|--------
1       |EOF值（0xFE）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; MySQL 4.1 及之后的版本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字节    |说明
--------|--------
1       |EOF值（0xFE）
2       |告警计数
2       |状态标志位&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;告警计数&lt;/strong&gt;：服务器告警数量，在所有数据都发送给客户端后该值才有效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;状态标志位&lt;/strong&gt;：包含类似&lt;code&gt;SERVER_MORE_RESULTS_EXISTS&lt;/code&gt;这样的标志位。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：由于EOF值与其它Result Set结构共用1字节，所以在收到报文后需要对EOF包的真实性进行校验，校验条件为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第1字节值为0xFE&lt;/li&gt;
&lt;li&gt;包长度小于9字节&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;附&lt;/strong&gt;：EOF结构的相关处理函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器：&lt;code&gt;protocol.cc&lt;/code&gt;源文件中的&lt;code&gt;send_eof&lt;/code&gt;函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="437-row-data"&gt;4.3.7 Row Data 结构&lt;/h4&gt;
&lt;p&gt;在Result Set消息中，会包含多个Row Data结构，每个Row Data结构又包含多个字段值，这些字段值组成一行数据。&lt;/p&gt;
&lt;p&gt;字节    |说明
--------|--------
n       |字段值（Length Coded String）
...     |（一行数据中包含多个字段值）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字段值&lt;/strong&gt;：行数据中的字段值，字符串形式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;附&lt;/strong&gt;：Row Data结构的相关处理函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端：&lt;code&gt;/client/client.c&lt;/code&gt;源文件中的&lt;code&gt;read_rows&lt;/code&gt;函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="438-row-data"&gt;4.3.8 Row Data 结构（二进制数据）&lt;/h4&gt;
&lt;p&gt;该结构用于传输二进制的字段值，既可以是服务器返回的结果，也可以是由客户端发送的（当执行预处理语句时，客户端使用Result Set消息来发送参数及数据）。&lt;/p&gt;
&lt;p&gt;字节    |说明
--------|--------
1       |结构头（0x00）
(列数量 + 7 + 2) / 8 |空位图
n       |字段值
...     |（一行数据中包含多个字段值）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;空位图&lt;/strong&gt;：前2个比特位被保留，值分别为0和1，以保证不会和OK、Error包的首字节冲突。在MySQL 5.0及之后的版本中，这2个比特位的值都为0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字段值&lt;/strong&gt;：行数据中的字段值，二进制形式。&lt;/p&gt;
&lt;h4 id="439-prepare_ok-prepared-statement"&gt;4.3.9 PREPARE_OK 响应报文（Prepared Statement）&lt;/h4&gt;
&lt;p&gt;用于响应客户端发起的预处理语句报文，组成结构如下：&lt;/p&gt;
&lt;p&gt;结构            |说明
----------------|--------
[PREPARE_OK]    |PREPARE_OK结构
如果参数数量大于0|
[Field]         |与Result Set消息结构相同
[EOF]           |
如果列数大于0|
[Field]         |与Result Set消息结构相同
[EOF]           |&lt;/p&gt;
&lt;p&gt;其中 PREPARD_OK 的结构如下：&lt;/p&gt;
&lt;p&gt;字节    |说明
--------|--------
1       |OK报文，值为0x00
4       |预处理语句ID值
2       |列数量
2       |参数数量
1       |填充值（0x00）
2       |告警计数&lt;/p&gt;
&lt;h4 id="4310-parameter-prepared-statement"&gt;4.3.10 Parameter 响应报文（Prepared Statement）&lt;/h4&gt;
&lt;p&gt;预处理语句的值与参数正确对应后，服务器会返回 Parameter 报文。&lt;/p&gt;
&lt;p&gt;字节    |说明
--------|--------
2       |类型
2       |标志
1       |数值精度
4       |字段长度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类型&lt;/strong&gt;：与 Field 结构中的字段类型相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标志&lt;/strong&gt;：与 Field 结构中的字段标志相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数值精度&lt;/strong&gt;：与 Field 结构中的数值精度相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字段长度&lt;/strong&gt;：与 Field 结构中的字段长度相同。&lt;/p&gt;
&lt;h2 id="5"&gt;5 参考资料&lt;/h2&gt;
&lt;p&gt;《&lt;a href="http://dev.mysql.com/doc/internals/en/index.html"&gt;MySQL Internals Manual&lt;/a&gt;: &lt;a href="http://dev.mysql.com/doc/internals/en/client-server-protocol.html"&gt;MySQL Client/Server Protocol&lt;/a&gt;》&lt;/p&gt;</summary><category term="Protocol"></category><category term="Database"></category><category term="MySQL"></category><category term="协议"></category><category term="数据库"></category></entry><entry><title>通过PXE方式安装Linux系统</title><link href="http://hutaow.com/blog/2013/10/30/install-linux-with-pxe" rel="alternate"></link><updated>2013-10-30T23:30:57+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2013-10-30:blog/2013/10/30/install-linux-with-pxe</id><summary type="html">&lt;hr /&gt;
&lt;h3 id="1"&gt;1 准备工作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Linux安装镜像（本文以CentOS为例）&lt;/li&gt;
&lt;li&gt;TFTP+DHCP服务程序（Windows环境中推荐Tftpd32，&lt;a href="http://tftpd32.jounin.net"&gt;点击此处进入下载页面&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;FTP服务程序（推荐FileZilla，&lt;a href="http://filezilla-project.org"&gt;点击此处进入下载页面&lt;/a&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;

&lt;h3 id="2-pxe"&gt;2 建立PXE启动目录&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;创建&lt;code&gt;E:\Server\PXE&lt;/code&gt;目录，将Linux光盘镜像&lt;code&gt;/images/pxeboot&lt;/code&gt;文件夹中的&lt;code&gt;initrd.img&lt;/code&gt;和&lt;code&gt;vmlinux&lt;/code&gt;文件拷贝到该目录中&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;E:\Server\PXE&lt;/code&gt;中创建&lt;code&gt;pxelinux.cfg&lt;/code&gt;目录，将光盘镜像&lt;code&gt;/isolinux&lt;/code&gt;文件夹中的&lt;code&gt;isolinux.cfg&lt;/code&gt;文件拷贝到该目录中，并重命名为&lt;code&gt;default&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将syslinux的PXE启动加载程序&lt;code&gt;pxelinux.0&lt;/code&gt;拷贝到&lt;code&gt;E:\Server\PXE&lt;/code&gt;目录中（可以从一个现有的Linux中拷贝一个，一般在&lt;code&gt;/usr/lib/syslinux&lt;/code&gt;或&lt;code&gt;/usr/share/syslinux&lt;/code&gt;目录中，如果找不到现成的Linux，可以&lt;a href="/downloads/linux/pxelinux.0"&gt;点击这里下载&lt;/a&gt;一个）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PXE目录建立好后，结构应该是下面的样子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/PXE/
    |- pxelinux.cfg/
    |              |- default
    |- pxelinux.0
    |- initrd.img
    |- vmlinuz
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="3"&gt;3 软件配置&lt;/h3&gt;
&lt;h4 id="31-dhcp"&gt;3.1 配置DHCP服务&lt;/h4&gt;
&lt;p&gt;配置DHCP主要有以下几个关键点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;IP Pool Starting Address&lt;/strong&gt;：192.168.0.100 &lt;em&gt;（配置DHCP分配IP的起始地址）&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Size of Pool&lt;/strong&gt;：100 &lt;em&gt;（配置DHCP的地址池大小）&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Boot File&lt;/strong&gt;：pxelinux.0 &lt;em&gt;（配置启动文件）&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外还有一个选项开关“&lt;strong&gt;Ping address before assignation&lt;/strong&gt;”（分配地址前进行Ping操作），最好将其关闭，因为打开它的情况下客户端可能出现无法及时加载启动文件的情况。&lt;/p&gt;
&lt;p&gt;配置完成后，Tftpd32应该是类似下图的样子：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tftpd32配置DHCP选项" src="/images/articles/201310/install_linux_with_pxe_dhcp.png" /&gt;&lt;/p&gt;
&lt;h4 id="32-tftp"&gt;3.2 配置TFTP服务&lt;/h4&gt;
&lt;p&gt;配置TFTP服务只需要将TFTP的目录设置对即可，其它选项用默认参数，这里目录设置为&lt;code&gt;E:\Server\PXE&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;配置完成后，Tftpd32应该是类似下图的样子：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tftpd32配置TFTP目录" src="/images/articles/201310/install_linux_with_pxe_tftp.png" /&gt;&lt;/p&gt;
&lt;h4 id="33-ftp"&gt;3.3 配置FTP服务&lt;/h4&gt;
&lt;p&gt;配置FTP比较简单，将Linux的光盘镜像解压，并将FTP服务指向解压目录即可&lt;/p&gt;
&lt;h3 id="4"&gt;4 启动安装&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;将待安装Linux的电脑设置为PXE引导方式，并等待电脑启动&lt;/li&gt;
&lt;li&gt;PXE启动成功后，屏幕上可以看到&lt;code&gt;Boot&lt;/code&gt;的提示符，输入&lt;code&gt;linux&lt;/code&gt;或直接按回车加载内核&lt;/li&gt;
&lt;li&gt;Linux内核加载后，会显示Linux的安装初始界面，选择FTP安装方式，并将前面配置好的FTP地址输入进去&lt;/li&gt;
&lt;li&gt;稍等片刻，就可以进入Linux的安装界面了&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Linux"></category><category term="PXE"></category></entry><entry><title>Linux中生成 Core Dump 文件的方法</title><link href="http://hutaow.com/blog/2013/10/25/linux-core-dump" rel="alternate"></link><updated>2013-10-25T23:19:39+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2013-10-25:blog/2013/10/25/linux-core-dump</id><summary type="html">&lt;hr /&gt;
&lt;h3 id="1-core-dump"&gt;1 什么是 Core Dump&lt;/h3&gt;
&lt;p&gt;Core Dump 又叫核心转储。在程序运行过程中发生异常时，将其内存数据保存到文件中，这个过程叫做 Core Dump。&lt;/p&gt;
&lt;h3 id="2-core-dump"&gt;2 Core Dump 的作用&lt;/h3&gt;
&lt;p&gt;在开发过程中，难免会遇到程序运行过程中异常退出的情况，这时候想要定位哪里出了问题，仅仅依靠程序自身的信息打印（日志记录）往往是不够的，这个时候就需要 Core Dump 文件来帮忙了。&lt;/p&gt;
&lt;p&gt;一个完整的 Core Dump 文件实际上相当于恢复了异常现场，利用 Core Dump 文件，可以查看到程序异常时的所有信息，变量值、栈信息、内存数据，程序异常时的运行位置（甚至记录代码行号）等等，定位所需要的一切信息都可以从 Core Dump文件获取到，能够非常有效的提高定位效率。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;h3 id="3-core-dump"&gt;3 如何生成 Core Dump&lt;/h3&gt;
&lt;h4 id="31-core-dump"&gt;3.1 Core Dump 文件生成开关&lt;/h4&gt;
&lt;p&gt;Core Dump 文件的生成是由Core文件大小限制，Linux中默认的Core文件大小设置为零，也就是不生成 Core Dump 文件，可以使用&lt;code&gt;ulimit -c&lt;/code&gt;命令来查看当前的Core文件大小限制。&lt;/p&gt;
&lt;p&gt;要生成 Core Dump 文件，只需要执行下面的命令设置Core文件的大小即可（其中&lt;code&gt;filesize&lt;/code&gt;参数的单位为KByte）：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ulimit -c filesize&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果要设置Core文件大小无限制（即把程序完整的运行内存都保存下来），则执行如下命令：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ulimit -c unlimited&lt;/code&gt;&lt;/p&gt;
&lt;h4 id="32-core-dump"&gt;3.2 Core Dump 文件名设置&lt;/h4&gt;
&lt;p&gt;Core Dump 文件默认的名字为&lt;code&gt;core&lt;/code&gt;，而且新的Core文件会把老的覆盖，这样我们只能看到最后一次的 Core Dump 信息，可以通过设置Core文件名称模板，使每次生成的 Core Dump 文件区分开来。&lt;/p&gt;
&lt;p&gt;Core Dump 文件的命名规则定义在&lt;code&gt;/proc/sys/kernel/core_pattern&lt;/code&gt;文件中，规则中还可以加入预设的变量来更好的区分Core文件，支持的变量列表如下：&lt;/p&gt;
&lt;p&gt;变量    |说明
--------|-----------
%%      |&lt;code&gt;%&lt;/code&gt;字符
%p      |进程ID(PID)
%u      |用户ID(UID)
%g      |用户组ID
%s      |触发 Core Dump 的信号
%t      |触发 Core Dump 的时间(单位为秒，从 1970-01-01 00:00:00 开始计算)
%h      |主机名称(主机名可以通过&lt;code&gt;uname&lt;/code&gt;命令来查看)
%e      |程序名称(无路径信息)
%E      |程序的路径名称(路径中的&lt;code&gt;/&lt;/code&gt;会被&lt;code&gt;!&lt;/code&gt;替代)
%c      |Core文件的限制大小值(Linux 2.6.24版本后开始支持)&lt;/p&gt;
&lt;p&gt;注：Core Dump 文件名的最大长度为128字节（在 Linux 2.6.19 版本前，最大长度为64字节）。&lt;/p&gt;
&lt;p&gt;例如：可以通过下面的命令，生成文件名为&lt;code&gt;core-程序名称-进程ID-时间&lt;/code&gt;的 Core Dump 文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;echo "core-%e-%p-%t" &amp;gt; /proc/sys/kernel/core_pattern&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从 Linux 2.4 版本开始，提供了一种比较原始的Core文件名设置方式，直接设置&lt;code&gt;/proc/sys/kernel/core_uses_pid&lt;/code&gt;文件中的值为1，生成的Core文件名中便会自动加上&lt;code&gt;.PID&lt;/code&gt;后缀，即生成的文件名为&lt;code&gt;core.PID&lt;/code&gt;这种形式。执行下面的命令可以设置该值：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;echo "1" &amp;gt; /proc/sys/kernel/core_uses_pid&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="4-core-dump"&gt;4 如何使用 Core Dump&lt;/h3&gt;
&lt;p&gt;有了 Core Dump 文件后，可以使用GDB来加载分析，执行如下命令（假设可执行程序名称及路径为&lt;code&gt;/home/hutaow/test_dump&lt;/code&gt;，生成的Core文件名为&lt;code&gt;core&lt;/code&gt;）：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gdb /home/hutaow/test_dump -c core&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;加载完成后，即可以在GDB中查看程序异常时的各种运行信息了（查看变量值、线程信息、调用栈、反汇编等等）。&lt;/p&gt;</summary><category term="Linux"></category><category term="Core Dump"></category><category term="GDB"></category><category term="定位"></category></entry><entry><title>Linux信号处理机制</title><link href="http://hutaow.com/blog/2013/10/19/linux-signal" rel="alternate"></link><updated>2013-10-19T21:47:22+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2013-10-19:blog/2013/10/19/linux-signal</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;在Linux中，信号是进程间通讯的一种方式，它采用的是异步机制。当信号发送到某个进程中时，操作系统会中断该进程的正常流程，并进入相应的信号处理函数执行操作，完成后再回到中断的地方继续执行。&lt;/p&gt;
&lt;p&gt;需要说明的是，信号只是用于通知进程发生了某个事件，除了信号本身的信息之外，并不具备传递用户数据的功能。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;h3 id="1"&gt;1 信号的响应动作&lt;/h3&gt;
&lt;p&gt;每个信号都有自己的响应动作，当接收到信号时，进程会根据信号的响应动作执行相应的操作，信号的响应动作有以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中止进程(Term)&lt;/li&gt;
&lt;li&gt;忽略信号(Ign)&lt;/li&gt;
&lt;li&gt;中止进程并保存内存信息(Core)&lt;/li&gt;
&lt;li&gt;停止进程(Stop)&lt;/li&gt;
&lt;li&gt;继续运行进程(Cont)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用户可以通过&lt;code&gt;signal&lt;/code&gt;或&lt;code&gt;sigaction&lt;/code&gt;函数修改信号的响应动作（也就是常说的“注册信号”，在文章的后面会举例说明）。另外，在多线程中，各线程的信号响应动作都是相同的，不能对某个线程设置独立的响应动作。&lt;/p&gt;
&lt;h3 id="2"&gt;2 信号类型&lt;/h3&gt;
&lt;p&gt;Linux支持的信号类型可以参考下面给出的列表。&lt;/p&gt;
&lt;h4 id="21-posix1-1990"&gt;2.1 在POSIX.1-1990标准中的信号列表&lt;/h4&gt;
&lt;p&gt;信号        |值         |动作       |说明
------------|-----------|-----------|---------------------------------
SIGHUP      |1          |Term       |终端控制进程结束(终端连接断开)
SIGINT      |2          |Term       |用户发送INTR字符(Ctrl+C)触发
SIGQUIT     |3          |Core       |用户发送QUIT字符(Ctrl+/)触发
SIGILL      |4          |Core       |非法指令(程序错误、试图执行数据段、栈溢出等)
SIGABRT     |6          |Core       |调用abort函数触发
SIGFPE      |8          |Core       |算术运行错误(浮点运算错误、除数为零等)
SIGKILL     |9          |Term       |无条件结束程序(不能被捕获、阻塞或忽略)
SIGSEGV     |11         |Core       |无效内存引用(试图访问不属于自己的内存空间、对只读内存空间进行写操作)
SIGPIPE     |13         |Term       |消息管道损坏(FIFO/Socket通信时，管道未打开而进行写操作)
SIGALRM     |14         |Term       |时钟定时信号
SIGTERM     |15         |Term       |结束程序(可以被捕获、阻塞或忽略)
SIGUSR1     |30,10,16   |Term       |用户保留
SIGUSR2     |31,12,17   |Term       |用户保留
SIGCHLD     |20,17,18   |Ign        |子进程结束(由父进程接收)
SIGCONT     |19,18,25   |Cont       |继续执行已经停止的进程(不能被阻塞)
SIGSTOP     |17,19,23   |Stop       |停止进程(不能被捕获、阻塞或忽略)
SIGTSTP     |18,20,24   |Stop       |停止进程(可以被捕获、阻塞或忽略)
SIGTTIN     |21,21,26   |Stop       |后台程序从终端中读取数据时触发
SIGTTOU     |22,22,27   |Stop       |后台程序向终端中写数据时触发&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：其中&lt;code&gt;SIGKILL&lt;/code&gt;和&lt;code&gt;SIGSTOP&lt;/code&gt;信号不能被捕获、阻塞或忽略。&lt;/p&gt;
&lt;h4 id="22-susv2posix1-2001"&gt;2.2 在SUSv2和POSIX.1-2001标准中的信号列表&lt;/h4&gt;
&lt;p&gt;信号        |值         |动作       |说明
------------|-----------|-----------|-------------------------------
SIGTRAP     |5          |Core       |Trap指令触发(如断点，在调试器中使用)
SIGBUS      |0,7,10     |Core       |非法地址(内存地址对齐错误)
SIGPOLL     |           |Term       |Pollable event (Sys V). Synonym for SIGIO
SIGPROF     |27,27,29   |Term       |性能时钟信号(包含系统调用时间和进程占用CPU的时间)
SIGSYS      |12,31,12   |Core       |无效的系统调用(SVr4)
SIGURG      |16,23,21   |Ign        |有紧急数据到达Socket(4.2BSD)
SIGVTALRM   |26,26,28   |Term       |虚拟时钟信号(进程占用CPU的时间)(4.2BSD)
SIGXCPU     |24,24,30   |Core       |超过CPU时间资源限制(4.2BSD)
SIGXFSZ     |25,25,31   |Core       |超过文件大小资源限制(4.2BSD)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：在Linux 2.2版本之前，&lt;code&gt;SIGSYS&lt;/code&gt;、&lt;code&gt;SIGXCPU&lt;/code&gt;、&lt;code&gt;SIGXFSZ&lt;/code&gt;以及&lt;code&gt;SIGBUS&lt;/code&gt;的默认响应动作为Term，Linux 2.4版本之后这三个信号的默认响应动作改为Core。&lt;/p&gt;
&lt;h4 id="23"&gt;2.3 其它信号&lt;/h4&gt;
&lt;p&gt;信号        |值         |动作       |说明
------------|-----------|-----------|-------------------------------
SIGIOT      |6          |Core       |IOT捕获信号(同SIGABRT信号)
SIGEMT      |7,-,7      |Term       |实时硬件发生错误
SIGSTKFLT   |-,16,-     |Term       |协同处理器栈错误(未使用)
SIGIO       |23,29,22   |Term       |文件描述符准备就绪(可以开始进行输入/输出操作)(4.2BSD)
SIGCLD      |-,-,18     |Ign        |子进程结束(由父进程接收)(同SIGCHLD信号)
SIGPWR      |29,30,19   |Term       |电源错误(System V)
SIGINFO     |29,-,-     |           |电源错误(同SIGPWR信号)
SIGLOST     |-,-,-      |Term       |文件锁丢失(未使用)
SIGWINCH    |28,28,20   |Ign        |窗口大小改变时触发(4.3BSD, Sun)
SIGUNUSED   |-,31,-     |Core       |无效的系统调用(同SIGSYS信号)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：列表中有的信号有三个值，这是因为部分信号的值和CPU架构有关，这些信号的值在不同架构的CPU中是不同的，三个值的排列顺序为：1，Alpha/Sparc；2，x86/ARM/Others；3，MIPS。&lt;/p&gt;
&lt;p&gt;例如&lt;code&gt;SIGSTOP&lt;/code&gt;这个信号，它有三种可能的值，分别是17、19、23，其中第一个值（17）是用在Alpha和Sparc架构中，第二个值（19）用在x86、ARM等其它架构中，第三个值（23）则是用在MIPS架构中的。&lt;/p&gt;
&lt;h3 id="3"&gt;3 信号机制&lt;/h3&gt;
&lt;p&gt;文章的前面提到过，信号是异步的，这就涉及信号何时接收、何时处理的问题。&lt;/p&gt;
&lt;p&gt;我们知道，函数运行在用户态，当遇到系统调用、中断或是异常的情况时，程序会进入内核态。信号涉及到了这两种状态之间的转换，过程可以先看一下下面的示意图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="信号处理机制示意图" src="/images/articles/201310/linux_signal_flow.png" /&gt;&lt;/p&gt;
&lt;p&gt;接下来围绕示意图，将信号分成接收、检测和处理三个部分，逐一讲解每一步的处理流程。&lt;/p&gt;
&lt;h4 id="31"&gt;3.1 信号的接收&lt;/h4&gt;
&lt;p&gt;接收信号的任务是由内核代理的，当内核接收到信号后，会将其放到对应进程的信号队列中，同时向进程发送一个中断，使其陷入内核态。&lt;/p&gt;
&lt;p&gt;注意，此时信号还只是在队列中，对进程来说暂时是不知道有信号到来的。&lt;/p&gt;
&lt;h4 id="32"&gt;3.2 信号的检测&lt;/h4&gt;
&lt;p&gt;进程陷入内核态后，有两种场景会对信号进行检测：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程从内核态返回到用户态前进行信号检测&lt;/li&gt;
&lt;li&gt;进程在内核态中，从睡眠状态被唤醒的时候进行信号检测&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当发现有新信号时，便会进入下一步，信号的处理。&lt;/p&gt;
&lt;h4 id="33"&gt;3.3 信号的处理&lt;/h4&gt;
&lt;p&gt;信号处理函数是运行在用户态的，调用处理函数前，内核会将当前内核栈的内容备份拷贝到用户栈上，并且修改指令寄存器（eip）将其指向信号处理函数。&lt;/p&gt;
&lt;p&gt;接下来进程返回到用户态中，执行相应的信号处理函数。&lt;/p&gt;
&lt;p&gt;信号处理函数执行完成后，还需要返回内核态，检查是否还有其它信号未处理。如果所有信号都处理完成，就会将内核栈恢复（从用户栈的备份拷贝回来），同时恢复指令寄存器（eip）将其指向中断前的运行位置，最后回到用户态继续执行进程。&lt;/p&gt;
&lt;p&gt;至此，一个完整的信号处理流程便结束了，如果同时有多个信号到达，上面的处理流程会在第2步和第3步骤间重复进行。&lt;/p&gt;
&lt;h3 id="4"&gt;4 信号的使用&lt;/h3&gt;
&lt;h4 id="41"&gt;4.1 发送信号&lt;/h4&gt;
&lt;p&gt;用于发送信号的函数有&lt;code&gt;raise&lt;/code&gt;、&lt;code&gt;kill&lt;/code&gt;、&lt;code&gt;killpg&lt;/code&gt;、&lt;code&gt;pthread_kill&lt;/code&gt;、&lt;code&gt;tgkill&lt;/code&gt;、&lt;code&gt;sigqueue&lt;/code&gt;，这几个函数的含义和用法都大同小异，这里主要介绍一下常用的&lt;code&gt;raise&lt;/code&gt;和&lt;code&gt;kill&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;raise函数&lt;/strong&gt;：向进程本身发送信号&lt;/p&gt;
&lt;p&gt;函数声明如下：&lt;/p&gt;
&lt;p&gt;``` c&lt;/p&gt;
&lt;h1 id="include"&gt;include &lt;signal.h&gt;&lt;/h1&gt;
&lt;p&gt;int raise(int sig);
```&lt;/p&gt;
&lt;p&gt;函数功能是向当前程序(自身)发送信号，其中参数&lt;code&gt;sig&lt;/code&gt;为信号值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;kill函数&lt;/strong&gt;：向指定进程发送信号&lt;/p&gt;
&lt;p&gt;函数声明如下：&lt;/p&gt;
&lt;p&gt;``` c&lt;/p&gt;
&lt;h1 id="include_1"&gt;include &lt;sys/types.h&gt;&lt;/h1&gt;
&lt;h1 id="include_2"&gt;include &lt;signal.h&gt;&lt;/h1&gt;
&lt;p&gt;int kill(pid_t pid, int sig);
```&lt;/p&gt;
&lt;p&gt;函数功能是向特定的进程发送信号，其中参数&lt;code&gt;pid&lt;/code&gt;为进程号，&lt;code&gt;sig&lt;/code&gt;为信号值。&lt;/p&gt;
&lt;p&gt;在这里的参数&lt;code&gt;pid&lt;/code&gt;，根据取值范围不同，含义也不同，具体说明如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pid &amp;gt; 0  ：向进程号为pid的进程发送信号&lt;/li&gt;
&lt;li&gt;pid = 0  ：向当前进程所在的进程组发送信号&lt;/li&gt;
&lt;li&gt;pid = -1 ：向所有进程(除PID=1外)发送信号(权限范围内)&lt;/li&gt;
&lt;li&gt;pid &amp;lt; -1 ：向进程组号为-pid的所有进程发送信号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，当&lt;code&gt;sig&lt;/code&gt;值为零时，实际不发送任何信号，但函数返回值依然有效，可以用于检查进程是否存在。&lt;/p&gt;
&lt;h4 id="42"&gt;4.2 等待信号被捕获&lt;/h4&gt;
&lt;p&gt;等待信号的过程，其实就是将当前进程(线程)暂停，直到有信号发到当前进程(线程)上并被捕获，函数有&lt;code&gt;pause&lt;/code&gt;和&lt;code&gt;sigsuspend&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pause函数&lt;/strong&gt;：将进程(或线程)转入睡眠状态，直到接收到信号&lt;/p&gt;
&lt;p&gt;函数声明如下：&lt;/p&gt;
&lt;p&gt;``` c&lt;/p&gt;
&lt;h1 id="include_3"&gt;include &lt;unistd.h&gt;&lt;/h1&gt;
&lt;p&gt;int pause(void);
```&lt;/p&gt;
&lt;p&gt;该函数调用后，调用者(进程或线程)会进入睡眠(Sleep)状态，直到捕获到(任意)信号为止。该函数的返回值始终为-1，并且调用结束后，错误代码(errno)会被置为EINTR。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sigsuspend函数&lt;/strong&gt;：将进程(或线程)转入睡眠状态，直到接收到特定信号&lt;/p&gt;
&lt;p&gt;函数声明如下：&lt;/p&gt;
&lt;p&gt;``` c&lt;/p&gt;
&lt;h1 id="include_4"&gt;include &lt;signal.h&gt;&lt;/h1&gt;
&lt;p&gt;int sigsuspend(const sigset_t *mask);
&lt;code&gt;``
该函数调用后，会将进程的信号掩码临时修改(参数&lt;/code&gt;mask`)，然后暂停进程，直到收到符合条件的信号为止，函数返回前会将调用前的信号掩码恢复。该函数的返回值始终为-1，并且调用结束后，错误代码(errno)会被置为EINTR。&lt;/p&gt;
&lt;h4 id="43"&gt;4.3 修改信号的响应动作&lt;/h4&gt;
&lt;p&gt;用户可以自己重新定义某个信号的处理方式，即前面提到的修改信号的默认响应动作，也可以理解为对信号的注册，可以通过&lt;code&gt;signal&lt;/code&gt;或&lt;code&gt;sigaction&lt;/code&gt;函数进行，这里以&lt;code&gt;signal&lt;/code&gt;函数举例说明。&lt;/p&gt;
&lt;p&gt;首先看一下函数声明：&lt;/p&gt;
&lt;p&gt;``` c&lt;/p&gt;
&lt;h1 id="include_5"&gt;include &lt;signal.h&gt;&lt;/h1&gt;
&lt;p&gt;typedef void (*sighandler_t)(int);&lt;/p&gt;
&lt;p&gt;sighandler_t signal(int signum, sighandler_t handler);
```&lt;/p&gt;
&lt;p&gt;第一个参数&lt;code&gt;signum&lt;/code&gt;是信号值，可以从前面的信号列表中查到，第二个参数&lt;code&gt;handler&lt;/code&gt;为处理函数，通过回调方式在信号触发时调用。&lt;/p&gt;
&lt;p&gt;下面为示例代码：&lt;/p&gt;
&lt;p&gt;``` c&lt;/p&gt;
&lt;h1 id="include_6"&gt;include &lt;stdio.h&gt;&lt;/h1&gt;
&lt;h1 id="include_7"&gt;include &lt;signal.h&gt;&lt;/h1&gt;
&lt;h1 id="include_8"&gt;include &lt;unistd.h&gt;&lt;/h1&gt;
&lt;p&gt;/&lt;em&gt; 信号处理函数 &lt;/em&gt;/
void sig_callback(int signum) {
    switch (signum) {
        case SIGINT:
            /&lt;em&gt; SIGINT: Ctrl+C 按下时触发 &lt;/em&gt;/
            printf("Get signal SIGINT. \r\n");
            break;
        /&lt;em&gt; 多个信号可以放到同一个函数中进行 通过信号值来区分 &lt;/em&gt;/
        default:
            /&lt;em&gt; 其它信号 &lt;/em&gt;/
            printf("Unknown signal %d. \r\n", signum);
            break;
    }&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; 主函数 &lt;/em&gt;/
int main(int argc, char *argv[]) {
    printf("Register SIGINT(%u) Signal Action. \r\n", SIGINT);&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* 注册SIGINT信号的处理函数 */
signal(SIGINT, sig_callback);

printf("Waitting for Signal ... \r\n");

/* 等待信号触发 */
pause();

printf("Process Continue. \r\n");

return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
```&lt;/p&gt;
&lt;p&gt;源文件下载：&lt;a href="/downloads/code/linux_signal.c"&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;例子中，将&lt;code&gt;SIGINT&lt;/code&gt;信号（&lt;code&gt;Ctrl+C&lt;/code&gt;触发）的动作接管(打印提示信息)，程序运行后，按下&lt;code&gt;Ctrl+C&lt;/code&gt;，命令行输出如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./linux_signal_example
Register SIGINT(2) Signal Action. 
Waitting for Signal ... 
^CGet signal SIGINT. 
Process Continue.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;进程收到&lt;code&gt;SIGINT&lt;/code&gt;信号后，触发响应动作，将提示信息打印出来，然后从暂停的地方继续运行。这里需要注意的是，因为我们修改了&lt;code&gt;SIGINT&lt;/code&gt;信号的响应动作（只打印信息，不做进程退出处理），所以我们按下&lt;code&gt;Ctrl+C&lt;/code&gt;后，程序并没有直接退出，而是继续运行并将"Process Continue."打印出来，直至程序正常结束。&lt;/p&gt;</summary><category term="Linux"></category><category term="Signal"></category><category term="C"></category><category term="信号"></category></entry><entry><title>函数调用栈的获取原理分析</title><link href="http://hutaow.com/blog/2013/10/15/dump-stack" rel="alternate"></link><updated>2013-10-15T23:32:31+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2013-10-15:blog/2013/10/15/dump-stack</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;上一篇文章&lt;a href="/blog/2013/10/11/dump-stack-with-backtrace"&gt;《在Linux程序中输出函数调用栈》&lt;/a&gt;，讲述了在Linux中如何利用backtrace获取调用栈，本篇文章主要介绍一下获取函数调用栈的原理，并给出相应的实现方式。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;p&gt;要了解调用栈，首先需要了解函数的调用过程，下面用一段代码作为例子：&lt;/p&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;h1 id="include"&gt;include &lt;stdio.h&gt;&lt;/h1&gt;
&lt;p&gt;int add(int a, int b) {
    int result = 0;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;result = a + b;

return result;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int main(int argc, char *argv[]) {
    int result = 0;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;result = test(1, 2);

printf("result = %d \r\n", result);

return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
```&lt;/p&gt;
&lt;p&gt;使用gcc编译，然后gdb反汇编main函数，看看它是如何调用add函数的：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(gdb) disassemble main 
Dump of assembler code for function main:
   0x08048439 &amp;lt;+0&amp;gt;:     push   %ebp
   0x0804843a &amp;lt;+1&amp;gt;:     mov    %esp,%ebp
   0x0804843c &amp;lt;+3&amp;gt;:     and    $0xfffffff0,%esp
   0x0804843f &amp;lt;+6&amp;gt;:     sub    $0x20,%esp
   0x08048442 &amp;lt;+9&amp;gt;:     movl   $0x0,0x1c(%esp)  # 给result变量赋0值
   0x0804844a &amp;lt;+17&amp;gt;:    movl   $0x2,0x4(%esp)   # 将第2个参数压栈(该参数偏移为esp+0x04)
   0x08048452 &amp;lt;+25&amp;gt;:    movl   $0x1,(%esp)      # 将第1个参数压栈(该参数偏移为esp+0x00)
   0x08048459 &amp;lt;+32&amp;gt;:    call   0x804841c &amp;lt;add&amp;gt;  # 调用add函数
   0x0804845e &amp;lt;+37&amp;gt;:    mov    %eax,0x1c(%esp)  # 将add函数的返回值赋给result变量
   0x08048462 &amp;lt;+41&amp;gt;:    mov    0x1c(%esp),%eax
   0x08048466 &amp;lt;+45&amp;gt;:    mov    %eax,0x4(%esp)
   0x0804846a &amp;lt;+49&amp;gt;:    movl   $0x8048510,(%esp)
   0x08048471 &amp;lt;+56&amp;gt;:    call   0x80482f0 &amp;lt;printf@plt&amp;gt;
   0x08048476 &amp;lt;+61&amp;gt;:    mov    $0x0,%eax
   0x0804847b &amp;lt;+66&amp;gt;:    leave  
   0x0804847c &amp;lt;+67&amp;gt;:    ret    
End of assembler dump.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可以看到，参数是在add函数调用前压栈，换句话说，参数压栈由调用者进行，参数存储在调用者的栈空间中，下面再看一下进入add函数后都做了什么：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(gdb) disassemble add
Dump of assembler code for function add:
   0x0804841c &amp;lt;+0&amp;gt;:     push   %ebp             # 将ebp压栈(保存函数调用者的栈基址)
   0x0804841d &amp;lt;+1&amp;gt;:     mov    %esp,%ebp        # 将ebp指向栈顶esp(设置当前函数的栈基址)
   0x0804841f &amp;lt;+3&amp;gt;:     sub    $0x10,%esp       # 分配栈空间(栈向低地址方向生长)
   0x08048422 &amp;lt;+6&amp;gt;:     movl   $0x0,-0x4(%ebp)  # 给result变量赋0值(该变量偏移为ebp-0x04)
   0x08048429 &amp;lt;+13&amp;gt;:    mov    0xc(%ebp),%eax   # 将第2个参数的值赋给eax(准备运算)
   0x0804842c &amp;lt;+16&amp;gt;:    mov    0x8(%ebp),%edx   # 将第1个参数的值赋给edx(准备运算)
   0x0804842f &amp;lt;+19&amp;gt;:    add    %edx,%eax        # 加法运算(edx+eax)，结果保存在eax中
   0x08048431 &amp;lt;+21&amp;gt;:    mov    %eax,-0x4(%ebp)  # 将运算结果eax赋给result变量
   0x08048434 &amp;lt;+24&amp;gt;:    mov    -0x4(%ebp),%eax  # 将result变量的值赋给eax(eax将作为函数返回值)
   0x08048437 &amp;lt;+27&amp;gt;:    leave                   # 恢复函数调用者的栈基址(pop %ebp)
   0x08048438 &amp;lt;+28&amp;gt;:    ret                     # 返回(准备执行下条指令)
End of assembler dump.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;进入add函数后，首先进行的操作是将当前的栈基址ebp压栈(此栈基址是调用者main函数的)，然后将ebp指向栈顶esp，接下来再进行函数内的处理流程。函数结束前，会将函数调用者的栈基址恢复，然后返回准备执行下一指令。这个过程中，栈上的空间会是下面的样子：&lt;/p&gt;
&lt;p&gt;&lt;img alt="函数调用过程中栈的情况" src="/images/articles/201310/dia_function_stack.png" /&gt;&lt;/p&gt;
&lt;p&gt;可以发现，每调用一次函数，都会对调用者的栈基址(ebp)进行压栈操作，并且由于栈基址是由当时栈顶指针(esp)而来，会发现，各层函数的栈基址很巧妙的构成了一个链，即当前的栈基址指向下一层函数栈基址所在的位置，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="调用栈中各层函数栈基址间的关系" src="/images/articles/201310/dia_dump_stack.png" /&gt;&lt;/p&gt;
&lt;p&gt;了解了函数的调用过程，想要回溯调用栈也就很简单了，首先获取当前函数的栈基址(寄存器ebp)的值，然后获取该地址所指向的栈的值，该值也就是下层函数的栈基址，找到下层函数的栈基址后，重复刚才的动作，即可以将每一层函数的栈基址都找出来，这也就是我们所需要的调用栈了。&lt;/p&gt;
&lt;p&gt;下面是根据原理实现的一段获取函数调用栈的代码，供参考。&lt;/p&gt;
&lt;p&gt;``` c&lt;/p&gt;
&lt;h1 id="include_1"&gt;include &lt;stdio.h&gt;&lt;/h1&gt;
&lt;p&gt;/&lt;em&gt; 打印调用栈的最大深度 &lt;/em&gt;/&lt;/p&gt;
&lt;h1 id="define-dump_stack_depth_max-16"&gt;define DUMP_STACK_DEPTH_MAX 16&lt;/h1&gt;
&lt;p&gt;/&lt;em&gt; 获取寄存器ebp的值 &lt;/em&gt;/
void get_ebp(unsigned long &lt;em&gt;ebp) {
    &lt;strong&gt;asm&lt;/strong&gt; &lt;strong&gt;volatile&lt;/strong&gt; (
        "mov %%ebp, %0"
        :"=m"(&lt;/em&gt;ebp)
        ::"memory");
}&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; 获取调用栈 &lt;/em&gt;/
int dump_stack(void **stack, int size) {
    unsigned long ebp = 0;
    int depth = 0;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* 1.得到首层函数的栈基址 */
get_ebp(&amp;amp;ebp);

/* 2.逐层回溯栈基址 */
for (depth = 0; (depth &amp;lt; size) &amp;amp;&amp;amp; (0 != ebp) &amp;amp;&amp;amp; (0 != *(unsigned long *)ebp) &amp;amp;&amp;amp; (ebp != *(unsigned long *)ebp); ++depth) {
    stack[depth] = (void *)(*(unsigned long *)(ebp + sizeof(unsigned long)));
    ebp = *(unsigned long *)ebp;
}

return depth;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; 测试函数 2 &lt;/em&gt;/
void test_meloner() {
    void *stack[DUMP_STACK_DEPTH_MAX] = {0};
    int stack_depth = 0;
    int i = 0;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* 获取调用栈 */
stack_depth = dump_stack(stack, DUMP_STACK_DEPTH_MAX);

/* 打印调用栈 */
printf(" Stack Track: \r\n");
for (i = 0; i &amp;lt; stack_depth; ++i) {
    printf(" [%d] %p \r\n", i, stack[i]);
}

return;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; 测试函数 1 &lt;/em&gt;/
void test_hutaow() {
    test_meloner();
    return;
}&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; 主函数 &lt;/em&gt;/
int main(int argc, char *argv[]) {
    test_hutaow();
    return 0;
}
```&lt;/p&gt;
&lt;p&gt;源文件下载：&lt;a href="/downloads/code/dumpstack.c"&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;执行&lt;code&gt;gcc dumpstack.c -o dumpstack&lt;/code&gt;编译并运行，执行结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; Stack Track: 
 [0] 0x8048475 
 [1] 0x8048508 
 [2] 0x804855c 
 [3] 0x804856a
&lt;/code&gt;&lt;/pre&gt;</summary><category term="C"></category><category term="Linux"></category><category term="调用栈"></category><category term="调试"></category><category term="定位"></category></entry><entry><title>在Linux程序中输出函数调用栈</title><link href="http://hutaow.com/blog/2013/10/11/dump-stack-with-backtrace" rel="alternate"></link><updated>2013-10-11T22:03:39+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2013-10-11:blog/2013/10/11/dump-stack-with-backtrace</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;程序发生异常时，将函数的调用栈打印出来，可以大大提高定位效率。&lt;/p&gt;
&lt;p&gt;Linux中提供了三个函数用来获取调用栈：&lt;/p&gt;
&lt;p&gt;``` c
/&lt;em&gt; 获取函数调用栈 &lt;/em&gt;/
int backtrace(void **buffer, int size);&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; 将调用栈中的函数地址转化为函数名称 并返回一个字符串数组 &lt;/em&gt;/
char &lt;em&gt;&lt;em&gt;backtrace_symbols(void &lt;/em&gt;const &lt;/em&gt;buffer, int size);&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; 将调用栈中的函数地址转化为函数名称 并将其定入到文件中 &lt;/em&gt;/
void backtrace_symbols_fd(void &lt;em&gt;const &lt;/em&gt;buffer, int size, int fd);
```&lt;/p&gt;
&lt;!-- more --&gt;

&lt;p&gt;示例代码：&lt;/p&gt;
&lt;p&gt;``` c&lt;/p&gt;
&lt;h1 id="include"&gt;include &lt;execinfo.h&gt;&lt;/h1&gt;
&lt;h1 id="include_1"&gt;include &lt;stdio.h&gt;&lt;/h1&gt;
&lt;h1 id="include_2"&gt;include &lt;stdlib.h&gt;&lt;/h1&gt;
&lt;p&gt;/&lt;em&gt; 打印调用栈的最大深度 &lt;/em&gt;/&lt;/p&gt;
&lt;h1 id="define-dump_stack_depth_max-16"&gt;define DUMP_STACK_DEPTH_MAX 16&lt;/h1&gt;
&lt;p&gt;/&lt;em&gt; 打印调用栈函数 &lt;/em&gt;/
void dump_trace() {
    void &lt;em&gt;stack_trace[DUMP_STACK_DEPTH_MAX] = {0};
    char &lt;/em&gt;*stack_strings = NULL;
    int stack_depth = 0;
    int i = 0;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* 获取栈中各层调用函数地址 */
stack_depth = backtrace(stack_trace, DUMP_STACK_DEPTH_MAX);

/* 查找符号表将函数调用地址转换为函数名称 */
stack_strings = (char **)backtrace_symbols(stack_trace, stack_depth);
if (NULL == stack_strings) {
    printf(" Memory is not enough while dump Stack Trace! \r\n");
    return;
}

/* 打印调用栈 */
printf(" Stack Trace: \r\n");
for (i = 0; i &amp;lt; stack_depth; ++i) {
    printf(" [%d] %s \r\n", i, stack_strings[i]);
}

/* 获取函数名称时申请的内存需要自行释放 */
free(stack_strings);
stack_strings = NULL;

return;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; 测试函数 2 &lt;/em&gt;/
void test_meloner() {
    dump_trace();
    return;
}&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; 测试函数 1 &lt;/em&gt;/
void test_hutaow() {
    test_meloner();
    return;
}&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; 主函数 &lt;/em&gt;/
int main(int argc, char *argv[]) {
    test_hutaow();
    return 0;
}
```&lt;/p&gt;
&lt;p&gt;源文件下载：&lt;a href="/downloads/code/backtrace.c"&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;编译时需要加上&lt;code&gt;-rdynamic&lt;/code&gt;参数，以得到符号名称，像下面这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcc -rdynamic backtrace.c -o backtrace
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行&lt;code&gt;./backtrace&lt;/code&gt;运行程序，输出如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Dump stack with backtrace" src="/images/articles/201310/dump_stack_with_backtrace.png" /&gt;&lt;/p&gt;</summary><category term="C"></category><category term="Linux"></category><category term="调用栈"></category><category term="调试"></category><category term="定位"></category></entry><entry><title>TP-WR703n安装OpenWRT记录</title><link href="http://hutaow.com/blog/2013/09/06/install-openwrt" rel="alternate"></link><updated>2013-09-06T23:16:00+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2013-09-06:blog/2013/09/06/install-openwrt</id><summary type="html">&lt;hr /&gt;
&lt;h3 id="1-openwrt"&gt;1 安装OpenWRT&lt;/h3&gt;
&lt;h4 id="11"&gt;1.1 下载并刷新固件&lt;/h4&gt;
&lt;p&gt;如果以前没刷过OpenWRT，需要升级factory固件，&lt;a href="http://downloads.openwrt.org/snapshots/trunk/ar71xx/openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-factory.bin" title="openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-factory.bin"&gt;点击这里下载&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果之前已经安装过了OpenWRT，则直接更新sysupgrade固件即可，&lt;a href="http://downloads.openwrt.org/snapshots/trunk/ar71xx/openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-sysupgrade.bin" title="openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-sysupgrade.bin"&gt;点击这里下载&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;注意升级的时候要将原配置删除，避免配置文件互相影响，固件刷新完成后，路由器会自动重启。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;h4 id="12"&gt;1.2 登陆路由器&lt;/h4&gt;
&lt;p&gt;OpenWRT主线固件的无线信号是默认关闭的，这个时候需要找跟网线将电脑和路由器连接上，然后将电脑的IP地址设置为静态的"192.168.1.100"，然后用Telnet访问"192.168.1.1"，正确的情况下，会看到如下界面：
&lt;img alt="First Login" src="/images/articles/201309/install_openwrt_01_first_login.png" /&gt;&lt;/p&gt;
&lt;h4 id="13"&gt;1.3 打开无线信号&lt;/h4&gt;
&lt;p&gt;编辑"/etc/config/wireless"文件，将"option disabled 1"这一行注掉，或者直接删除。&lt;/p&gt;
&lt;p&gt;```
config wifi-device radio0
    option type     mac80211
    option channel  11
    option hwmode   11ng
    option path     'platform/ar933x_wmac'
    option htmode   HT20
    list ht_capab   SHORT-GI-20
    list ht_capab   SHORT-GI-40
    list ht_capab   RX-STBC1
    list ht_capab   DSSS_CCK-40
    # REMOVE THIS LINE TO ENABLE WIFI:
    # option disabled 1&lt;/p&gt;
&lt;p&gt;config wifi-iface
    option device   radio0
    option network  lan
    option mode     ap
    option ssid     OpenWrt
    option encryption none
```&lt;/p&gt;
&lt;h4 id="14"&gt;1.4 外网接入配置&lt;/h4&gt;
&lt;p&gt;编辑"/etc/config/network"文件，将原"lan"区段中的"ifname"注掉，新增"wan"段，如果是用宽带拨号上网，则配置成下面的样子（其中USERNAME和PASSWORD分别是拨号的用户名和密码）：&lt;/p&gt;
&lt;p&gt;```
config interface 'loopback'
    option ifname 'lo'
    option proto 'static'
    option ipaddr '127.0.0.1'
    option netmask '255.0.0.0'&lt;/p&gt;
&lt;p&gt;config globals 'globals'
    option ula_prefix 'fd4f:26fb:9d78::/48'&lt;/p&gt;
&lt;p&gt;config interface 'lan'
    # option ifname 'eth0'
    option type 'bridge'
    option proto 'static'
    option ipaddr '192.168.1.1'
    option netmask '255.255.255.0'
    option ip6assign '60'&lt;/p&gt;
&lt;p&gt;config interface 'wan'
    option ifname 'eth0'
    option proto 'pppoe'
    option username 'USERNAME'
    option password 'PASSWORD'
```&lt;/p&gt;
&lt;p&gt;如果不需要拨号，直接通过其它路由器连接，则将"wan"区段配置成下面的样子：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;config interface 'wan'
    option ifname 'eth0'
    option proto 'dhcp'&lt;/code&gt;&lt;/p&gt;
&lt;h4 id="15-openwrt"&gt;1.5 重启路由器，完成OpenWRT的安装&lt;/h4&gt;
&lt;p&gt;执行reboot命令重启路由器，将外网线连上，重启后搜索无线信号，就可以看到"OpenWRT"的信号了，连接上去，不出意外的话，这个时候电脑已经可以上网了。&lt;/p&gt;
&lt;h3 id="2-openwrtu"&gt;2 将OpenWRT扩展至U盘&lt;/h3&gt;
&lt;h4 id="21"&gt;2.1 安装基本软件&lt;/h4&gt;
&lt;p&gt;再次用Telnet访问"192.168.1.1"，执行下面的命令，将挂载U盘相关的基本软件安装上。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;opkg update
opkg install block-mount kmod-fs-ext4 kmod-usb-ohci kmod-usb-storage e2fsprogs&lt;/code&gt;&lt;/p&gt;
&lt;h4 id="22-u"&gt;2.2 准备挂载U盘&lt;/h4&gt;
&lt;p&gt;将U盘插上，执行"block info"命令，看下U盘是否已被识别，如下图，其中中sda1、sda2、sda5为U盘分区：
&lt;img alt="Block Info" src="/images/articles/201309/install_openwrt_02_block_info.png" /&gt;&lt;/p&gt;
&lt;h4 id="23"&gt;2.3 拷贝系统文件&lt;/h4&gt;
&lt;p&gt;执行如下命令，将路由器ROM中的系统文件全部拷贝到U盘中：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mount /dev/sda1 /mnt 
mkdir /tmp/vroot 
mount --bind / /tmp/vroot 
cp -a /tmp/vroot/* /mnt 
sync 
umount /tmp/vroot&lt;/code&gt;&lt;/p&gt;
&lt;h4 id="24"&gt;2.4 设置交换空间（可选）&lt;/h4&gt;
&lt;p&gt;U盘在分区时可以预留一个交换分区，防止路由器内存不足，这里预留的交换分区是sda5，执行下面的命令：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;swapon /dev/sda5&lt;/code&gt;&lt;/p&gt;
&lt;h4 id="25"&gt;2.5 保存挂载信息&lt;/h4&gt;
&lt;p&gt;将当前挂载状态写入fstab文件中：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;block detect &amp;gt; /etc/config/fstab&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后修改"/etc/config/fstab"文件，将sda1的挂载点设置为"/"，并将"option enabled"置1，配置类似下面的样子：&lt;/p&gt;
&lt;p&gt;```
config global
    option anon_swap '0'
    option anon_mount '0'
    option auto_swap '1'
    option auto_mount '1'
    option delay_root '5'
    option check_fs '0'&lt;/p&gt;
&lt;p&gt;config mount
    option target '/'
    option uuid '413b964c-9c9c-4af4-8966-daf04ee53414'
    option enabled '1'
    option fstype 'ext4'&lt;/p&gt;
&lt;p&gt;config mount
    option target '/home'
    option uuid 'e7052ed0-b883-4375-9f31-5648ea8f2948'
    option enabled '1'
    option fstype 'ext4'&lt;/p&gt;
&lt;p&gt;config swap
    option uuid '58713d02-e9de-4c23-a56b-a5ea3d3dfcf0'
    option enabled '1'
```&lt;/p&gt;
&lt;p&gt;如果U盘只有一个分区，会只看到一个sda1("/")，其它诸如sda2("/home")、sda5("swap")需要额外分区才能看到。&lt;/p&gt;
&lt;h4 id="26-openwrt"&gt;2.6 重启路由器，完成OpenWRT的扩展&lt;/h4&gt;
&lt;p&gt;重启路由器，再次"df -h"一下，可以看到路由器的空间已经扩展成功了。
&lt;img alt="DF Info" src="/images/articles/201309/install_openwrt_03_df.png" /&gt;&lt;/p&gt;</summary><category term="Network"></category><category term="OpenWRT"></category><category term="路由器"></category></entry><entry><title>Linux中分区出现“Read-only file system”的解决办法</title><link href="http://hutaow.com/blog/2013/06/16/slove-the-read-only-file-system-problem-in-linux" rel="alternate"></link><updated>2013-06-16T22:54:00+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2013-06-16:blog/2013/06/16/slove-the-read-only-file-system-problem-in-linux</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;最近发现手机上TF卡权限显示是可写入的，但无法向TF卡写入文件，并提示“Read-only file system”，用下面的命令重新挂载一下就可以了：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mount -o remount,rw /media/TF&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注：其中”/media/TF“是挂载的目录。&lt;/p&gt;</summary><category term="Linux"></category></entry><entry><title>Linux中批量设置目录或文件权限的方法</title><link href="http://hutaow.com/blog/2013/06/16/batch-settings-directory-or-file-permissions" rel="alternate"></link><updated>2013-06-16T01:48:00+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2013-06-16:blog/2013/06/16/batch-settings-directory-or-file-permissions</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;递归方式将当前目录下所有的子目录设置为755权限（不包括文件）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;find ./ -type d -exec chmod 755 {} \;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;递归方式将当前目录下的所有文件设置为644权限（包括子目录下的文件，但不对目录本身设置权限）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;find ./ -type f -exec chmod 644 {} \;&lt;/code&gt;&lt;/p&gt;</summary><category term="Linux"></category><category term="find"></category><category term="chmod"></category></entry><entry><title>配置 Cisco Catalyst 3560 交换机端口镜像</title><link href="http://hutaow.com/blog/2010/05/14/config-cisco-catalyst-3560-switch-port-mirroring" rel="alternate"></link><updated>2010-05-14T22:13:00+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2010-05-14:blog/2010/05/14/config-cisco-catalyst-3560-switch-port-mirroring</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;假设要将19和27号端口的数据镜像到2号端口，按如下操作进行：&lt;/p&gt;
&lt;p&gt;1) 通过串口登陆到交换机，其中参数设置为：速率9600bps，8位数据位，1位停止位，无奇偶校验，无流量控制。&lt;/p&gt;
&lt;p&gt;2) 交换机上电自检然后登入后出现命令提示符：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Switch&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;!-- more --&gt;

&lt;p&gt;3) 依次进入特权模式和全局模式，输入如下命令：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Switch&amp;gt;enable
Password:
Switch#configure terminal
Enter configuration commands, one per line.  End with CNTL/Z.
Switch(config)#&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;4) 在新session中，将端口19和27设置为被监听端口(source)，2号端口设置为监听端口(destination)，命令如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Switch(config)#monitor session 1 source interface Fa0/19
Switch(config)#monitor session 1 source interface Fa0/27
Switch(config)#monitor session 1 destination interface Fa0/2
Switch(config)#end
Switch#
03:30:52: %SYS-5-CONFIG_I: Configured from console by console&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;5) 断开连接，完成。&lt;/p&gt;</summary><category term="Network"></category><category term="CISCO"></category><category term="交换机"></category></entry><entry><title>C#获取XML文件指定节点的数据</title><link href="http://hutaow.com/blog/2010/04/27/get-xml-node-value-with-c-sharp-language" rel="alternate"></link><updated>2010-04-27T12:43:00+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2010-04-27:blog/2010/04/27/get-xml-node-value-with-c-sharp-language</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;实例说明会更清楚些，假设有如下XML文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xml message_hutaow.xml
&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
&amp;lt;Message version="1.0"&amp;gt;
  &amp;lt;Head&amp;gt;
    &amp;lt;Date&amp;gt;20080502&amp;lt;/Date&amp;gt;
    &amp;lt;Source&amp;gt;
      &amp;lt;Address&amp;gt;192.168.0.1&amp;lt;/Address&amp;gt;
      &amp;lt;Name&amp;gt;hutaow&amp;lt;/Name&amp;gt;
    &amp;lt;/Source&amp;gt;
    &amp;lt;Target&amp;gt;
      &amp;lt;Address&amp;gt;192.168.0.19&amp;lt;/Address&amp;gt;
    &amp;lt;/Target&amp;gt;
  &amp;lt;/Head&amp;gt;
&amp;lt;/Message&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;现在要读取消息源IP地址(192.168.0.1)和目的IP地址(192.168.0.19)。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;p&gt;根据上面XML文件的结构，查找路径为"/Message/Head/Source/Address"和"/Message/Head/Target/Address"，需要用到XPath的寻径方式，代码如下：&lt;/p&gt;
&lt;p&gt;``` c#
// 需要引用System.Xml库
using System.Xml;&lt;/p&gt;
&lt;p&gt;// 省略中间无关代码&lt;/p&gt;
&lt;p&gt;// 加载XML文件
XmlDocument xmlDoc = new XmlDocument();
xmlDoc.Load("message_hutaow.xml");&lt;/p&gt;
&lt;p&gt;// 使用XPath方式寻找源IP地址节点并输出
xmlNode = xmlDoc.SelectSingleNode("/Message/Head/Source/Address");
Console.WriteLine("Source Address: {0}",xmlNode.InnerText);&lt;/p&gt;
&lt;p&gt;// 使用XPath方式寻找目的IP地址节点并输出
xmlNode = xmlDoc.SelectSingleNode("/Message/Head/Target/Address");
Console.WriteLine("Target Address: {0}",xmlNode.InnerText);
```&lt;/p&gt;
&lt;p&gt;控制台输出
    Source Address: 192.168.0.1
    Target Address: 192.168.0.19&lt;/p&gt;</summary><category term="CSharp"></category><category term="XML"></category></entry><entry><title>Snort安装IDMEF插件</title><link href="http://hutaow.com/blog/2010/04/21/install-idmef-plugin-for-snort" rel="alternate"></link><updated>2010-04-21T10:48:00+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2010-04-21:blog/2010/04/21/install-idmef-plugin-for-snort</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;Snort作为一款开源的入侵检测系统，可以与其它各种网络设备连接协同工作，其中IDMEF插件可以实现设备之间报警信息的共享，在安装该插件时，需要注意以下几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;IDMEF插件依赖于&lt;a href="http://sourceforge.net/projects/libidmef"&gt;libidmef&lt;/a&gt;、&lt;a href="http://xmlsoft.org"&gt;libxml2&lt;/a&gt;及&lt;a href="http://www.ntp.org"&gt;libntp&lt;/a&gt;库，所以在安装Snort之前，需要首先安装这三个库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置Snort时，需要加上"--enable-idmef"参数，如下所示：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;./configure --enable-idmef
make
make install&lt;/code&gt;&lt;/p&gt;</summary><category term="Security"></category><category term="IDS"></category><category term="Snort"></category><category term="信息安全"></category><category term="入侵检测"></category></entry><entry><title>入侵检测与响应系统的信息共享</title><link href="http://hutaow.com/blog/2010/04/17/intrusion-dedection-and-response-system-for-information-sharing" rel="alternate"></link><updated>2010-04-17T21:25:00+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2010-04-17:blog/2010/04/17/intrusion-dedection-and-response-system-for-information-sharing</id><summary type="html">&lt;hr /&gt;
&lt;h3 id="_1"&gt;引言&lt;/h3&gt;
&lt;p&gt;入侵检测系统(IDS)与其它系统(如防火墙)交互过程中，需要遵循一定的规范和协议，然而生产IDS的各个厂家的报警日志及数据格式均有所区别，所以在不同设备之间交互会遇到很多麻烦。早先知道的是CheckPoint提出的OPSec协议和天融信提出的TOPSec协议，凡是遵循这两个协议的网络安全设备均可与相应的IDS进行交互，协同防护网络安全。在2007年，IETF针对这种交互情况形成了四份相关文档，分为三个部分，分别是隧道轮廓(RFC3620 - The TUNNEL Profile)、入侵检测消息交换格式和要求(RFC4765 - IDMEF, RFC4766 - IDMER)、入侵检测交换协议(RFC4767 - IDXP)。&lt;/p&gt;
&lt;p&gt;值得注意的是，IETF规定IDS对其它设备交互的方式采用XML格式存储和传输，和SOAP似乎有些相似，XML跨平台跨语言结构清晰等优点使它的应用范围越来越广，几乎达到了无处不用XML的程度。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;h3 id="1"&gt;1 入侵检测消息交互过程&lt;/h3&gt;
&lt;h4 id="11"&gt;1.1 建立连接&lt;/h4&gt;
&lt;p&gt;使用IDXP传输数据的入侵检测实体被称为IDXP对等体。对等体只能成对出现，这些对等体通过BEEP会话中的一个或多个BEEP信道进行数据传输。对等体可能是管理器或分析器。&lt;/p&gt;
&lt;p&gt;在分析器和管理器之间很可能是多对多的关系。即一个分析器可以和多个管理器通信，同样，一个管理器也可以和多个分析器通信；在不同的管理器之间也可以是多对多的关系。所以，一个管理器可以通过多个中间管理器接收大量的来自分析器的报警信息。但是，各个分析器之间禁止建立IDXP连接，避免重复报警情况的发生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对等体"Alice"和"Bob"建立IDXP交换的过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;IDXP对等体之间通过打开一个BEEP信道进行通信。在打开BEEP信道之前，需要首先建立BEEP会话，然后就安全特性等问题进行协商。BEEP安全轮廓协商成功后，再经互相确认应答，然后开始IDXP交换。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Alice                                               Bob
  ------------------- 建立连接(1) --------------------&amp;gt;
&amp;lt;---------------------- 问候 ------------------------&amp;gt;
&amp;lt;------------------ 启动安全轮廓(2) ------------------&amp;gt;
&amp;lt;---------------------- 问候 ------------------------&amp;gt;
&amp;lt;------------------- 启动 IDXP(3) -------------------&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;交互过程:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;"Alice"建立一个到'Bob'的连接, 并触发交换二者BEEP问候消息&lt;/li&gt;
&lt;li&gt;两个实体协商BEEP安全轮廓&lt;/li&gt;
&lt;li&gt;两个实体协商IDXP轮廓&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;对等体"Alice"和"Bob"通过代理服务器建立IDXP交换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在一对IDXP对等体之间可以存在多个代理，这些代理可能是因为管理的需要。比如透过防火墙进行受限访问，或是将公司各部门分析器的数据转发到公司总管理器。&lt;/p&gt;
&lt;p&gt;在使用代理转发数据时，会使用BEEP协调轮廓建立一个应用层的隧道。隧道轮廓(详细见"RFC3620 - The TUNNEL profile")即在此时发挥作用。在创建应用层隧道时，必须建立一个作为协调轮廓的隧道，并且该隧道轮廓需要进行SASL认证。隧道建立完成后，BEEP安全轮廓才可以提供IDXP协商时需要的各项安全特性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Alice              proxy1               proxy2               Bob
  ----- 建立连接 ----&amp;gt;
&amp;lt;------ 问候 -------&amp;gt;
  ---- 启动隧道 -----&amp;gt;
                      --- 建立连接(1) ----&amp;gt;
                    &amp;lt;------- 问候 -------&amp;gt;
                      ----- 启动隧道 -----&amp;gt;
                                           ----- 建立连接 -----&amp;gt;
                                         &amp;lt;------- 问候 -------&amp;gt;
                                           ----- 启动隧道 -----&amp;gt;
                                         &amp;lt;---- &amp;lt;确认&amp;gt;(2) -----
                    &amp;lt;------ &amp;lt;确认&amp;gt; ------
&amp;lt;----- &amp;lt;确认&amp;gt; ------
&amp;lt;--------------------------- 问候 ----------------------------&amp;gt;
&amp;lt;----------------------- 启动安全轮廓 -------------------------&amp;gt;
&amp;lt;--------------------------- 问候 ----------------------------&amp;gt;
&amp;lt;------------------------- 启动 IDXP -------------------------&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;交互过程:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;收到"Alice"启动隧道的消息后，"proxy1"并没有立即返回确认消息，而是先试图和"proxy"连接以建立隧道。同样的，"proxy2"也不会立即给"proxy1"返回确认消息&lt;/li&gt;
&lt;li&gt;"Bob"的确认信息首先到达"proxy2"并且与之启动隧道，然后确认消息会传递下去最终返回给"Alice"，最终"Alice"和"Bob"之间就成功建立了应用层的隧道&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="12"&gt;1.2 数据传输&lt;/h4&gt;
&lt;p&gt;在一对入侵检测实体通过BEEP会话进行通信时，会使用IDXP轮廓打开一个或多个BEEP信道。如果需要，可以用IDXP轮廓建立更多的BEEP会话，以提供额外的信道。但是在多数情况下，还是应该在已有的BEEP会话中添加新的信道，尽量避免用新建BEEP会话的方式添加信道。&lt;/p&gt;
&lt;p&gt;在每条信道中，对等体都是以客户端/服务器形式进行通信。客户端和服务器的角色扮演决定于建立BEEP会话的发起者和监听者。即发起者为客户端，监听者为服务器。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+----------+                          +----------+
|          |                          |          |
|          |******** BEEP 会话 ********|          |
|          |                          |          |
|  分析器   | ------- IDXP 轮廓 ------&amp;gt; |  管理器   |
| (客户端)  |                          | (服务端)  |
|          |                          |          |
|          |**************************|          |
|          |                          |          |
+----------+                          +----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在一个BEEP会话中使用多个BEEP信道的方式对IDXP对等体之间传输数据的分类和优先级的管理非常有利。例如，管理器"M1"向"M2"发送报警数据时，可以将不同类型的信息使用单独的信道进行传输。"M1"在这些信道中扮演了客户端的角色，"M2"则对接收到的报警信息根据其不同类型进行相应处理。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+----------+                                            +----------+
|          |                                            |          |
|          |**************** BEEP 会话 ******************|          |
|          |                                            |          |
|          | ------- IDXP 轮廓, 基于网络的报警信息 -------&amp;gt; |          |
|  管理器   |                                            |  管理器   |
|    M1    | ------- IDXP 轮廓, 基于主机的报警信息 -------&amp;gt; |    M2    |
| (客户端)  |                                            | (服务端)  |
|          | ---------- IDXP 轮廓, 其它报警信息 ---------&amp;gt; |          |
|          |                                            |          |
|          |********************************************|          |
|          |                                            |          |
+----------+                                            +----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="13"&gt;1.3 断开连接&lt;/h4&gt;
&lt;p&gt;在一些情况下(如处理过程中出现错误)，IDXP对等体可以关闭某个IDXP信道。要关闭某条信道，需要在零号信道上发送一条"关闭"的指令，并且指明所关闭的信道。如果想要关闭整个BEEP会话，只需在零号信道上发送一条要求"关闭"零信道的指令即可。&lt;/p&gt;
&lt;p&gt;由于应用层隧道和BEEP安全轮廓会经常使用，所以凡是包含IDXP信道的BEEP会话将会一直存活下去。同时，为了避免IDXP信道被反复的建立，系统会一直保持这些IDXP信道的连接，即使当前已经没有数据在上面传输。建议当IDXP对等体在合适的时候，手动关闭并重建BEEP会话。&lt;/p&gt;
&lt;h4 id="14"&gt;1.4 可信模型&lt;/h4&gt;
&lt;p&gt;在以上的模型中，BEEP安全轮廓是建立在IDXP对等体之间从而实现的端到端安全，而无需对中间代理建立信任。因此，只有在安全轮廓下经过协商后的IDXP对等体之间是相互信任的，而代理始终被看作是不可信的。&lt;/p&gt;
&lt;h3 id="2"&gt;2 入侵检测消息交换格式&lt;/h3&gt;
&lt;h4 id="21-idmef"&gt;2.1 IDMEF数据模型&lt;/h4&gt;
&lt;p&gt;IDMEF数据模型的各主要部分关系如下图所示（这里省略了事件指示器和属性）。
&lt;img alt="数据模型" src="/images/articles/201004/intrusion_dedection_and_response_system_for_information_sharing.png" /&gt;&lt;/p&gt;
&lt;p&gt;IDMEF消息的最高层类是"IDMEF-Message"，其它各类型消息都是该类的子类。目前IDMEF定义了两种消息："Alerts"和"Heartbeats"。其中这两个消息各自携带不同的子类，各子类又描述了更加详细的信息。&lt;/p&gt;
&lt;p&gt;需要注意的是，数据模型并没有指明警报信息如何分类和识别。例如，端口扫描这一行为，它可能被分析器识别为一次单点对多目标的攻击，同时被另一分析器识别为多次的单点攻击。所有，只有在分析器确定了报警类型之后，数据模型才能确定如何对报警数据进行格式化。&lt;/p&gt;
&lt;h4 id="22"&gt;2.2 示例&lt;/h4&gt;
&lt;p&gt;IDMEF数据模型最终是以XML形式实现，XML跨平台、跨语言以及强扩展性的特点保证了IDS设备之间共享信息时良好的兼容性。&lt;/p&gt;
&lt;p&gt;下面用实例说明IDMEF对报警信息封装的格式。这些例子只是为说明用，不具备代表性。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xml 基于网络检测到的某次泪滴攻击报警信息
&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
   &amp;lt;idmef:IDMEF-Message xmlns:idmef="http://iana.org/idmef" version="1.0"&amp;gt;
     &amp;lt;idmef:Alert messageid="abc123456789"&amp;gt;
       &amp;lt;idmef:Analyzer analyzerid="hq-dmz-analyzer01"&amp;gt;
         &amp;lt;idmef:Node category="dns"&amp;gt;
           &amp;lt;idmef:location&amp;gt;Headquarters DMZ Network&amp;lt;/idmef:location&amp;gt;
           &amp;lt;idmef:name&amp;gt;analyzer01.example.com&amp;lt;/idmef:name&amp;gt;
         &amp;lt;/idmef:Node&amp;gt;
       &amp;lt;/idmef:Analyzer&amp;gt;
       &amp;lt;idmef:CreateTime ntpstamp="0xbc723b45.0xef449129"&amp;gt;
         2000-03-09T10:01:25.93464-05:00
       &amp;lt;/idmef:CreateTime&amp;gt;
       &amp;lt;idmef:Source ident="a1b2c3d4"&amp;gt;
         &amp;lt;idmef:Node ident="a1b2c3d4-001" category="dns"&amp;gt;
           &amp;lt;idmef:name&amp;gt;badguy.example.net&amp;lt;/idmef:name&amp;gt;
           &amp;lt;idmef:Address ident="a1b2c3d4-002" category="ipv4-net-mask"&amp;gt;
             &amp;lt;idmef:address&amp;gt;192.0.2.50&amp;lt;/idmef:address&amp;gt;
             &amp;lt;idmef:netmask&amp;gt;255.255.255.255&amp;lt;/idmef:netmask&amp;gt;
           &amp;lt;/idmef:Address&amp;gt;
         &amp;lt;/idmef:Node&amp;gt;
       &amp;lt;/idmef:Source&amp;gt;
       &amp;lt;idmef:Target ident="d1c2b3a4"&amp;gt;
         &amp;lt;idmef:Node ident="d1c2b3a4-001" category="dns"&amp;gt;
           &amp;lt;idmef:Address category="ipv4-addr-hex"&amp;gt;
             &amp;lt;idmef:address&amp;gt;0xde796f70&amp;lt;/idmef:address&amp;gt;
           &amp;lt;/idmef:Address&amp;gt;
         &amp;lt;/idmef:Node&amp;gt;
       &amp;lt;/idmef:Target&amp;gt;
       &amp;lt;idmef:Classification text="Teardrop detected"&amp;gt;
         &amp;lt;idmef:Reference origin="bugtraqid"&amp;gt;
           &amp;lt;idmef:name&amp;gt;124&amp;lt;/idmef:name&amp;gt;
           &amp;lt;idmef:url&amp;gt;http://www.securityfocus.com/bid/124&amp;lt;/idmef:url&amp;gt;
         &amp;lt;/idmef:Reference&amp;gt;
       &amp;lt;/idmef:Classification&amp;gt;
     &amp;lt;/idmef:Alert&amp;gt;
   &amp;lt;/idmef:IDMEF-Message&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xml 基于网络检测到的某个端口扫描行为（注意&amp;lt;portlist&amp;gt;中记录了被扫描的端口列表）
&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
   &amp;lt;idmef:IDMEF-Message version="1.0" xmlns:idmef="http://iana.org/idmef"&amp;gt;
     &amp;lt;idmef:Alert messageid="abc123456789"&amp;gt;
       &amp;lt;idmef:Analyzer analyzerid="hq-dmz-analyzer62"&amp;gt;
         &amp;lt;idmef:Node category="dns"&amp;gt;
           &amp;lt;idmef:location&amp;gt;Headquarters Web Server&amp;lt;/idmef:location&amp;gt;
           &amp;lt;idmef:name&amp;gt;analyzer62.example.com&amp;lt;/idmef:name&amp;gt;
         &amp;lt;/idmef:Node&amp;gt;
       &amp;lt;/idmef:Analyzer&amp;gt;
       &amp;lt;idmef:CreateTime ntpstamp="0xbc72b2b4.0x00000000"&amp;gt;
         2000-03-09T15:31:00-08:00
       &amp;lt;/idmef:CreateTime&amp;gt;
       &amp;lt;idmef:Source ident="abc01"&amp;gt;
         &amp;lt;idmef:Node ident="abc01-01"&amp;gt;
           &amp;lt;idmef:Address ident="abc01-02" category="ipv4-addr"&amp;gt;
             &amp;lt;idmef:address&amp;gt;192.0.2.200&amp;lt;/idmef:address&amp;gt;
           &amp;lt;/idmef:Address&amp;gt;
         &amp;lt;/idmef:Node&amp;gt;
       &amp;lt;/idmef:Source&amp;gt;
       &amp;lt;idmef:Target ident="def01"&amp;gt;
         &amp;lt;idmef:Node ident="def01-01" category="dns"&amp;gt;
           &amp;lt;idmef:name&amp;gt;www.example.com&amp;lt;/idmef:name&amp;gt;
           &amp;lt;idmef:Address ident="def01-02" category="ipv4-addr"&amp;gt;
             &amp;lt;idmef:address&amp;gt;192.0.2.50&amp;lt;/idmef:address&amp;gt;
           &amp;lt;/idmef:Address&amp;gt;
         &amp;lt;/idmef:Node&amp;gt;
         &amp;lt;idmef:Service ident="def01-03"&amp;gt;
           &amp;lt;idmef:portlist&amp;gt;5-25,37,42,43,53,69-119,123-514
           &amp;lt;/idmef:portlist&amp;gt;
         &amp;lt;/idmef:Service&amp;gt;
       &amp;lt;/idmef:Target&amp;gt;
       &amp;lt;idmef:Classification text="simple portscan"&amp;gt;
         &amp;lt;idmef:Reference origin="vendor-specific"&amp;gt;
           &amp;lt;idmef:name&amp;gt;portscan&amp;lt;/idmef:name&amp;gt;
           &amp;lt;idmef:url&amp;gt;http://www.vendor.com/portscan&amp;lt;/idmef:url&amp;gt;
         &amp;lt;/idmef:Reference&amp;gt;
       &amp;lt;/idmef:Classification&amp;gt;
     &amp;lt;/idmef:Alert&amp;gt;
   &amp;lt;/idmef:IDMEF-Message&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="3"&gt;3 参考资料&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;1. RFC4765 - The Intrusion Detection Message Exchange Format (IDMEF)
2. RFC4767 - The Intrusion Detection Exchange Protocol (IDXP)
&lt;/code&gt;&lt;/pre&gt;</summary><category term="Security"></category><category term="IDS"></category><category term="信息安全"></category><category term="入侵检测"></category></entry><entry><title>字符串中单词逆序的实现</title><link href="http://hutaow.com/blog/2010/04/13/reverse-order-of-words-in-a-string" rel="alternate"></link><updated>2010-04-13T19:35:00+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2010-04-13:blog/2010/04/13/reverse-order-of-words-in-a-string</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;在Java中可以用压栈/弹栈的方式：&lt;/p&gt;
&lt;!-- more --&gt;

&lt;p&gt;``` java
import java.util.Stack;&lt;/p&gt;
&lt;p&gt;public class StackTest {
    public static void main(String argv[]) {
        Stack&lt;String&gt; stack = new Stack&lt;String&gt;();
        for(String s : "I have a round peach".split(" ")) {
            // 按字符串原顺序压栈
            stack.push(s);
        }&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    while(!stack.empty()) {
        // 弹栈并输出
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;System.out.print(stack.pop() + " ");
        }
    }
}
```&lt;/p&gt;
&lt;p&gt;运行后系统将输出 "peach round a have I "。&lt;/p&gt;</summary><category term="Java"></category></entry><entry><title>正斜杠与反斜杠的分析</title><link href="http://hutaow.com/blog/2010/01/30/analysis-of-the-forward-slash-and-backslash" rel="alternate"></link><updated>2010-01-30T00:29:00+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2010-01-30:blog/2010/01/30/analysis-of-the-forward-slash-and-backslash</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;正斜杠(左斜杠)，符号是"/"；反斜杠(右斜杠)，符号是"\"。&lt;/p&gt;
&lt;p&gt;在Unix/Linux中，路径的分隔采用正斜杠"/"，比如"/home/hutaow"；而在Windows中，路径分隔采用反斜杠"\"，比如"C:\Windows\System"。&lt;/p&gt;
&lt;p&gt;有时我们会看到这样的路径写法，"C:\\Windows\\System"，也就是用两个反斜杠来分隔路径，这种写法在网络应用或编程中经常看到，事实上，上面这个路径可以用"C:/Windows/System"来代替，不会出错。但是如果写成了"C:\Windows\System"，那就可能会出现各种奇怪的错误了。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;p&gt;至于上述问题出现的原因，要从字符串解析这方面来分析。&lt;/p&gt;
&lt;p&gt;学过编程的人都应该知道，在C里面，输出字符串时，如果想输出一个换行，那就要加上'\n'这个标志，类似的，输出一个TAB，就加上'\t'，也就是说，反斜杠("\")这个符号会把跟在它后面的字符结合起来转义成其它字符。根据这个原理，如果想输出双引号('"')，就需要输入'\"'，这样才会将包含了双引号的字符串正确的写入内存中。那么如果想输入一个反斜杠呢？很简单，只要敲'\\'就可以了。&lt;/p&gt;
&lt;p&gt;看到这里或许有些人已经看出眉目了，如果"C:\Windows\System"这个路径字符串交给C编译器编译，实际写入内存的字符串并没有包含反斜杠"\"，甚至紧跟在反斜杠后面的字母也一起被转义成了其它的字符，再次调用的话势必会出问题。&lt;/p&gt;
&lt;p&gt;字符串解析不仅仅局限于C编译器，Java编译器、一些配置文件的解析、Web服务器等等，都会遇到对字符串进行解析的这个问题，由于传统的Windows采用的是单个斜杠的路径分隔形式，导致在对文件路径进行解析的时候可能发生不必要的错误，所以就出现了用双反斜杠"\\"分隔路径的形式。不管解析引擎是否将反斜杠解析成转义字符，最终在内存中得到的都是"\"，结果也就不会出问题了。&lt;/p&gt;
&lt;p&gt;由此也可以看出Windows或者说DOS在设计初期考虑不够周全，为了和Unix一些特征区别开来，将Unix中的正斜杠"/"分隔路径方式改变成了反斜杠"\"。这样改变导致的一个问题就是在早期DOS命令行中，正常的文件名是不能包含空格的，如果包含了空格，会导致输入这样的文件名时，命令解析无法将其和参数区分开。例如，想要进入"hutaow yuan"这个目录（在此先忽略8.3命名规则），直接输入"cd hutaow yuan"，命令行会将其解析为进入"hutaow"目录，而后面的"yuan"做参数，这显然不是所期望的。&lt;/p&gt;
&lt;p&gt;而在Unix中，文件名如果包含空格，可以直接在空格前加上反斜杠"\"进行转义，从而很好的和命令参数区别出来（参数之间一般使用空格分隔）。还是上面的例子，在Unix中，只要输入"cd hutaow\ yuan"(在yuan前面的空格前加上"\")，命令行会正确的辨认出"hutaow yuan"并进入这个目录。&lt;/p&gt;
&lt;p&gt;当然，现在Windows的后续版本已经使用其它方法（比如文件名用双引号括住）解决了空格问题。&lt;/p&gt;</summary></entry><entry><title>HTC Diamond 两个有意思的功能</title><link href="http://hutaow.com/blog/2010/01/14/interesting-features-in-htc-diamond" rel="alternate"></link><updated>2010-01-14T20:28:00+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2010-01-14:blog/2010/01/14/interesting-features-in-htc-diamond</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;这两天一直折腾 HTC Diamond，发现了两个很有意思的功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Diamond的手写笔不像其它手机那样有卡槽卡住，而是像有磁铁一样把笔"吸"进去，实际上功能远不止这个。在Diamond关闭屏幕时，拔出手写笔，屏幕会自动亮起，还有比这更神奇的，在打电话时，如果拔出手写笔，Diamond会打开便签，并且便签已经包含了通话对象、时间等信息，方便记录；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Diamond的重力感应不仅用在玩游戏上，来电话时，只要把手机面向下放，就可以关闭铃声（静音）。这避免了在开会等类似场合突然遇到来电手忙脚乱情况的发生。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary><category term="HTC"></category></entry><entry><title>Xmarks(原Foxmarks)被墙之后更新的方法</title><link href="http://hutaow.com/blog/2010/01/12/slove-the-problem-that-xmarks-was-block-by-gfw" rel="alternate"></link><updated>2010-01-12T22:53:00+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2010-01-12:blog/2010/01/12/slove-the-problem-that-xmarks-was-block-by-gfw</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;最近重新装上Xmarks书签同步之后，发现不能用了，还以为设置出了问题，上官网发现已经上不去了，被GFW屏蔽了。于是上网查找解决办法，总结如下：&lt;/p&gt;
&lt;h4 id="1-cwindowssystem32driversetchosts"&gt;1. 手动添加域名解析的地址，即向“C:\Windows\System32\Drivers\etc\hosts"文件中添加如下内容：&lt;/h4&gt;
&lt;!-- more --&gt;

&lt;p&gt;```&lt;/p&gt;
&lt;h1 id="xmarks"&gt;Xmarks&lt;/h1&gt;
&lt;p&gt;64.147.188.86 www.xmarks.com
64.147.188.92 api.xmarks.com
64.147.188.89 login.xmarks.com
64.147.188.87 sync.xmarks.com
64.147.188.86 static.xmarks.com
64.147.188.86 download.xmarks.com
64.147.188.86 my.xmarks.com
```&lt;/p&gt;
&lt;h4 id="2-xmarksconnection-securityencrypt-all"&gt;2. 设置Xmarks连接及传输数据过程中加密，即在"Connection Security"中选择"Encrypt All"。&lt;/h4&gt;
&lt;p&gt;以上两步即可解决Xmarks不能同步的问题。&lt;/p&gt;
&lt;h4 id="_1"&gt;分析原因：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;第一步操作的原因在于GFW是根据URL而不是IP进行过滤的，所以在请求解析诸如"xmarks.com"等类似的域名时，返回结果被GFW拦截，所以要手动添加xmarks.com一系列服务器的域名IP；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二步操作让Xmarks在同步时对数据进行加密，GFW是无法认出加密的数据的，也就无法进一步拦截了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary><category term="Xmarks"></category><category term="Foxmarks"></category></entry><entry><title>标记ATL控件为安全控件</title><link href="http://hutaow.com/blog/2009/05/02/mark-atl-control-as-a-safe-control" rel="alternate"></link><updated>2009-05-02T14:02:00+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2009-05-02:blog/2009/05/02/mark-atl-control-as-a-safe-control</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;用ATL开发网页控件时，IE总会出现“该控件不是安全的”之类的提示，去掉这个提示的方法就是使用 IObjectSafety 将其标记为可安全初始化的控件。&lt;/p&gt;
&lt;p&gt;实现方法如下：&lt;/p&gt;
&lt;p&gt;首先在需要将 IObjectSafetyImpl 添加到该控件的派生类中，然后在映射列表中添加 IObjectSafety，具体添加的代码如下：&lt;/p&gt;
&lt;!-- more --&gt;

&lt;p&gt;``` c++
class CHutaow : 
    // 添加到控件的派生类列表中
    public IObjectSafetyImpl&lt;CHutaow, INTERFACESAFE_FOR_UNTRUSTED_CALLER|INTERFACESAFE_FOR_UNTRUSTED_DATA&gt;
    ...
    {
        public:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    BEGIN_COM_MAP(CHutaow)

    COM_INTERFACE_ENTRY(IObjectSafety) //创建IObjectSafety的映射

    ...

    END_COM_MAP()
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;p&gt;PS: 如果出现"'IObjectSafetyImpl' : base class undefined"的错误，则需要添加"atlctl.h"头文件。&lt;/p&gt;</summary><category term="C++"></category><category term="ATL"></category><category term="控件"></category></entry><entry><title>SQL语句实现某一字符串的替换</title><link href="http://hutaow.com/blog/2009/04/02/sql-statements-batch-replace-a-string" rel="alternate"></link><updated>2009-04-02T10:55:00+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2009-04-02:blog/2009/04/02/sql-statements-batch-replace-a-string</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;使用update+replace语句：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mysql
update table_name set column_name = replace(column_name,’hutaow_original_string’,'hutaow_new_string’);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中，table_name是表的名字，column_name是要替换数据的列的名字，hutaow_original_string是待替换的原始字符串，hutaow_new_string是新字符串，MySQL下验证成功。&lt;/p&gt;</summary><category term="Database"></category><category term="SQL"></category><category term="MySQL"></category><category term="数据库"></category></entry><entry><title>Java中十六进制字符串与字节数组的相互转换</title><link href="http://hutaow.com/blog/2008/08/14/convert-between-byte-array-and-hex-string" rel="alternate"></link><updated>2008-08-14T19:05:00+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2008-08-14:blog/2008/08/14/convert-between-byte-array-and-hex-string</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;原理很简单，直接贴源代码吧。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;p&gt;``` java
/&lt;em&gt;&lt;em&gt;
 &lt;/em&gt; @author wangtao
 &lt;/em&gt; @version 2008.8.14
 */
public class Util {
    public static char[] hexDigits = 
    {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};&lt;/p&gt;
&lt;p&gt;/&lt;em&gt;&lt;em&gt;
     &lt;/em&gt; @notes 字节数组转化为字符串
     &lt;/em&gt; @param bytes
     &lt;em&gt; @return String
     &lt;/em&gt;/
    public static String toHexString(byte[] bytes) {
        char[] chars = new char[bytes.length * 2];&lt;/p&gt;
&lt;p&gt;for (int i = 0; i &amp;lt; bytes.length; i++) {
            int b = bytes[i];
            chars[i * 2] = Util.hexDigits[(b &amp;amp; 0xF0) &amp;gt;&amp;gt; 4];
            chars[i * 2 + 1] = Util.hexDigits[b &amp;amp; 0x0F];
        }&lt;/p&gt;
&lt;p&gt;return new String(chars);
    }&lt;/p&gt;
&lt;p&gt;/&lt;em&gt;&lt;em&gt;
     &lt;/em&gt; @notes 字符串转化为字节数组
     &lt;/em&gt; @param str
     &lt;em&gt; @return byte[]
     &lt;/em&gt;/
    public static byte[] toByteArray(String str) { 
        int length = str.length() / 2;
        byte[] bytes = new byte[length];
        byte[] source = str.getBytes();&lt;/p&gt;
&lt;p&gt;for (int i = 0; i &amp;lt; bytes.length; ++i) {
            byte bh = Byte.decode("0x" + new String(new byte[]{source[i * 2]})).byteValue();
            bh = (byte)(bh &amp;lt;&amp;lt; 4);
            byte bl = Byte.decode("0x" + new String(new byte[]{source[i * 2 + 1]})).byteValue();
            bytes[i] = (byte)(bh ^ bl);
        }&lt;/p&gt;
&lt;p&gt;return bytes;
    }
}
```&lt;/p&gt;</summary><category term="Java"></category></entry><entry><title>终端下使用代理的方法</title><link href="http://hutaow.com/blog/2008/08/10/config-proxy-in-linux-terminal" rel="alternate"></link><updated>2008-08-10T15:12:00+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2008-08-10:blog/2008/08/10/config-proxy-in-linux-terminal</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;很长时间都不知道怎么设置，今天突然发现，设置四个环境变量就行了，"HTTP_PROXY"、"http_proxy"和"FTP_PROXY"、"ftp_proxy"，在"~/.bash_profile"中添加以下几行：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;export HTTP_PROXY=http://username:password@proxy.server:8080
export FTP_PROXY=http://username:password@proxy.server:8080
export http_proxy=http://username:password@proxy.server:8080
export ftp_proxy=http://username:password@proxy.server:8080&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中，username和password是用户名和密码，用在需要验证的代理服务器上；proxy.server是代理服务器的地址，后面的8080是端口号。&lt;/p&gt;
&lt;p&gt;修改保存后重启终端或在执行"source ~/.bash_proxy"生效。&lt;/p&gt;</summary><category term="Linux"></category><category term="代理"></category></entry><entry><title>Fedora 9 无法启动KDE的解决办法</title><link href="http://hutaow.com/blog/2008/07/29/slove-the-problem-that-kde-can-not-start-in-fedora-9" rel="alternate"></link><updated>2008-07-29T11:34:00+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2008-07-29:blog/2008/07/29/slove-the-problem-that-kde-can-not-start-in-fedora-9</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;今天突然想再尝试一下KDE的环境，而且传说中的KDE4出了那么久，还一直没有用过，于是兴致勃勃的安装上了KDE的桌面环境。Logout-&amp;gt;KDE，结果却报出个错误，说"Could not start kstartupconfig4. Check your installation"，无语，难道是我少装了什么东西？&lt;/p&gt;
&lt;p&gt;按照它说的检查，结果没问题啊，kstartupconfig4已经安装好了，于是又上网查，google出好多解决办法，不过基本上都是用"chown"改变"~/.kde"目录的所有者，哦？检查……"~/.kde"这个目录竟然是root的，原来是权限的问题。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;p&gt;输入"chown -R owner ~/.kde"，为了保险，再加个"chgrp -R group ~/.kde"，这里面的"owner"和"group"分别是当前的用户名和用户所在的组名。&lt;/p&gt;
&lt;p&gt;之后重新进入KDE，一切正常！&lt;/p&gt;
&lt;p&gt;PS：新的KDE环境确实做的不错，桌面右上角的widget加上suse的主菜单非常赞&lt;/p&gt;</summary><category term="Linux"></category><category term="KDE"></category></entry><entry><title>Linux下将.cue/.bin转换为.iso的方法</title><link href="http://hutaow.com/blog/2008/07/19/convert-cue-and-bin-to-iso-format-in-linux" rel="alternate"></link><updated>2008-07-19T17:20:00+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2008-07-19:blog/2008/07/19/convert-cue-and-bin-to-iso-format-in-linux</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;从学校的FTP上下了个Windows 2000 Advance Server光盘镜像，打算装在虚拟机里，结果发现下下来的镜像是.cue/.bin格式的，VirtualBox还用不了，于是跑google上搜了一大堆linux里转换.iso格式的软件，发现一个叫"bchunk"的小软件非常好用，而且小的可以，才几十K，很不错。&lt;/p&gt;
&lt;p&gt;在终端里输入如下命令：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bchunk e-w2sp4ru1as.bin e-w2sp4ru1as.cue e-w2sp4ru1as.iso&lt;/code&gt;&lt;/p&gt;
&lt;!-- more --&gt;

&lt;p&gt;其中，e-w2sp4ru1as.e-w2sp4ru1as.cue是原来的镜像名，e-w2sp4ru1as.iso是转换后想要保存的文件名。&lt;/p&gt;
&lt;p&gt;等一小会儿，就像下面这幅图一样，会有一个进度条，进度到100%后转换就完成了。
&lt;img alt="Convert CUE and BIN to ISO format" src="/images/articles/200807/convert_cue_and_bin_to_iso_format_in_linux.png" /&gt;&lt;/p&gt;</summary><category term="Linux"></category><category term="工具"></category></entry><entry><title>新版VirtualBox在Fedora下不能启动虚拟机的解决办法</title><link href="http://hutaow.com/blog/2008/07/18/slove-the-problem-of-new-version-virtualbox-can-not-start-virtual-machine-in-fedora" rel="alternate"></link><updated>2008-07-18T20:48:00+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2008-07-18:blog/2008/07/18/slove-the-problem-of-new-version-virtualbox-can-not-start-virtual-machine-in-fedora</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;前一段时间突然发现VirtualBox被Sun收购了，改名成"Sun xVM VirtualBox"，于是兴致勃勃的安上了最新版，结果发现虚拟机启动不了了，提示错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;VirtualBox kernel driver not installed. The vboxdrv kernel module was either not loaded or /dev/vboxdrv was not created for some reason. 
Re-setup the kernel module by executing ‘/etc/init.d/vboxdrv setup’ as root.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;于是按照提示在终端里执行"sudo /etc/init.d/vboxdrv setup"时，却又提示VirtualBox的内核模块无法编译，查看日志发现是没有安装内核源代码。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;p&gt;于是执行"sudo yum install kernel-devel"，等待系统自动下载并安装。注意这里我用的Linux是Fedora，如果是其它发行版可以执行相应的安装命令，唯一相同的是软件包"kernel-devel"名字不变。&lt;/p&gt;
&lt;p&gt;安装完成后，再次执行"sudo /etc/init.d/vboxdrv setup"，搞定！&lt;/p&gt;</summary><category term="Linux"></category><category term="VirtualBox"></category><category term="Fedora"></category></entry><entry><title>二维条码终于有了突破!</title><link href="http://hutaow.com/blog/2008/04/02/mark-breakthrough-for-dimensional-bar-code-decoder" rel="alternate"></link><updated>2008-04-02T12:21:00+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2008-04-02:blog/2008/04/02/mark-breakthrough-for-dimensional-bar-code-decoder</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;自己改写了几个类，这几天不停的测试测试测试，今天终于成功解码，不过因为字符编码还没彻底弄好，所以解出来的还都是乱码，不过英文已经可以解析出来了，值得纪念的一天!&lt;/p&gt;
&lt;!-- more --&gt;

&lt;p&gt;&lt;img alt="Breakthrough for Dimensional Bar Code Decoder" src="/images/articles/200804/mark_breakthrough_for_dimensional_bar_code_decoder.png" /&gt;&lt;/p&gt;</summary><category term="Android"></category></entry><entry><title>因字符编码导致的编译不通过</title><link href="http://hutaow.com/blog/2008/03/20/compilation-failed-due-to-character-encoding" rel="alternate"></link><updated>2008-03-20T15:08:00+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2008-03-20:blog/2008/03/20/compilation-failed-due-to-character-encoding</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;从网上下了QR标准的二维码库，打算直接调用里面的类来实现。在Fedora下Java编译通过，只是提示了一下使用了过时的方法。但我把代码复制到Windows里时，却编译不同过，出现了近1k个错误，代码完全一样，只是操作系统不同就会出问题？&lt;/p&gt;
&lt;!-- more --&gt;

&lt;p&gt;回想在Windows里用UltraEdit打开时，提示文件不是"DOS Format"，会不会和文字编码有关？Linux用的是UTF-8的编码，而Windows用的是GBK的编码，难道字符编码必须要和本地相同才能编译通过么？试一下，于是把代码用UltraEdit转换成了GBK编码，再次编译，终于正常通过。&lt;/p&gt;
&lt;p&gt;看来有时编译不通过不一定是语句问题，连文件的编码也有可能出问题，如果在不同系统中出现类似上面一个正常一个错误的情况，可以考虑看是不是因为文件的编码和系统默认的编码有差异而引起的。&lt;/p&gt;</summary><category term="Linux"></category><category term="Java"></category><category term="字符编码"></category></entry><entry><title>Fedora禁止自动挂载分区的方法</title><link href="http://hutaow.com/blog/2008/02/17/disable-automatically-mount-partitions-under-fedora" rel="alternate"></link><updated>2008-02-17T21:28:00+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2008-02-17:blog/2008/02/17/disable-automatically-mount-partitions-under-fedora</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;Fedora在启动时会自动把系统中的其它分区挂载，为了对自动挂载的分区进行一定的限制，就要改变相应的策略，这一策略存放在"/usr/share/hal/fdi/policy/10osvendor/20-storage-methods.fdi"文件中。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;p&gt;找到以下提示行&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;!-- Here follow volumes we specifically want to ignore - it is the --&amp;gt;
&amp;lt;!-- responsibility of software higher in the stack (e.g. gnome-vfs) --&amp;gt;
&amp;lt;!-- amd mount programs (e.g. Mount() on HAL) to respect volume.ignore --&amp;gt;
&amp;lt;merge key="volume.ignore" type="bool"&amp;gt;false&amp;lt;/merge&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;按照说明在提示之后添加对磁盘挂载的策略即可，比如我自己的硬盘就是&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;match key="volume.fstype" string="vfat"&amp;gt;
  &amp;lt;match key="volume.label" string="DATA"&amp;gt;
    &amp;lt;merge key="volume.ignore" type="bool"&amp;gt;true&amp;lt;/merge&amp;gt;
  &amp;lt;/match&amp;gt;
  &amp;lt;match key="volume.label" string="MULTI"&amp;gt;
    &amp;lt;merge key="volume.ignore" type="bool"&amp;gt;true&amp;lt;/merge&amp;gt;
  &amp;lt;/match&amp;gt;
  &amp;lt;match key="volume.label" string="BACKUP"&amp;gt;
    &amp;lt;merge key="volume.ignore" type="bool"&amp;gt;true&amp;lt;/merge&amp;gt;
  &amp;lt;/match&amp;gt;
&amp;lt;/match&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中"volume.fstype"后面的值就是匹配的文件系统，"volume.label"后面的值是匹配的卷标，"volume.ignore"中的参数是"true"，意思是忽略被匹配的分区。&lt;/p&gt;</summary><category term="Linux"></category><category term="Fedora"></category></entry><entry><title>解决安装ntfs-3g时遇到的问题</title><link href="http://hutaow.com/blog/2008/02/15/slove-the-problem-on-install-ntfs-3g" rel="alternate"></link><updated>2008-02-15T20:16:00+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2008-02-15:blog/2008/02/15/slove-the-problem-on-install-ntfs-3g</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;今天安装了CentOS，结果发现好多软件源里都没有，看来又要手动安装了，为了挂载ntfs分区，跑去&lt;a href="http://www.ntfs-3g.org"&gt;http://www.ntfs-3g.org&lt;/a&gt;下载ntfs-3g，安装好后，试图执行"mount -t ntfs-3g /dev/hdc5 /media/wdata"，结果提示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FATAL: Module fuse not found.
fuse: device not found, try 'modprobe fuse' first
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- more --&gt;

&lt;p&gt;冷不丁的冒出这么个错误提示，有点措手不及的感觉，于是按照提示执行"modprobe fuse"，结果又出来：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FATAL: Module fuse not found.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没有fuse模块？用Google搜到了&lt;a href="http://fuse.sourceforge.net"&gt;http://fuse.sourceforge.net&lt;/a&gt;，看上面说明的意思是说fuse(Filesystem in Userspace)是个库，提供了API供用户开发文件系统，看样子通过它开发文件系统又会方便不少，最后只要连接到fuse库上就可以了。呵呵，不管怎么说先下载了安装再说，这些以后有时间再慢慢研究吧。下载后解压，执行下面的命令编译安装fuse：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;./configure
make
make install&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;装好后再次执行mount命令，完成！&lt;/p&gt;</summary><category term="Linux"></category></entry><entry><title>Android命令行下的编译和运行</title><link href="http://hutaow.com/blog/2008/02/13/compile-android-project-in-command-line" rel="alternate"></link><updated>2008-02-13T15:51:00+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2008-02-13:blog/2008/02/13/compile-android-project-in-command-line</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;想学到东西还是要从命令行开始，真正学到之后再考虑用IDE。下面总结一下在命令行下android工程的创建、编译、运行和调试的方法。&lt;/p&gt;
&lt;h3 id="1"&gt;1 工程的创建&lt;/h3&gt;
&lt;p&gt;在要存放工程的目录下用执行"activityCreator.py --out hutaow edu.bupt.hutaow.example" &lt;/p&gt;
&lt;p&gt;说明如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;activityCreator.py，创建工程的脚本文件，linux里使用"activityCreator.py"，如果是windows，则应当换成"activityCreator.bat"&lt;/li&gt;
&lt;li&gt;--out hutaow，其中hutaow是生成工程的输出目录，执行android工程的所有文件都会放在这个目录里&lt;/li&gt;
&lt;li&gt;edu.bupt.hutaow.example，这个是包的名称以及类的名称，其中最后一个字段是生成的类的名称，edu.bupt.hutaow是example类所在的包&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;

&lt;p&gt;命令执行后会在hutaow目录下生成工程的所有文件。&lt;/p&gt;
&lt;p&gt;执行后终端输出如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;package: edu.bupt.hutaow
out_dir: hutaow
activity_name: example
Created directory hutaow/src/edu/bupt/hutaow
Added file hutaow/src/edu/bupt/hutaow/example.java
Created directory hutaow/bin
Created directory hutaow/res/values
Added file hutaow/res/values/strings.xml
Created directory hutaow/res/layout
Added file hutaow/res/layout/main.xml
Added file hutaow/AndroidManifest.xml
Added file hutaow/build.xml&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="2"&gt;2 工程的编译&lt;/h3&gt;
&lt;p&gt;这里编译需要用到Ant，Ant是Apache出的用于编译Java工程文件的工具，Android是基于Java设计的，所以这里要用到它，Ant可以在&lt;a href="http://ant.apache.org"&gt;http://ant.apache.org&lt;/a&gt;下载的到，具体安装过程和Java、Android差不多，都是解压出来后设置环境变量，可以参考Linux中设置Java环境变量。&lt;/p&gt;
&lt;p&gt;使用Ant编译直接在工程目录下执行简单的一条"ant"即可，不用任何参数，Ant会根据build.xml文件中的描述自动进行相关的语法检查、依赖分析等等一些工作，最终将编译好的文件输出在工程的bin目录下。&lt;/p&gt;
&lt;p&gt;执行后终端输出如下：&lt;/p&gt;
&lt;p&gt;```
Buildfile: build.xml&lt;/p&gt;
&lt;p&gt;dirs:
    [mkdir] Created dir: /home/wangtao/Documents/android/hutaow/bin/classes&lt;/p&gt;
&lt;p&gt;resource-src:
     [echo] Generating R.java...&lt;/p&gt;
&lt;p&gt;aidl:&lt;/p&gt;
&lt;p&gt;compile:
    [javac] Compiling 2 source files to /home/wangtao/Documents/android/hutaow/bin/classes&lt;/p&gt;
&lt;p&gt;dex:&lt;/p&gt;
&lt;p&gt;package-res:&lt;/p&gt;
&lt;p&gt;package-res-no-assets:
     [echo] Packaging resources...&lt;/p&gt;
&lt;p&gt;package-dex:
     [echo] Packaging dex...&lt;/p&gt;
&lt;p&gt;package:&lt;/p&gt;
&lt;p&gt;BUILD SUCCESSFUL
Total time: 6 seconds
```&lt;/p&gt;
&lt;h3 id="3"&gt;3 程序的运行及调试&lt;/h3&gt;
&lt;p&gt;这里要用到的工具是android的调试工具adb，由它来完成程序的安装工作。首先在命令行输入"emulator"启动android模拟器。&lt;/p&gt;
&lt;p&gt;然后等模拟器完全启动好后，执行"adb install bin/example.apk"，即将example.apk安装到模拟器中。&lt;/p&gt;
&lt;p&gt;最终在模拟器的"Applications"分类中找到"example"执行程序。&lt;/p&gt;
&lt;p&gt;执行后终端输出如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;* daemon not running. starting it now *
33 KB/s (4170 bytes in 0.120s)&lt;/code&gt;&lt;/p&gt;</summary><category term="Android"></category></entry><entry><title>Linux中改变网卡的速度</title><link href="http://hutaow.com/blog/2008/02/11/change-the-spped-of-network-adapter-under-linux" rel="alternate"></link><updated>2008-02-11T18:28:00+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2008-02-11:blog/2008/02/11/change-the-spped-of-network-adapter-under-linux</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;今天又用到家里的那根20几米的超长网线了，因为太长了，之前windows里用它联网的时候要把网卡速度降到10Mbps才能用。如果自动配置的话会默认用100Mbps的速度连接，但这样的话就会时断时连很不稳定。&lt;/p&gt;
&lt;p&gt;我在Linux里试图在Network里直接配置速度，但没有找到，上网google发现需要手动修改，用到的工具是mii-tool。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;p&gt;用管理员权限执行如下命令&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mii-tool -A 10baseT-FD eth0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;eth0是网卡的名称，"10baseT-FD"是网卡的工作模式，如果要改回100Mbps的话这里填"100baseTx-FD"；&lt;/p&gt;
&lt;p&gt;FD指的是Full Duplex全双工，也可以是HD即Half Duplex半双工。&lt;/p&gt;</summary><category term="Linux"></category><category term="工具"></category></entry><entry><title>解决MPlayer中文字幕显示问题</title><link href="http://hutaow.com/blog/2008/02/02/slove-mplayer-chinese-subtitles-problems" rel="alternate"></link><updated>2008-02-02T21:44:00+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2008-02-02:blog/2008/02/02/slove-mplayer-chinese-subtitles-problems</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;MPlayer在播放电影时，中文字幕往往不能正确显示，自己简单分析了一下，之所以中文显示出乱码是由于字符的编码选择不正确造成的。&lt;/p&gt;
&lt;p&gt;在MPlayer的设置里有两个地方要对字符编码进行设置，一个是对显示字幕的编码进行设置，另一个是对字体文件的编码设置。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;p&gt;对于字幕的编码，就是要显示中文、英文、法文还是其它文字；而对于字体的编码，则是需要根据提供的字体文件严格选择对应的编码。明白了以上两点，再进行设置就不难了。&lt;/p&gt;
&lt;p&gt;具体的设置过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先选择字幕编码，在MPlayer的设置中选择"Subtitle &amp;amp; OSD"选项卡，在"Encoding"选单中选择"Simplified Chinese charset (CP936)"。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接下来是字体编码，先要选择一个中文字体，"Font"选项卡中，在"Font"一栏选择一个中文字体(个人建议将自己的字体放在~/.fonts目录下，然后再到这个目录中选择相应的字体)。字体选择好后，在"Encoding"选单中选择"Unicode"，因为unicode是国际通用的字符编码标准，一般的字体编码都是unicode，所以此处要选择"Unicode"而不是"CP936"。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;确定保存后重新播放中文字幕就可以正常显示了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary><category term="Linux"></category><category term="MPlayer"></category></entry><entry><title>Rhythmbox播放MP3和WMA所需要的解码器</title><link href="http://hutaow.com/blog/2008/02/02/rhythmbox-play-mp3-and-wma-format-decoder-required" rel="alternate"></link><updated>2008-02-02T08:45:00+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2008-02-02:blog/2008/02/02/rhythmbox-play-mp3-and-wma-format-decoder-required</id><summary type="html">&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;如果想支持mp3，需要gstreamer-plugins-bad和gstreamer-plugins-ugly&lt;/li&gt;
&lt;li&gt;如果想支持wma，需要gstreamer-ffmpeg&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Linux"></category><category term="Rhythmbox"></category></entry><entry><title>用Android做了一个计算器</title><link href="http://hutaow.com/blog/2008/01/30/android-calculator" rel="alternate"></link><updated>2008-01-30T11:50:00+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2008-01-30:blog/2008/01/30/android-calculator</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;这两天一直在看xml，昨天简单的做了一个计算器，算是实地练习一下，熟悉一下Android的开发过程，不过有些小问题还没有顾及，还有就是界面可能稍显难看了一些。&lt;/p&gt;
&lt;p&gt;运行时的截图：
&lt;img alt="Android Calculator" src="/images/articles/200801/android_calculator.png" /&gt;&lt;/p&gt;
&lt;p&gt;源代码地址：&lt;a href="https://github.com/hutaow/AndroidCalculator"&gt;点击这里&lt;/a&gt;&lt;/p&gt;
&lt;!-- more --&gt;

&lt;p&gt;PS: 今天整理的时候发现一个问题，这个程序是我原来用Android SDK的m3版本生成编译的，现在SDK的最新版本是m5，结果在m5里竟然编译不通过。解决方法是可以重新创建一个项目，直接将源代码部分复制粘贴过去就可以了，新的项目仍然可以编译运行，我想应该是build.xml那个文件里的问题，版本、结构上google可能改了一些，不过不碍大事。&lt;/p&gt;</summary><category term="Android"></category></entry><entry><title>对Android布局的理解</title><link href="http://hutaow.com/blog/2008/01/28/understanding-on-the-android-layout" rel="alternate"></link><updated>2008-01-28T20:13:00+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2008-01-28:blog/2008/01/28/understanding-on-the-android-layout</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;前一段时间一直在考试，现在放假了，有时间好好的看了一下Android的布局。&lt;/p&gt;
&lt;p&gt;之前对于XML的布局方法一直看着不爽，感觉很乱的样子，但时间长了我渐渐发现，这种程序代码与界面布局完全分开的方法非常顺手，该布局的地方都到main.xml里去写，甚至界面中显示的字符串都可以集中到string.xml文件中，而主程序的".java"文件中则完全用于编写代码，思路非常清晰。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;h3 id="1"&gt;1 首先按照程序的目录结构大致分析&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;res/layout/   这个目录存放的就是布局用的xml文件，一般默认为main.xml
res/values/   这个目录存放的是一堆常量的xml文件
res/drawable/ 存放的是一些图片什么的，当然图标也在这里
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="2-layoutxml"&gt;2 下面主要对layout下的xml文件做个介绍，顺便也把布局的方法总结一下&lt;/h3&gt;
&lt;h4 id="21"&gt;2.1 文件的开头&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;?xml version="1.0" encoding="utf-8"?&amp;gt;&lt;/code&gt;
这是在说明xml版本及字符编码&lt;/p&gt;
&lt;h4 id="22"&gt;2.2 布局框架&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
  android:layout_width="wrap_content"
  android:layout_height="wrap_content"&amp;gt;
&amp;lt;/LinearLayout&amp;gt;&lt;/code&gt;
其中开头的"LinearLayout"是布局的方式，可以有很多种，最常用的应该就是Linear了，其他的布局方法等下在后面总结。&lt;/p&gt;
&lt;p&gt;接着android:layout_width(height)="wrap_content"是在设置这部分布局的宽高，也可以是绝对值，当然设置为绝对值时要标上单位。&lt;/p&gt;
&lt;h4 id="23"&gt;2.3 添加控件&lt;/h4&gt;
&lt;p&gt;在"\&amp;lt;LinearLayout&gt;"和"\&amp;lt;/LinearLayout&gt;"之间就可以添加控件了，比如要添加一个名字为btn的Button控件，并且Button上显示的文字是"Test!"，可以这样写：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;Button id="@+id/btn" 
  android:text="Test!"
  android:layout_width="wrap_content"
  android:layout_height="wrap_content"
/&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;开头id后面的就是控件名称，在用于添加事件Listener时会用到，而下几行的android:xxx就是设置控件的属性了，这些属性在Android的文档中都有，不需要特别去记，一般现查就可以了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;有一点要说明的是，布局方法可以嵌套，有点像java中的Container，可以非常方便的把界面“堆”出来。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;布局方式的简单说明：
查了Android文档发现布局确实很多，只列出两个我自己认为较常用的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LinearLayout线性的布局方式，要么上下，要么左右的添加控件，很常用&lt;/li&gt;
&lt;li&gt;GridView中文翻译过来是网格布局，控件按照顺序依次填到每个格子里就好了，出来的界面会很整齐&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他的布局方式可以在需要时查文档，这里不再列出。&lt;/p&gt;</summary><category term="Android"></category></entry><entry><title>初学Android的一点问题</title><link href="http://hutaow.com/blog/2008/01/11/android-beginner-question" rel="alternate"></link><updated>2008-01-11T11:33:00+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2008-01-11:blog/2008/01/11/android-beginner-question</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;前几天一直在看Android的文档，有些收获但同时还是有问题。&lt;/p&gt;
&lt;h4 id="1-androidlayout"&gt;1 问题：关于Android的Layout&lt;/h4&gt;
&lt;p&gt;似乎和java有很大的不同，Android引入了XML，从google所给的例子来看，控件的布局方式都是写在XML文件里，而主程序中需要的只是add并且引用XML文件中的布局方式。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;p&gt;这种方法对我来说并不是很习惯，毕竟java用了那么长时间，在代码中直接setLayout感觉更舒服些。当然既然google采用了这种布局和代码分离的方式那就肯定有它的优点，看来还需要一点的时间来习惯这种布局方式。&lt;/p&gt;
&lt;h4 id="2-android"&gt;2 总结：我自己对Android几个模块的理解&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;Activity：类似java中的Applet或Frame，以我的理解，这个类提供了程序的最基本框架。
Intent Receiver：翻译过来是“目的接收器”，和java中的listener类似，用于处理事件。
Service：后台运行的服务，长贮内存中，个人认为这一块最可能出现安全问题。
Content Provider：主要用在数据存贮和交换，根据官方文档所说，不仅仅是存储数据，还可以是在不同程序、不同设备之间的数据交换。
&lt;/code&gt;&lt;/pre&gt;</summary><category term="Android"></category></entry><entry><title>Linux中设置Java环境变量</title><link href="http://hutaow.com/blog/2007/09/22/config-java-environment-in-linux" rel="alternate"></link><updated>2007-09-22T13:38:00+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2007-09-22:blog/2007/09/22/config-java-environment-in-linux</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;从网上找资料，自己总结一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;从java.sun.com上下载jdk，解压到某个目录，比如"/usr/local/java/jdk1.x.x/"&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改~/.bashrc文件，在文件末尾加入以下几行：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;export JAVA_HOME=/usr/java/j2sdk1.x.x
export PATH=$JAVA_HOME/bin:$PATH
export CLASSPATH=.:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:$CLASSPATH&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最后重启终端或执行source ~/.bashrc即可。&lt;/p&gt;</summary><category term="Linux"></category><category term="Java"></category></entry><entry><title>我的VI配置文件</title><link href="http://hutaow.com/blog/2007/08/19/my-vi-config" rel="alternate"></link><updated>2007-08-19T14:02:00+08:00</updated><author><name>hutaow</name></author><id>tag:hutaow.com,2007-08-19:blog/2007/08/19/my-vi-config</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;```
" 设置字符编码
set encoding=utf-8
set termencoding=utf-8
set fileencoding=utf-8
set fileencodings=utf-8,ucs-bom,gb2312,gb18030,gbk,cp936&lt;/p&gt;
&lt;p&gt;" 设置文件格式(unix=LF,dos=CRLF,mac=CR)
set fileformat=unix
set fileformats=unix,dos,mac&lt;/p&gt;
&lt;p&gt;" 提示信息语言
set langmenu=en_US.utf-8
language messages en_US.utf-8&lt;/p&gt;
&lt;p&gt;" 开启文件类型检测
filetype on&lt;/p&gt;
&lt;p&gt;" 开启语法高亮
syntax on&lt;/p&gt;
&lt;p&gt;" 显示行号
set number&lt;/p&gt;
&lt;p&gt;" 设置缩进大小
set tabstop=4
set softtabstop=4
set shiftwidth=4&lt;/p&gt;
&lt;p&gt;" 将制表符用空格代替
set expandtab&lt;/p&gt;
&lt;p&gt;" 关闭兼容模式(使用VIM的键盘模式)
set nocompatible&lt;/p&gt;
&lt;p&gt;" 历史记录数量
set history=1000&lt;/p&gt;
&lt;p&gt;" 设置关键字符(遇到以下字符连接的单词时不进行换行)
set iskeyword+=_,$,@,%,#,-&lt;/p&gt;
&lt;p&gt;" 设置退格键模式
set backspace=indent,eol,start&lt;/p&gt;
&lt;p&gt;" 设置列提示(右下角)
set ruler&lt;/p&gt;
&lt;p&gt;" 设置状态提示(左下角)
set showmode&lt;/p&gt;
&lt;p&gt;" 启动的时候不显示提示信息
set shortmess=atI&lt;/p&gt;
&lt;p&gt;" 关闭错误信息响铃
set noerrorbells&lt;/p&gt;
&lt;p&gt;" 设置(括号)匹配模式
set showmatch&lt;/p&gt;
&lt;p&gt;" 搜索时实时匹配关键字
set incsearch&lt;/p&gt;
&lt;p&gt;" 搜索时高亮关键字
set hlsearch&lt;/p&gt;
&lt;p&gt;" 设置自动缩进
set autoindent&lt;/p&gt;
&lt;p&gt;" 设置结构缩进(换行时缩进与当前行相同)
set smartindent&lt;/p&gt;
&lt;p&gt;" 关闭自动备份
set nobackup&lt;/p&gt;
&lt;p&gt;" 设置当前行/列高亮
set cursorline
" set cursorcolumn&lt;/p&gt;
&lt;p&gt;" 设置背景色主题
set background=dark&lt;/p&gt;
&lt;p&gt;" 主题颜色
colorscheme desert &lt;/p&gt;
&lt;p&gt;" 状态行显示内容
set statusline=%F%m%r%h%w\ [FORMAT=%{&amp;amp;ff}:%{&amp;amp;fenc!=''?&amp;amp;fenc:&amp;amp;enc}]\ [TYPE=%Y]\ %r%h%=[POS=%l,%v][%p%%]\ [%{strftime(\"%Y/%m/%d\ %H:%M\")}]&lt;/p&gt;
&lt;p&gt;" 状态行显示模式(0=不显示,1=两个窗口以上显示,2=始终显示)
set laststatus=2&lt;/p&gt;
&lt;p&gt;" 设置字体
set guifont=Terminus:h10:cANSI&lt;/p&gt;
&lt;p&gt;" 设置窗口大小
" set lines=35 columns=128&lt;/p&gt;
&lt;p&gt;" GUI 隐藏菜单栏
" set guioptions-=m&lt;/p&gt;
&lt;p&gt;" GUI 隐藏工具栏
set guioptions-=T
```&lt;/p&gt;
&lt;p&gt;源文件下载：&lt;a href="/downloads/code/hutaow.vimrc"&gt;链接&lt;/a&gt;&lt;/p&gt;</summary><category term="Linux"></category><category term="VI"></category><category term="配置文件"></category></entry></feed>